capability WebServer(
    intenalSystem: NodeSystem
    internalHost: String
    internalPort: Int
    mutable internalJsWebSockets: JsValue
    mutable internalJsWildcard: JsValue
    mutable internalJsHosts: Array[JsValue]
    mutable internalJsApp: JsValue
)

class WebRequest[T](
    internalJsApp: JsValue
    internalJsContext: JsValue
    internalMethod: String
    internalPath: String
    internalQuery: String
    internalHeaders: StringMap[String]
    internalJsResponse: JsValue
    internalResponse: Option[T]
    internalResponseHeaders: StringMap[String]
    internalResponseChunks: Array[JsValue]
    mutable internalResponseStatus: String
    mutable internalCloseConnection: Bool
    mutable internalResolveFlush: JsValue
    mutable internalContentSize: Int
    mutable internalResponded: Bool
)

capability WebResponse {}

data MultipartField {}

capability WebSocketConnection {}

new(
    system: NodeSystem
    host: String
    port: Int
): WebServer {
    WebServer(system, host, port, system.js().null(), system.js().null(), [].toArray(), system.js().null())
}

extend self: WebServer {
    
    enableWebSockets(
        maxPayloadBytes: Int = 16384
        maxBackpressureBytes: Int = 65536
        closeDueToMaxBackpressureBytes: Bool = False
        maxLifetime: Option[Duration] = None
        idleTimeout: Option[Duration] = None
    ) {
        self.internalJsWebSockets = self.intenalSystem.js().object()
        self.internalJsWebSockets.set("maxPayloadLength", maxPayloadBytes)
        self.internalJsWebSockets.set("maxBackpressureBytes", maxBackpressureBytes)
        self.internalJsWebSockets.set("closeOnBackpressureLimit", closeDueToMaxBackpressureBytes)
        maxLifetime.each {self.internalJsWebSockets.set("maxLifetime", (_.seconds / 60).round().toInt())}
        idleTimeout.each {self.internalJsWebSockets.set("idleTimeout", _.seconds.round().toInt())}
    }
    
    addHost(
        hostname: String
        key: Option[Path] = None
        certificate: Option[Path] = None
        certificateAuthority: Option[Path] = None
        passphrase: Option[String] = None
        dhParameters: Option[Path] = None
        ciphers: Option[String] = None
        preferLowMemoryUsage: Bool = False
    ) {
        let object = self.intenalSystem.js().object().with("hostname", hostname)
        key.each {object.set("key_file_name", _.absolute())}
        certificate.each {object.set("cert_file_name", _.absolute())}
        certificateAuthority.each {object.set("ca_file_name", _.absolute())}
        passphrase.each {object.set("passphrase", _)}
        dhParameters.each {object.set("dh_params_file_name", _.absolute())}
        ciphers.each {object.set("ssl_ciphers", _)}
        if(preferLowMemoryUsage) {object.set("ssl_prefer_low_memory_usage", True)}
        self.internalJsHosts.push(object)
    }

    setWildcard(
        key: Option[Path] = None
        certificate: Option[Path] = None
        certificateAuthority: Option[Path] = None
        passphrase: Option[String] = None
        dhParameters: Option[Path] = None
        ciphers: Option[String] = None
        preferLowMemoryUsage: Bool = False
    ) {
        let object = self.intenalSystem.js().object()
        key.each {object.set("key_file_name", _.absolute())}
        certificate.each {object.set("cert_file_name", _.absolute())}
        certificateAuthority.each {object.set("ca_file_name", _.absolute())}
        passphrase.each {object.set("passphrase", _)}
        dhParameters.each {object.set("dh_params_file_name", _.absolute())}
        ciphers.each {object.set("ssl_ciphers", _)}
        if(preferLowMemoryUsage) {object.set("ssl_prefer_low_memory_usage", True)}
        self.internalJsWildcard = object
    }
    
    listen(handler: WebRequest[WebResponse] => Unit) {
        let uws = Js.import("uWebSockets.js")
        Js.awaitCancellablePromise {resolveServer, rejectServer, onSettleServer =>
            self.internalJsApp = if(!self.internalJsWildcard.isNullOrUndefined()) {
                uws->SSLApp(self.internalJsWildcard)
            } elseIf {self.internalJsHosts.any {h => h->"key_file_name".truthy()}} {
                uws->SSLApp()
            } else {
                uws->App()
            }
            self.internalJsHosts.each {h => 
                self.internalJsApp->addServerName(h->hostname, h)
            }
            let handleRequest = Js->{res, req, context => 
                mutable abortedByUws = False
                let method = req->getMethod()?
                let path = req->getUrl()?
                let query = req->getQuery().coalesce("")?
                let headers = StringMap.new()
                req->forEach(Js->{key, value => headers.set(key?, value?)})
                let chunks = Array.new()
                let task = Js.currentTask().spawn {task => 
                    try {
                        task.throwIfAborted()
                        let webRequest = WebRequest(
                            internalJsApp = self.internalJsApp
                            internalJsContext = context
                            internalMethod = method
                            internalPath = path
                            internalQuery = query
                            internalHeaders = headers
                            internalJsResponse = res
                            internalResponse = None
                            internalResponseHeaders = StringMap.new()
                            internalResponseChunks = Array.new()
                            internalResponseStatus = "200 OK"
                            internalCloseConnection = False
                            internalResolveFlush = Js.null()
                            internalContentSize = -1
                            internalResponded = False
                        );
                        handler(webRequest)
                        task.throwIfAborted()
                        if(context.nullish() && !webRequest.internalResponded && webRequest.internalContentSize >= 0) {
                            webRequest.flush()
                            task.throwIfAborted()
                        }
                        if(context.nullish() && !webRequest.internalResponded) {
                            Js.awaitCancellablePromise {resolve, reject, onSettle => 
                                res->cork(Js->{
                                    try {
                                        // Js.throwIfCancelled() <- TODO ignored in sync context
                                        if(webRequest.internalResolveFlush.falsy()) {
                                            res->writeStatus(webRequest.internalResponseStatus)
                                            webRequest.internalResponseHeaders.each {key, value => 
                                                res->writeHeader(key, value)
                                            }
                                        }
                                        let chunk = internalChunksToChunk(webRequest.internalResponseChunks)
                                        res->end(chunk, webRequest.internalCloseConnection)
                                        resolve(Unit)
                                    } catchAny {e =>
                                        reject(e)
                                    }
                                })
                            }
                        }
                    } catchAny {e =>
                        if(!abortedByUws) {Js->console->error(e)}
                        if(!abortedByUws && context.nullish()) {
                            res->cork(Js->{
                                if(!abortedByUws) {res->writeStatus("500 Internal Server Error")}
                                if(!abortedByUws) {res->end()}
                            })
                        }
                    }
                }
                res->onAborted(Js->{
                    abortedByUws = True
                    task.abort()
                })
            }
            self.internalJsApp->any("/*", handleRequest)
            if(!self.internalJsWebSockets.nullish()) {
                self.internalJsApp->ws("/*", self.internalJsWebSockets
                    .with("upgrade", handleRequest)
                    .with("open", Js->{ws => ws->getUserData()->onOpen(ws)})
                    .with("message", Js->{ws, m, b => ws->getUserData()->onMessage(m, b)})
                    .with("close", Js->{ws => ws->getUserData()->onClose()})
                )
            }
            self.internalJsApp->listen(self.internalHost, self.internalPort, Js->{listenSocket =>
                if(!listenSocket.nullish()) {
                    mutable abort = Js->{}
                    abort = Js->{
                        Js.currentTask().controller->signal->removeEventListener("abort", abort)
                        uws->"us_listen_socket_close"(listenSocket)
                        self.internalJsApp->close()
                    }
                    Js.currentTask().controller->signal->addEventListener("abort", abort)
                } else {
                    rejectServer(Js->Error->("listenSocket was nullish")?)
                }
                Unit
            })
        }
    }

    publishBuffer(topic: String, message: Buffer) { // Should this be corked?
        if(!self.internalJsApp.nullish()) {
            self.internalJsApp->publish(topic, message!->buffer, True)
        }
    }
    
    publishText(topic: String, message: String) { // Should this be corked?
        if(!self.internalJsApp.nullish()) {
            self.internalJsApp->publish(topic, message, False)
        }
    }
}

extend self[T]: WebRequest[T] {

    readMethod(): String {
        self.internalMethod
    }

    readPath(): String {
        self.internalPath
    }

    readRawQueryString(): String {
        self.internalQuery
    }

    readQuery(name: String): Option[String] {
        if(self.internalQuery.size() == 0) {None} else:
        let ps = self.internalQuery.split('&')
        let n = name + "="
        ps.find {p => p == name || p.startsWith(n)}.map {r => 
            Js->decodeURIComponent(r.dropFirst(n.size()))?
        }
    }
    
    readHeader(lowerCaseName: String): Option[String] {
        self.internalHeaders.get(lowerCaseName)
    }
    
    eachHeader(body: (String, String) => Unit) {
        self.internalHeaders.each {body(_, _)}
    }
    
}

extend self[T]: WebRequest[T] {
    
    writeStatus(codeAndMessage: String) {
        self.internalResponseStatus = codeAndMessage
    }
    
    writeHeader(name: String, value: String) {
        self.internalResponseHeaders.set(name, value)
    }
    
    writeContentSize(contentSize: Int) {
        if(contentSize >= 0) {
            self.internalContentSize = contentSize
        }
    }

    writeText(data: String) {
        self.internalResponseChunks.push(internalTextChunk(data))
    }

    writeLine(data: String) {
        self.writeText(data + "\n")
    }

    writeBuffer(data: Buffer) {
        self.internalResponseChunks.push(internalBufferChunk(data))
    }
    
    writeStream(data: Stream[Buffer]) {
        data.each {self.writeBuffer(_)}
    }

}

extend self[T]: WebRequest[T] {

    publishBuffer(topic: String, message: Buffer) { // Should this be corked?
        self.internalJsApp->publish(topic, message!->buffer, True)
    }
    
    publishText(topic: String, message: String) { // Should this be corked?
        self.internalJsApp->publish(topic, message, False)
    }

}

extend self[T]: WebRequest[T] {
    
    closeConnection() {
        self.internalCloseConnection = True
    }
    
    readRemoteAddress(): String {
        Js->TextDecoder->()->decode(self.internalJsResponse->getRemoteAddressAsText())?
    }

    readProxiedRemoteAddress(): String {
        Js->TextDecoder->()->decode(self.internalJsResponse->getProxiedRemoteAddressAsText())?
    }

}

extend self: WebRequest[WebResponse] {

    flush() {
        if(self.internalResolveFlush.nullish()) {
            self.internalResolveFlush = Js->{}
            self.internalJsResponse->cork(Js->{
                self.internalJsResponse->writeStatus(self.internalResponseStatus)
                self.internalResponseHeaders.each {key, value =>
                    self.internalJsResponse->writeHeader(key, value)
                }
                self.internalJsResponse->onWritable(Js->{
                    self.internalResolveFlush.callValue0()
                    True
                })
            })
        }
        while {!self.internalResponseChunks.isEmpty()} {
            Js.awaitCancellablePromise {resolve, reject, onSettle =>
                self.internalJsResponse->cork(Js->{
                    mutable backpressure = False
                    mutable i = 0
                    while {i < self.internalResponseChunks.size() && !backpressure} {
                        let rawChunk = self.internalResponseChunks.grab(i)
                        let chunk = if(rawChunk.typeof() != "string") {
                            Js->Uint8Array->(rawChunk!->buffer, rawChunk!->byteOffset, rawChunk!->byteLength)
                        } else {
                            Js->TextEncoder->()->encode(rawChunk)
                        }
                        if(self.internalContentSize >= 0) {
                            let lastOffset = self.internalJsResponse->getWriteOffset()?
                            let pair = self.internalJsResponse->tryEnd(chunk, self.internalContentSize)
                            let ok = pair.get(0)
                            let responded = pair.get(1)
                            if(!ok?) {
                                let written = self.internalJsResponse->getWriteOffset() - lastOffset
                                backpressure = True
                                self.internalResponseChunks.set(i, Js->Uint8Array->(chunk->buffer, chunk->byteOffset + written, chunk->byteLength - written))
                                i -= 1
                            }
                        } else {
                            backpressure = !self.internalJsResponse->write(chunk)?
                        }
                        i += 1
                    }
                    if(i > 0) {
                        self.internalResponseChunks.delete(0, i)
                    }
                    if(!backpressure) {
                        resolve(Unit)
                    } else {
                        self.internalResolveFlush = Js->{resolve(Unit)}
                    }
                })
            }
        }
    }

    flushText(data: String) {
        self.writeText(data)
        self.flush()
    }

    flushBuffer(data: Buffer) {
        self.writeBuffer(data)
        self.flush()
    }

    flushStream(data: Stream[Buffer]) {
        data.each {self.flushBuffer(_)}
    }

}

extend self: WebRequest[WebResponse] {
    
    readText(encoding: String = "utf8"): String {
        self.readStream(1073741823).toString(encoding)
    }
    
    readBuffer(): Buffer {
        self.readStream(1073741823).toBuffer()
    }
    
    readStream(maxPendingBytes: Int = 65536): Stream[Buffer]
        target js async """
            const front = [];
            const back = [];
            let pendingBytes = 0
            let closed = false;
            let callResolve = null;
            let callReject = null;
            self_.internalJsResponse_.onData((chunk, isLast) => {
                if(closed) return;
                if(isLast) closed = true; 
                else chunk = cunk.slice();
                pendingBytes += chunk.byteLength;
                back.push(new DataView(chunk));
                if(pendingBytes >= maxPendingBytes_) self_.internalJsResponse_.pause();
                if(callResolve) callResolve();
            });
            const abort = () => {
                $task.controller_.signal.removeEventListener('abort', abort);
                if(callReject) callReject();
            }
            $task.controller_.signal.addEventListener('abort', abort);
            return ff_core_Stream.Stream(
                async () => {
                    while(true) {
                        ff_core_Task.Task_throwIfAborted($task);
                        if(front.length === 0) {
                            while(back.length !== 0) front.push(back.pop());
                        }
                        if(front.length !== 0) {
                            const chunk = front.pop();
                            const paused = pendingBytes >= maxPendingBytes_;
                            pendingBytes -= chunk.byteLength;
                            if(!closed && paused && pendingBytes < maxPendingBytes_) self_.internalJsResponse_.unpause();
                            return ff_core_Option.Some(chunk);
                        } else if(closed) {
                            return ff_core_Option.None();
                        } else {
                            await new Promise((resolve, reject) => {
                                callResolve = resolve;
                                callReject = reject;
                            });
                            callResolve = null;
                            callReject = null;
                        }
                    }
                },
                async () => {
                    closed = true;
                    ff_core_Task.Task_throwIfAborted($task);
                    if(callResolve) callResolve();
                }
            )
        """
    
}

extend self[T]: WebRequest[T] {
    
    needsWebSocket(): Bool
        target js sync """
            return self_.internalJsContext_ != null;
        """
    
}

extend self: WebRequest[WebResponse] {
    
    openWebSocket(): WebSocketConnection
        target js async """
            ff_core_Task.Task_throwIfAborted($task);
            const userData = {};
            const wrapper = {front: [], back: [], listeners: [], task: $task};
            const promise = new Promise((resolve, reject) => {
                const abort = () => {wrapper.webSocket = null; reject()};
                userData.onOpen = ws => {wrapper.webSocket = ws; resolve(wrapper)};
                userData.onClose = () => {
                    $task.controller_.signal.removeEventListener('abort', abort);
                    abort();
                    for(let i = 0; i < wrapper.listeners.length; i++) wrapper.listeners[i]();
                    wrapper.listeners.length = 0;
                };
                userData.onMessage = (message, isBinary) => {
                    wrapper.back.push(isBinary ? new DataView(message) : new TextDecoder().decode(message));
                    for(let i = 0; i < wrapper.listeners.length; i++) wrapper.listeners[i]();
                    wrapper.listeners.length = 0;
                };
                $task.controller_.signal.addEventListener('abort', abort);
            });
            self_.internalJsResponse_.cork(() => {
                ff_core_Task.Task_throwIfAborted($task);
                self_.internalJsResponse_.upgrade(
                    userData, 
                    self_.internalHeaders_.get('sec-websocket-key'),
                    self_.internalHeaders_.get('sec-websocket-protocol'),
                    self_.internalHeaders_.get('sec-websocket-extensions'),
                    self_.internalJsContext_
                )
            });
            return await promise;
        """

}

extend self: WebSocketConnection {
    
    readText(encoding: String = "utf8"): Option[String] {
        self.readAny {_} {_.toString(encoding)}
    }

    readBuffer(): Option[Buffer] {
        self.readAny {_.toBuffer()} {_}
    }
    
    readAny[T](fromText: String => T, fromBuffer: Buffer => T): Option[T]
        target node async """
            ff_core_Task.Task_throwIfAborted($task);
            while(self_.front.length === 0) {
                while(self_.back.length !== 0) {
                    self_.front.push(self_.back.pop());
                }
                if(self_.front.length !== 0) break;
                if(self_.webSocket == null) return ff_core_Option.None();
                let abort = null;
                try {
                    await new Promise((resolve, reject) => {
                        self_.listeners.push(resolve);
                        if($task !== self_.task) {
                            abort = () => {
                                self_.listeners = self_.listeners.filter(l => l != resolve);
                                reject();
                            };
                            $task.controller_.signal.addEventListener('abort', abort);
                        }
                    });
                } finally {
                    if($task !== self_.task) {
                        $task.controller_.signal.removeEventListener('abort', abort);
                    }
                }
            }
            const data = self_.front.pop();
            if(typeof data === 'string') return ff_core_Option.Some(await fromText_(data));
            return ff_core_Option.Some(await fromBuffer_(data));
        """
        
    readStream(): Stream[Buffer] {
        Stream {self.readBuffer()} {self.close()}
    }
    
    writeBuffer(message: Buffer)
        target node async """
            await internalSend_$(self_, () => self_.webSocket.send(message_.buffer, true) !== 2, $task);
        """
    
    writeText(message: String)
        target node async """
            await internalSend_$(self_, () => self_.webSocket.send(message_, false) !== 2, $task);
        """
    
    publishBuffer(topic: String, message: Buffer)
        target node async """
            await internalSend_$(self_, () => self_.webSocket.publish(topic_, message_.buffer, true), $task);
        """
    
    publishText(topic: String, message: String)
        target node async """
            await internalSend_$(self_, () => self_.webSocket.publish(topic_, message_, false), $task);
        """

    subscribe(topic: String)
        target node async """
            if(self_.webSocket == null) throw new Error("WebSocket is closed");
            self_.webSocket.subscribe(topic_);
        """

    unsubscribe(topic: String)
        target node async """
            if(self_.webSocket == null) throw new Error("WebSocket is closed");
            self_.webSocket.unsubscribe(topic_);
        """

    isSubscribedTo(topic: String): Bool
        target node async """
            if(self_.webSocket == null) throw new Error("WebSocket is closed");
            return self_.webSocket.isSubscribed(topic_);
        """
        
    subscriptions(): Array[String]
        target node async """
            if(self_.webSocket == null) throw new Error("WebSocket is closed");
            return self_.webSocket.getTopics();
        """

    close(): Unit
        target node async """
            if(self_.webSocket != null) {
                self_.webSocket.close();
                self_.webSocket = null;
            }
        """

}

internalSend[T](self: WebSocketConnection, send: () => Bool): JsValue
    target node async """
        let abort = null;
        try {
            await new Promise((resolve, reject) => {
                if(self_.webSocket == null) new Error("WebSocket is closed");
                else self_.webSocket.cork(() => {
                    if($task !== self_.task) {
                        abort = () => {
                            self_.listeners = self_.listeners.filter(l => l != resolve);
                            reject();
                        };
                        $task.controller_.signal.addEventListener('abort', abort);
                    }
                    if(self_.webSocket == null) {
                        reject(new Error("WebSocket is closed"));
                    } else if(!send_()) {
                        reject(new Error("Dropped message due to backpressure"));
                    } else {
                        resolve();
                    }
                })
            });
        } finally {
            if($task !== self_.task) {
                $task.controller_.signal.removeEventListener('abort', abort);
            }
        }
    """

internalArray[T](): Array[T] {
    Array.new()
}

internalTextChunk(data: String): JsValue
    target js sync """
        return data_;
    """
    
internalBufferChunk(data: Buffer): JsValue
    target js sync """
        return data_;
    """

internalChunksToChunk(chunks: Array[JsValue]): JsValue
    target js sync """
        const chunks = chunks_.array;
        if(chunks.length === 0) return;
        const firstIsString = typeof chunks[0] === 'string';
        if(firstIsString && chunks.length === 1) return chunks[0];
        if(firstIsString && chunks.every(c => typeof c === 'string')) {
            let result = chunks[0];
            for(let i = 1; i < chunks.length; i++) {
                result += chunks[i];
            }
            return result;
        }
        let totalLength = 0;
        for(let i = 0; i < chunks.length; i++) {
            if(typeof chunks[i] === 'string') chunks[i] = new TextEncoder().encode(chunks[i]);
            totalLength += chunks[i].byteLength;
        }
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for(let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];
            const uint8Array = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            result.set(uint8Array, offset);
            offset += chunk.byteLength;
        }
        return result;
    """

parseMultipartFields(data: Buffer, contentType: String): Option[Array[MultipartField]] {
    let uws = Js.import("uWebSockets.js")
    let parts = uws->getParts(data, contentType)
    if(!parts.nullish()) {parts?}
}

extend self: MultipartField {
    
    data(): Buffer {
        Js->DataView->(self!->data)?
    }

    name(): String {
        self!->name?
    }

    type(): Option[String] {
        if(!self!->type.nullish()) {self!->type?}
    }

    filename(): Option[String] {
        if(!self!->filename.nullish()) {self!->filename?}
    }

}
