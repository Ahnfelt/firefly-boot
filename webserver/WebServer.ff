class WebRequest[T](
    internalMethod: String
    internalUrl: String
    internalHeaders: StringMap[String]
    internalJsResponse: JsValue
    internalResponse: T
    internalResponseHeaders: StringMap[String]
    internalResponseChunks: Stack[JsValue]
    mutable internalResponseSize: Int
    mutable internalResponseStatus: String
    mutable internalCloseConnection: Bool
)

capability WebResponse(
    internalRequestBody: Stream[Buffer]
)

listen(system: NodeSystem, host: String, port: Int, handler: WebRequest[WebResponse] => Unit): Unit
    target node async """
        import * as uws from 'uWebSockets.js'
        ff_core_Task.Task_throwIfAborted($task);
        uws.App().any('/*', (res, req) => {
            ff_core_Task.Task_spawn($task, async task => {
                try {
                    const body = internalBody_(res, task);
                    const method = req.getMethod();
                    const url = req.getUrl();
                    const headers = new Map();
                    req.forEach((key, value) => headers.set(key, value));
                    const chunks = internalStack_();
                    const webResponse = WebResponse(body);
                    const webRequest = WebRequest(
                        method, url, headers, 
                        res, webResponse, 
                        new Map(), internalStack_(), 
                        0, "200 OK", false
                    );
                    await handler_(webRequest, task);
                } catch(e) {
                    
                }
            });
        }).listen(host_, port_, listenSocket => {
            if(listenSocket) {
                console.log('Listening to port ' + port_);
            }
        });
    """

nodeMain(system: NodeSystem) {
    listen(system, "localhost", 8080) {request =>
        request.writeHeader("IsExample", "Oh Yes")
        request.writeText("Hello!")
    }
}

extend self[T]: WebRequest[T] {

    readMethod(): String {
        self.internalMethod
    }

    readRelativeUrl(): String {
        self.internalUrl
    }

    readPath(): String {
        self.internalUrl.takeWhile {_ != '?'}
    }

    readQueryString(): String {
        self.internalUrl.dropWhile {_ != '?'}
    }

    readHeader(lowerCaseName: String): Option[String] {
        self.internalHeaders.get(lowerCaseName)
    }
    
    eachHeader(body: (String, String) => Unit) {
        self.internalHeaders.each {body(_, _)}
    }
    
}

extend self[T]: WebRequest[T] {
    
    writeStatus(codeAndMessage: String) {
        self.internalResponseStatus = codeAndMessage
    }
    
    writeHeader(name: String, value: String) {
        self.internalResponseHeaders.set(name, value)
    }

    writeText(data: String) {
        self.internalResponseChunks.push(internalTextChunk(data))
    }

    writeBuffer(data: Buffer) {
        self.internalResponseChunks.push(internalBufferChunk(data))
    }
    
    writeStream(data: Stream[Buffer]) {
        data.each {self.writeBuffer(_)}
    }

}

extend self[T]: WebRequest[T] {
    
    closeConnection() {
        self.internalCloseConnection = True
    }

}

extend self: WebRequest[WebResponse] {
    
    flush()
        target js async """
            // TODO
        """

    flushText(data: String) {
        self.writeText(data)
        self.flush()
    }

    flushBuffer(data: Buffer) {
        self.writeBuffer(data)
        self.flush()
    }

    flushStream(data: Stream[Buffer]) {
        self.writeStream(data)
        self.flush()
    }

}

extend self: WebRequest[WebResponse] {
    
    readBody(): Stream[Buffer] {
        self.internalResponse.internalRequestBody
    }
    
}

internalBody(jsResponse: JsValue): Stream[Buffer] {
    Stream {None} {} // TODO
}

internalStack[T](): Stack[T] {
    Stack.make()
}

internalTextChunk(data: String): JsValue
    target js sync """
        return data
    """
    
internalBufferChunk(data: Buffer): JsValue
    target js sync """
        return data.buffer; // TODO: Copy if byteOffset != 0 || byteLength != buffer.length
    """
