class WebRequest[T](
    internalMethod: String
    internalPath: String
    internalQuery: String
    internalHeaders: StringMap[String]
    internalJsResponse: JsValue
    internalResponse: T
    internalResponseHeaders: StringMap[String]
    internalResponseChunks: Stack[JsValue]
    mutable internalResponseStatus: String
    mutable internalCloseConnection: Bool
    mutable internalResolveFlush: JsValue
    mutable internalContentSize: Int
    mutable internalResponded: Bool
)

capability WebResponse {}

data MultipartField {}

listen(system: NodeSystem, host: String, port: Int, handler: WebRequest[WebResponse] => Unit): Unit
    target node async """
        import * as uws from 'uWebSockets.js'
        ff_core_Task.Task_throwIfAborted($task);
        await new Promise((resolveServer, rejectServer) => uws.App().any('/*', (res, req) => {
            let abortedByUws = false;
            const task = ff_core_Task.Task_spawn($task, async task => {
                try {
                    ff_core_Task.Task_throwIfAborted(task);
                    const body = internalBody_(res, task);
                    const method = req.getMethod();
                    const path = req.getUrl();
                    const query = req.getQuery() || '';
                    const headers = new Map();
                    req.forEach((key, value) => headers.set(key, value));
                    const chunks = internalStack_();
                    const webRequest = WebRequest(
                        method, path, query, headers, 
                        res, null, 
                        new Map(), internalStack_(), 
                        "200 OK", false, null, -1, false
                    );
                    await handler_(webRequest, task);
                    ff_core_Task.Task_throwIfAborted(task);
                    if(!webRequest.internalResponded_) await new Promise((resolve, reject) => {
                        res.cork(() => {
                            try {
                                ff_core_Task.Task_throwIfAborted(task);
                                if(!webRequest.internalResolveFlush_) {
                                    res.writeStatus(webRequest.internalResponseStatus_);
                                    webRequest.internalResponseHeaders_.forEach((value, key) => res.writeHeader(key, value));
                                }
                                const chunk = internalChunksToChunk_(webRequest.internalResponseChunks_);
                                res.end(chunk, webRequest.internalCloseConnection_);
                                resolve();
                            } catch(e) {
                                reject(e);
                            }
                        });
                    });
                } catch(e) {
                    if(!abortedByUws) console.error(e);
                    if(!abortedByUws) res.cork(() => {
                        if(!abortedByUws) res.writeStatus("500 Internal Server Error");
                        if(!abortedByUws) res.end();
                    });
                }
            });
            res.onAborted(() => {
                abortedByUws = true; 
                ff_core_Task.Task_abort(task);
            });
        }).listen(host_, port_, listenSocket => {
            if(listenSocket) {
                const abort = () => {
                    $task.controller.signal.removeEventListener('abort', abort);
                    uws.us_listen_socket_close(listenSocket);
                }
                $task.controller.signal.addEventListener('abort', abort);
            } else {
                rejectServer();
            }
        }));
    """

nodeMain(system: NodeSystem) {
    listen(system, "localhost", 8080) {request =>
        if(request.readPath() != "/") {request.writeStatus("404 Not Found")} else:
        request.writeHeader("IsExample", request.readQuery("foo").else {"None"})
        request.writeContentSize(500000 * "Hello ".size() + "world!".size())
        1.to(500000).each {_ => request.writeText("Hello ")}
        request.flush()
        request.writeText("world!")
    }
}

extend self[T]: WebRequest[T] {

    readMethod(): String {
        self.internalMethod
    }

    readPath(): String {
        self.internalPath
    }

    readRawQueryString(): String {
        self.internalQuery
    }

    readQuery(name: String): Option[String]
        target node sync """
            if(self_.internalQuery_.length === 0) return ff_core_Option.None();
            const ps = self_.internalQuery_.split('&');
            const n = name_ + '=';
            const r = ps.find(p => p === name_ || p.startsWith(n));
            if(r == null) return ff_core_Option.None();
            return ff_core_Option.Some(decodeURIComponent(r.slice(name_.length + 1)));
        """
    
    readHeader(lowerCaseName: String): Option[String] {
        self.internalHeaders.get(lowerCaseName)
    }
    
    eachHeader(body: (String, String) => Unit) {
        self.internalHeaders.each {body(_, _)}
    }
    
}

extend self[T]: WebRequest[T] {
    
    writeStatus(codeAndMessage: String) {
        self.internalResponseStatus = codeAndMessage
    }
    
    writeHeader(name: String, value: String) {
        self.internalResponseHeaders.set(name, value)
    }
    
    writeContentSize(contentSize: Int) {
        if(contentSize >= 0) {
            self.internalContentSize = contentSize
        }
    }

    writeText(data: String) {
        self.internalResponseChunks.push(internalTextChunk(data))
    }

    writeBuffer(data: Buffer) {
        self.internalResponseChunks.push(internalBufferChunk(data))
    }
    
    writeStream(data: Stream[Buffer]) {
        data.each {self.writeBuffer(_)}
    }

}

extend self[T]: WebRequest[T] {
    
    closeConnection() {
        self.internalCloseConnection = True
    }
    
    readRemoteAddress(): String
        target js sync """
            return new TextDecoder().decode(self_.internalJsResponse_.getRemoteAddressAsText())
        """

    readProxiedRemoteAddress(): String
        target js sync """
            return new TextDecoder().decode(self_.internalJsResponse_.getProxiedRemoteAddressAsText())
        """

}

extend self: WebRequest[WebResponse] {

    flush()
        target js async """
            if(!self_.internalResolveFlush_) {
                self_.internalResolveFlush_ = () => {};
                self_.internalJsResponse_.cork(() => {
                    self_.internalJsResponse_.writeStatus(self_.internalResponseStatus_);
                    self_.internalResponseHeaders_.forEach((value, key) =>
                        self_.internalJsResponse_.writeHeader(key, value)
                    );
                    self_.internalJsResponse_.onWritable(() => {
                        self_.internalResolveFlush_();
                        return true;
                    });
                });
            }
            while(self_.internalResponseChunks_.array.length !== 0) {
                await new Promise((resolve, reject) => {
                    self_.internalJsResponse_.cork(() => {
                        let backpressure = false;
                        let i = 0;
                        for(i = 0; i < self_.internalResponseChunks_.array.length && !backpressure; i++) {
                            let chunk = self_.internalResponseChunks_.array[i];
                            if(chunk && (chunk.byteLength || chunk.length)) {
                                if(typeof chunk !== 'string' && chunk.byteLength !== chunk.buffer.byteLength) {
                                    chunk = chunk.buffer.subarray(chunk.byteOffset, chunk.byteOffset + chunk.byteLength);
                                }
                                if(self_.internalContentSize_ >= 0) {
                                    const [ok, responded] = self_.internalJsResponse_.tryEnd(chunk, self_.internalContentSize_);
                                    backpressure = !ok;
                                    if(responded) self_.internalResponded_ = true;
                                } else {
                                    backpressure = !self_.internalJsResponse_.write(chunk);
                                }
                            }
                        }
                        if(backpressure && self_.internalContentSize_ >= 0) i -= 1;
                        if(i > 0) self_.internalResponseChunks_.array = self_.internalResponseChunks_.array.slice(i);
                        if(!backpressure) {
                            resolve();
                        } else {
                            self_.internalResolveFlush_ = resolve;
                        }
                    });
                });
            }
        """

    flushText(data: String) {
        self.writeText(data)
        self.flush()
    }

    flushBuffer(data: Buffer) {
        self.writeBuffer(data)
        self.flush()
    }

    flushStream(data: Stream[Buffer]) {
        data.each {self.flushBuffer(_)}
    }

}

extend self: WebRequest[WebResponse] {
    
    readText(encoding: String = "utf8"): String {
        self.readStream(1073741823).toString(encoding)
    }
    
    readBuffer(): Buffer {
        self.readStream(1073741823).toBuffer()
    }
    
    readStream(maxPendingBytes: Int = 65536): Stream[Buffer]
        target js async """
            const front = [];
            const back = [];
            let pendingBytes = 0
            let closed = false;
            let callResolve = null;
            let callReject = null;
            self_.internalJsResponse_.onData((chunk, isLast) => {
                if(closed) return;
                if(isLast) closed = true; 
                else chunk = cunk.slice();
                pendingBytes += chunk.byteLength;
                back.push(new DataView(chunk));
                if(pendingBytes >= maxPendingBytes_) self_.internalJsResponse_.pause();
                if(callResolve) callResolve();
            });
            const abort = () => {
                $task.controller.signal.removeEventListener('abort', abort);
                if(callReject) callReject();
            }
            $task.controller.signal.addEventListener('abort', abort);
            return ff_core_Stream.Stream(
                async () => {
                    while(true) {
                        ff_core_Task.Task_throwIfAborted($task);
                        if(front.length === 0) {
                            while(back.length !== 0) front.push(back.pop());
                        }
                        if(front.length !== 0) {
                            const chunk = front.pop();
                            const paused = pendingBytes >= maxPendingBytes_;
                            pendingBytes -= chunk.byteLength;
                            if(!closed && paused && pendingBytes < maxPendingBytes_) self_.internalJsResponse_.unpause();
                            return ff_core_Option.Some(chunk);
                        } else if(closed) {
                            return ff_core_Option.None();
                        } else {
                            await new Promise((resolve, reject) => {
                                callResolve = resolve;
                                callReject = reject;
                            });
                            callResolve = null;
                            callReject = null;
                        }
                    }
                },
                async () => {
                    closed = true;
                    ff_core_Task.Task_throwIfAborted($task);
                    if(callResolve) callResolve();
                }
            )
        """
    
}

internalBody(jsResponse: JsValue): Stream[Buffer] {
    Stream {None} {} // TODO
}

internalStack[T](): Stack[T] {
    Stack.make()
}

internalTextChunk(data: String): JsValue
    target js sync """
        return data_;
    """
    
internalBufferChunk(data: Buffer): JsValue
    target js sync """
        return data_;
    """

internalChunksToChunk(chunks: Stack[JsValue]): JsValue
    target js sync """
        const chunks = chunks_.array;
        if(chunks.length === 0) return;
        const firstIsString = typeof chunks[0] === 'string';
        if(firstIsString && chunks.length === 1) return chunks[0];
        if(firstIsString && chunks.every(c => typeof c === 'string')) {
            let result = chunks[0];
            for(let i = 1; i < chunks.length; i++) {
                result += chunks[i];
            }
            return result;
        }
        let totalLength = 0;
        for(let i = 0; i < chunks.length; i++) {
            if(typeof chunks[i] === 'string') chunks[i] = new TextEncoder().encode(chunks[i]);
            totalLength += chunks[i].byteLength;
        }
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for(let i = 0; i < chunks.length; i++) {
            const chunk = chunks[i];
            const uint8Array = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            result.set(uint8Array, offset);
            offset += chunk.byteLength;
        }
        return result;
    """

parseMultipartFields(data: Buffer, contentType: String): Option[Array[MultipartField]]
    target js sync """
        const parts = getParts(data_, contentType_);
        return parts == null ? ff_core_Option.None() : ff_core_Option.Some(parts);
    """

extend self: MultipartField {
    
    data(): Buffer
        target js sync """
            return new DataView(self_.data);
        """

    name(): String
        target js sync """
            return self_.name;
        """

    type(): Option[String]
        target js sync """
            return self_.type == null ? ff_core_Option.None() : ff_core_Option.Some(self_.type);
        """

    filename(): Option[String]
        target js sync """
            return self_.filename == null ? ff_core_Option.None() : ff_core_Option.Some(self_.filename);
        """

}
