import LspHook from ff:compiler
import Unification from ff:compiler
import Environment from ff:compiler
import Syntax from ff:compiler
import Handler

data CompletionInfo(
    label: String
    extra: String
    snippet: String
    member: Bool
    type: Type
    documentation: String
    expectedType: Option[Type]
    secondarySort: Int = 5
)

handleCompletion(lspHook: LspHook, toplevel: Bool, followedByOpenBracket: Bool): Json {
    let topLevelCompletions = if(!toplevel) {[]} else {toplevelCompletion(lspHook)}
    let patternCompletions = lspHook.results().collectFirst {
        | InferPatternHook h =>
            let expected = h.unification.substitute(h.expected)
            Some(patternCompletion(h.unification, h.environment, expected))
        | _ =>
            None
    }
    mutable sawLookupHook = False // Only consider the first lookup
    mutable sawParameterOrVariantFieldHook = False // Rewrite the type completions to parameter completions
    mutable typeCompletions = []
    let completions = patternCompletions.else {lspHook.results().flatMap {
        | ResolveTypeHook h =>
            typeCompletions = [...typeCompletions, ...typeCompletion(h.types, h.typeGenerics)]
            []
        | ResolveVariantFieldHook _ =>
            sawParameterOrVariantFieldHook = True
            []
        | InferLambdaStartHook h =>
            h.unification.substitute(h.lambdaType).{
                | TConstructor(_, "Function$1", [_, TConstructor(_, prefix, _), _]) =>
                    exhaustiveMatchCompletion(h.environment, prefix + "_", True)
                | _ =>
                    []
            }
        | InferLookupHook h {!sawLookupHook && !h.symbol.value.qualifiedName.startsWith("_")} =>
            sawLookupHook = True
            let typePrefix = if(h.symbol.value.qualifiedName.contains("_")) {
                h.symbol.value.qualifiedName.reverse().dropWhile {_ != '_'}.reverse()
            } else {
                ""
            }
            let expected = h.unification.substitute(h.expected)
            let qualifiedByAlias = h.symbol.value.qualifiedName.{n => 
                if(n.contains(".") && !n.contains("/") && !n.contains(":")) {n.takeWhile {_ != '.'}}
            }
            h.selfVariable.{
                | Some(selfName) {typePrefix == "" && qualifiedByAlias == None} {
                    h.environment.symbols.get(selfName) | Some(scheme)
                } {
                    scheme.signature.returnType | TConstructor(_, selfTypeName, _)
                } => 
                    let otherCompletions = completion(h.unification, h.environment, "", None, expected)
                    let selfCompletions = h.environment.symbols.get(selfName).toList().flatMap {scheme =>
                        let prefix = selfTypeName + "_"
                        completion(h.unification, h.environment, prefix, None, expected).filter {
                            _.label.first().any {_.isAsciiLower()}
                        }.map {c =>
                            c.CompletionInfo(label = selfName + "." + c.label, snippet = selfName + "." + c.snippet)
                        }
                    }
                    [...otherCompletions, ...selfCompletions]
                | _ => 
                    completion(h.unification, h.environment, typePrefix, qualifiedByAlias, expected)
            }
        | InferRecordFieldHook h {h.unification.substitute(h.recordType) | TConstructor(_, n, ts)} =>
            let fieldNames = n.split('$').toList().dropFirst(1)
            let fieldCompletions = fieldNames.zip(ts).map {| Pair(name, t) =>
                let t2 = h.unification.substitute(t)
                CompletionInfo(name, "", name, True, t2, "(\n    ...\n    " + name + ": " + t2.show([]) + "\n    ...\n)", Some(h.expected))
            }
            [...fieldCompletions, ...completion(h.unification, h.environment, n, None, h.expected)]
        | InferArgumentHook h {
            ![ // Avoids named argument suggestions for operators that become trait method calls, such as ==
                "ff:core/Equal.equals", "ff:core/Equal.notEquals"
                "ff:core/Ordering.before", "ff:core/Ordering.notBefore"
                "ff:core/Ordering.after", "ff:core/Ordering.notAfter"
            ].any {_ == h.callName}
        } =>
            let usedNames = h.arguments.pairs().filter {| Pair(i, a) => i != h.argumentIndex}.collect {_.second.name}
            let usedPlaces = h.arguments.takeFirst(h.argumentIndex).filter {_.name.isEmpty()}.size()
            let remainingParameters = h.parameters.filter {p => !usedNames.any {_ == p.name}}.dropFirst(usedPlaces)
            let preselect = h.isCopy || usedNames.size() != 0
            remainingParameters.pairs().map {| Pair(i, p) =>
                namedParameterCompletion(p, i, preselect)
            }
        | InferTermHook h {h.term | ELet _} =>
            h.missing.toList().filter {_.first.all {_.isAsciiLetterOrDigit()}}.flatMap {
                | Pair(x, Pair(instantiated, None)) =>
                    missingCompletion(False, False, h.unification, x, instantiated, None)
                | _ =>
                    []
            }
        | InferSequentialStartHook h {h.term | ESequential(_, before, _)} =>
            function lastIsVariable(term: Term): Bool {
                | ESequential(_, _, e) => lastIsVariable(e)
                | EVariable _ => True
                | _ => False
            }
            if(!lastIsVariable(before)) {[]} else:
            h.missing.toList().filter {| Pair(x, _) =>
                x.size() != 0 && x.all {_.isAsciiLetterOrDigit()}
            }.flatMap {| Pair(x, Pair(instantiated, arguments)) =>
                missingCompletion(True, False, h.unification, x, instantiated, arguments)
            }
        | InferParameterHook h =>
            sawParameterOrVariantFieldHook = True
            h.missing.toList().filter {| Pair(x, _) =>
                x.size() != 0 && x.all {_.isAsciiLetterOrDigit()}
            }.flatMap {| Pair(x, Pair(instantiated, arguments)) =>
                missingCompletion(False, True, h.unification, x, instantiated, arguments)
            }
        | InferFunctionDefinitionHook h {!h.definition.signature.member} =>
            h.missing.toList().filter {| Pair(x, _) =>
                x.size() != 0 && x.all {_.isAsciiLetterOrDigit()}
            }.flatMap {| Pair(x, Pair(instantiated, arguments)) =>
                arguments.toList().flatMap {as => 
                    missingCompletion(False, False, h.unification, x, instantiated, Some(as))
                }
            }
        | InferFunctionDefinitionHook h {h.definition.signature.member} =>
            h.missing.toList().filter {_.first.contains("_")}.map {
                _.mapFirst {_.reverse().takeWhile {_ != '_'}.reverse()}
            }.filter {| Pair(x, _) =>
                x.size() != 0 && x.all {_.isAsciiLetterOrDigit()}
            }.flatMap {| Pair(x, Pair(instantiated, arguments)) =>
                arguments.toList().flatMap {as => 
                    let instantiated2 = instantiated.Instantiated(scheme = instantiated.scheme.Scheme(
                        signature = instantiated.scheme.signature.Signature(
                            parameters = instantiated.scheme.signature.parameters.dropFirst()
                        )
                    ))
                    missingCompletion(False, False, h.unification, x, instantiated2, Some(as.dropFirst()))
                }
            }
        | _ =>
            []
    }}
    let fixedTypeCompletions = if(!sawParameterOrVariantFieldHook) {typeCompletions} else {
        typeCompletions.map {c => c.CompletionInfo(snippet = 
            (c.snippet.slice(0, 1).lower() + c.snippet.dropFirst()).takeWhile {_ != '['} + ": " + c.snippet
        )}
    }
    let fixedCompletions = if(!followedByOpenBracket) {completions} else {
        completions.map {c =>
            if(c.snippet.dropFirst(1).any {c => c != '(' && c != '[' && c != '{'}) {
                c.CompletionInfo(snippet = c.snippet.takeWhile {c => c != ' ' && c != '(' && c != '[' && c != '{'})
            } else {c}
        }
    }
    completionsToJson([...fixedCompletions, ...fixedTypeCompletions, ...topLevelCompletions])
}

completionsToJson(completions: List[CompletionInfo]): Json {
    Json.object()
        .with("isIncomplete", False)
        .with("items", completions.distinct().toArray().map {| CompletionInfo i =>
            let shownType = i.type.show([])
            let isAlpha = i.label.first().any {_.isAsciiLetter()}
            let isLower = i.label.first().any {_.isAsciiLower()}
            let isUnqualified = !i.label.contains(".")
            let isMember = isLower && !isUnqualified
            let isVariable = isLower && !i.extra.contains("(") && !i.extra.contains("{")
            let isDefinition = ["let ", "mutable ", "function "].any {i.snippet.startsWith(_)}
            let isParameter = i.snippet.endsWith(" = ")
            let sortText = if(isParameter || isDefinition) {0} else {9 - (
                isVariable.toInt() + isUnqualified.toInt() +
                isAlpha.toInt() + isLower.toInt() + isMember.toInt()
            )} + if(isMember) {"1"} else {"0"} + i.secondarySort + i.label.lower()
            let preselect = !isDefinition && Pair(i.type, i.expectedType).{
                | Pair(TConstructor(_, n1, _), Some(TConstructor(_, n2, _))) => n1 == n2
                | _ => False
            }
            Json.object()
                // Namespace or Property or Constructor or EnumMember or Constructor or Method/Function or Field/Variable
                .with("kind"
                    if(shownType == "") {3} else:
                    if(isParameter) {10} else:
                    if(i.type.{| TConstructor(_, "type", _) => True | _ => False}) {9} else:
                    if(i.label.first().any {c => c == '{' || c == '|'}) {22} else:
                    if(i.label.first().any {_.isAsciiUpper()}) {4} else:
                    if(i.extra.any {c => c == '(' || c == '{'}) {2} else {5} + if(i.member) {0} else {1}
                )
                .with("sortText", sortText)
                .with("preselect", preselect)
                .with("label", i.label)
                .with("labelDetails", Json.object()
                    .with("detail", i.extra + if(shownType == "") {""} else {": " + shownType})
                )
                .with("insertText", i.snippet)
                .with("insertTextFormat", 2 /* Snippet */)
                .with("documentation", Json.object()
                    .with("kind", "markdown")
                    .with("value", "```\n" + i.documentation + "\n```")
                )
        })
}

typeCompletion(types: Map[String, String], typeGenerics: Map[String, List[String]]): List[CompletionInfo] {
    let completions = types.toList().filter {| Pair(n, full) =>
        n.all {_.isAsciiLetterOrDigit()}
    }.map {| Pair(typeName, full) =>
        let generics = typeGenerics.find {k, _ => k == typeName}.toList().flatMap {_.second}
        let realGenerics = generics.filter {_ != "Q$"}
        let label = typeName 
        let extra = if(realGenerics.isEmpty()) {""} else {"[" + realGenerics.join(", ") + "]"}
        let snippet = typeName + if(realGenerics.isEmpty()) {""} else {"[$0]"}
        CompletionInfo(label, extra, snippet, False, TConstructor(Location("", 0, 0), "type", []), full, None)
    }
    completions
}

completion(
    unification: Unification
    environment: Environment
    prefix: String
    qualifiedByAlias: Option[String]
    expected: Type
): List[CompletionInfo] {

    let member = prefix.contains("_")

    let members = Stack.make()

    let symbols = if(prefix == "") {
        environment.symbols.toList().collect {
            | Pair(name, _)@pair {name.all {_.isAsciiLetterOrDigit()}} =>
                Some(pair)
            | Pair(name, _)@pair {name.startsWith("ff:core/Core.")} =>
                Some(pair.Pair(first = name.dropFirst("ff:core/Core.".size())))
            | Pair(name, _)@pair {name.startsWith(environment.modulePrefix)} {
                name.dropFirst(environment.modulePrefix.size()) | n
            } {n.all {_.isAsciiLetterOrDigit()}} =>
                Some(pair.Pair(first = n))
            | Pair(name, scheme) {name.dropWhile {_ != '/'}.dropFirst() | short} {
                short.reverse().takeWhile {_ != '.'}.reverse() | shorter
            } {shorter.all {_.isAsciiLetterOrDigit()}} =>
                if(shorter.first().any {_.isAsciiUpper()}) {
                    Some(Pair(shorter, scheme))
                } else {
                    let module = name.dropLast(shorter.size() + 1)
                    let alias = environment.imports.find {_, i =>
                        module == i.package.groupName() + "/" + i.directory.map {_ + "/"}.join() + i.file
                    }
                    alias.map {| Pair(alias, i) =>
                        Pair(alias + short.dropFirst(i.file.size()), scheme)
                    }
                }
            | _ =>
                None
        }.toMap()
    } else {
        members.pushAll(exhaustiveMatchCompletion(environment, prefix, False).toStack())
        let shorterPrefix = prefix.dropLast()
        let recordFields = shorterPrefix.split('$').dropFirst().toSet()
        environment.symbols.each {
            | shortName, scheme {shortName.dropWhile {_ != '/'}.dropFirst() | short} {
                short.reverse().takeWhile {_ != '.'}.reverse() | shorter
            } {shorter.all {_.isAsciiLetterOrDigit()} && shorter.first().any {_.isAsciiUpper()}} =>
                scheme.signature.returnType.{
                    | _ {prefix.startsWith("Record$")} =>
                        if(scheme.signature.parameters.any {recordFields.contains(_.name)}) {
                            members.push(makeCompletion(unification, expected, "", shorter, scheme, True, member))
                        }
                    | TConstructor(_, name, _) {name.startsWith(shorterPrefix)} =>
                        if(!scheme.signature.parameters.isEmpty()) {
                            members.push(makeCompletion(unification, expected, "", shorter, scheme, True, member))
                        }
                    | _ =>
                }
            | _, _ =>
        }
        environment.symbols
    }

    let filteredSymbols = qualifiedByAlias.{
        | None => symbols
        | Some(alias) => 
            let aliasPrefix = alias + "."
            symbols.toList().filter {
                _.first.startsWith(aliasPrefix)
            }.map {
                _.mapFirst {_.dropFirst(aliasPrefix.size())}
            }.toMap()
    }

    filteredSymbols.each {memberName, memberScheme =>
        if(memberName.startsWith(prefix)) {
            members.push(makeCompletion(unification, expected, prefix, memberName, memberScheme, False, member))
        }
    }
    members.toList()
}

makeCompletion(
    unification: Unification
    expected: Type
    prefix: String
    memberName: String
    memberScheme: Scheme
    copy: Bool
    member: Bool
): CompletionInfo {
    let shortName = memberName.dropFirst(prefix.size())
    let unqualifiedName = shortName.reverse().takeWhile {_ != '.'}.reverse()
    let upper = unqualifiedName.first().any {_.isAsciiUpper()}
    let variantWithoutParameters = upper && memberScheme.signature.parameters.isEmpty()
    let realParameters = memberScheme.signature.parameters.dropFirst(if(member && !copy) {1} else {0})
    let pair = if(!memberScheme.isVariable && !variantWithoutParameters) {
        let trailing = realParameters.pairs().reverse().map {| Pair(index, p) =>
            p.valueType.{
                | TConstructor(_, name, _) {name.startsWith("Function$")} =>
                    Some(Pair(
                        " {...}"
                        if(index == 0) {" {$0}"} else {" {}"}
                    ))
                | _ =>
                    None
            }
        }.toStream().takeWhile {_ != None}.collect {_}.toList().reverse()
        let allRequired = realParameters.filter {_.default.isEmpty()}
        let required =  allRequired.dropLast(trailing.size()).map {_.name}
        let optional = if(allRequired.size() != realParameters.size()) {"..."}
        Pair(
            if(trailing.isEmpty() || !required.isEmpty()) {
                "(" + [...required, ...optional.toList()].join(", ") + ")"
            } else {
                ""
            } + trailing.map {_.first}.join()
            if(copy) {
                "(${1|" + realParameters.map {_.name}.map {f => f + " = "}.join(",") + "|}$0)"
            } else {
                if(trailing.isEmpty() || !required.isEmpty()) {
                    if(required.isEmpty()) {"()"} else {"($0)"}
                } else {
                    ""
                } + if(trailing.isEmpty()) {""} else {trailing.map {_.second}.join()}
            }
        )
    } else {Pair("", "")}
    let returnType = unification.substitute(memberScheme.signature.returnType)
    let documentation = if(memberScheme.isVariable || variantWithoutParameters) {
        let methodGenerics = memberScheme.signature.generics
        let generics = if(member || methodGenerics.isEmpty()) {""} else {"[" + methodGenerics.join(", ") + "]"}
        let beforeAfter = memberScheme.signature.parameters.first().map {
            Pair(unification.substitute(_.valueType).show([]) + "(\n    ...\n    ", "\n    ...\n)")
        }.else {Pair("", "")}
        beforeAfter.first +
        if(memberScheme.isMutable) {"mutable "} else {""} +
        unqualifiedName + generics +
        ": " + returnType.show([]) +
        beforeAfter.second
    } else {
        let selfType = memberScheme.signature.parameters.first().filter {_ => member && !copy}.map {_.valueType}
        let generics = selfType.map {
            | TConstructor(_, _, gs) =>
                // TODO: Needs constraints as well
                // TODO: This drops the wrong number of type parameters - more environment needed
                let methodGenerics = memberScheme.signature.generics.dropFirst(gs.size() + 1)
                if(methodGenerics.isEmpty()) {""} else {"[" + methodGenerics.join(", ") + "]"}
            | _ =>
                ""
        }.else {
            let methodGenerics = memberScheme.signature.generics.filter {_ != "Q$"}
            if(methodGenerics.isEmpty()) {""} else {"[" + methodGenerics.join(", ") + "]"}
        }
        let selfIndent = selfType.map {_ => "    "}.else {""}
        let parameters = if(realParameters.isEmpty()) {""} else {
            "\n" + realParameters.map {p =>
                showCompletionParameter(selfIndent + "    ", p)
            }.join("\n") + "\n" + selfIndent
        }
        selfType.map {_.show([])}.map {"extend " + _ + " {\n"}.else {""} +
        selfIndent + unqualifiedName +
        generics + "(" + parameters + "): " +
        returnType.show([]) +
        selfType.map {_ => "\n}"}.else {""}
    }
    CompletionInfo(
        label = shortName
        extra = pair.first
        snippet = shortName + pair.second
        member = member && !copy
        type = returnType
        documentation = documentation
        expectedType = Some(expected)
    )
}

exhaustiveMatchCompletion(environment: Environment, prefix: String, inside: Bool): List[CompletionInfo] {
    if(prefix == "ff:core/List.List_") {
        let curly = if(inside) {Pair("", "")} else {Pair("{", "}")}
        [CompletionInfo(
            label = curly.first + "| "
            extra = "[] => ... | [first, ...rest] => ..." + curly.second
            snippet = curly.first + "\n    | [] => $0\n    | [first, ...rest] =>\n" + curly.second
            member = True
            type = TConstructor(Location("", 0, 0), "exhaustive match", [])
            documentation = "// Exhaustive list match"
            expectedType = None
        )]
    } else:
    let shorterPrefix = prefix.dropLast()
    let variants = environment.symbols.toList().filter {s =>
        !s.first.contains("_") &&
        s.first.reverse().takeWhile {_ != '.'}.reverse().first().any {_.isAsciiUpper()} &&
        s.second.signature.returnType.{
            | TConstructor(_, n, _) => n == shorterPrefix
            | _ => False
        }
    }
    if(variants.isEmpty()) {[]} else:
    let label = if(inside) {""} else {"{"} +
        variants.map {v =>
            "| " + v.first.reverse().takeWhile {_ != '.'}.reverse() +
            if(v.second.signature.parameters.isEmpty()) {""} else {"(...)"} + " => ..."
        }.join(" ") +
        if(inside) {""} else {"}"}
    let snippetParts = variants.pairs().map {| Pair(index, Pair(name, scheme)) =>
        "| " + name.reverse().takeWhile {_ != '.'}.reverse() +
        if(scheme.signature.parameters.isEmpty()) {""} else {
            "(" + scheme.signature.parameters.map {_.name}.join(", ") + ")"
        } +
        " => " + if(index == 0) {"$0"} else {""}
    }
    let snippet =
        if(inside) {""} else {"{"} +
        if(snippetParts.size() != 1) {
            "\n" + snippetParts.map {"    " + _}.join("\n") + "\n"
        } else {
            snippetParts.join(" ")
        } +
        if(inside) {""} else {"}"}
    [CompletionInfo(
        label = label.slice(0, 2)
        extra = label.dropFirst(2)
        snippet = snippet
        member = True
        type = TConstructor(Location("", 0, 0), "exhaustive match", [])
        documentation = "// Exhaustive match:\n" + snippetParts.join("\n").replace("$0", "")
        expectedType = None
    )]
}

patternCompletion(unification: Unification, environment: Environment, expected: Type): List[CompletionInfo] {
    let typeName = unification.substitute(expected).{
        | TConstructor(_, name, _) => name
        | _ => ""
    }
    if(typeName == "") {[]} else:
    if(typeName == "ff:core/List.List") {
        [CompletionInfo("[...]", "", "[$0]", False, expected, "// List pattern", Some(expected))]
    } else:
    if(typeName == "ff:core/String.String") {
        [CompletionInfo("\"...\"", "", "\"$0\"", False, expected, "// String pattern", Some(expected))]
    } else:
    if(typeName == "ff:core/Char.Char") {
        [CompletionInfo("'...'", "", "'$0'", False, expected, "// Char pattern", Some(expected))]
    } else:
    if(typeName == "ff:core/Int.Int") {
        [CompletionInfo("0", "", "0", False, expected, "// Int pattern", Some(expected))]
    } else:
    let variants = do {
        environment.symbols.toList().filter {s =>
            !s.first.contains("_") &&
            s.first.reverse().takeWhile {_ != '.'}.reverse().first().any {_.isAsciiUpper()} &&
            s.second.signature.returnType.{
                | TConstructor(_, n, _) => n == typeName
                | _ => False
            }
        }
    }
    let completions = variants.map {| Pair(name, scheme) =>
        let shortName = name.reverse().takeWhile {_ != '.'}.reverse()
        let extra = if(scheme.signature.parameters.isEmpty()) {""} else {
            "(" + scheme.signature.parameters.map {_.name}.join(", ") + ")"
        }
        let generics = scheme.signature.generics.filter {_ != "Q$"}
        let documentation =
            shortName +
            if(generics.isEmpty()) {""} else {"[" + generics.join(", ") + "]"} +
            if(scheme.signature.parameters.isEmpty()) {""} else {
                "(\n" + scheme.signature.parameters.map {
                    showCompletionParameter("    ", _)
                }.join("\n") + "\n)"
            } + ": " + scheme.signature.returnType.show([])
        CompletionInfo(
            label = shortName
            extra = extra
            snippet = shortName + if(scheme.signature.parameters.isEmpty()) {""} else {"($0)"}
            member = False
            type = expected
            documentation = documentation
            expectedType = Some(expected)
        )
    }
    completions
}

missingCompletion(
    keyword: Bool
    isParameter: Bool
    unification: Unification
    name: String
    instantiated: Instantiated
    arguments: Option[List[Argument]]
): List[CompletionInfo] {
    function findTermName(term: Term): Option[String] {
        | ECall e {e.target | DynamicCall c} {
            e.arguments.last() | Some(Argument(_, _, e2))
        } {e2 | ELambda(_, Lambda(_, _, cases))} =>
            cases.collectFirst {findTermName(_.body)}
        | ECall e {e.target | DynamicCall c} => findTermName(c.function)
        | ECopy e => Some(e.name.slice(0, 1).lower() + e.name.dropFirst())
        | EField e => Some(e.field)
        | ELambda e {e.lambda.cases | [MatchCase c]} => findTermName(c.body)
        | EList e {e.items | []} => Some("list")
        | EList e {e.items | [e1, ...]} => findTermName(e1.first)
        | EPipe e => findTermName(e.function)
        | ERecord _ => Some("record")
        | EVariable e {e.name != "" && e.name.all {_.isAsciiLetterOrDigit()}} => Some(e.name)
        | EVariant e => Some(e.name.slice(0, 1).lower() + e.name.dropFirst())
        | EVariantIs e => Some(e.name.slice(0, 1).lower() + e.name.dropFirst())
        | _ => None
    }
    function findTypeName(type: Type): String {
        | TConstructor(_, name, _) {name.startsWith("Function$")} =>
            "lambda"
        | TConstructor(_, name, _) =>
            let n = name.reverse().takeWhile {_.isAsciiLetterOrDigit()}.reverse()
            if(!n.first().all {_.isAsciiLetter()}) {"p"} else {n.slice(0, 1).lower() + n.dropFirst()}
        | TVariable(_, index) => "p"
    }
    let completions = arguments.{
        | None {isParameter} =>
            let t = unification.substitute(instantiated.scheme.signature.returnType)
            let snippet = t.{
                | TConstructor _ => name + ": " + t.show([])
                | TVariable _ => name + ": "
            }
            let documentation = "// Add missing parameter\n" + name + ": " + t.show([])
            [CompletionInfo(name, "", snippet, False, t, documentation, Some(t))]
        | Some(as) {isParameter} =>
            let noEffect = TConstructor(instantiated.scheme.signature.at, "ff:core/Nothing.Nothing", [])
            let t = unification.substitute(TConstructor(
                instantiated.scheme.signature.at
                "Function$" + instantiated.scheme.signature.parameters.size()
                [
                    noEffect
                    ...instantiated.scheme.signature.parameters.map {_.valueType}
                    instantiated.scheme.signature.returnType
                ]
            ))
            let documentation = "// Add missing parameter\n" + name + ": " + t.show([])
            [CompletionInfo(name, "", name + ": " + t.show([]), False, t, documentation, Some(t))]
        | None =>
            let t = unification.substitute(instantiated.scheme.signature.returnType)
            let snippet = name + " = "
            let documentation = "// Define missing variable\n" + name + ": " + t.show([])
            [CompletionInfo(snippet, "...", snippet, False, t, documentation, Some(t))]
        | Some(as) =>
            mutable remainingParameters = instantiated.scheme.signature.parameters
            mutable usedNames = [].toSet()
            function uniqueName(name: String): String {
                let alternativeName = name + (usedNames.size() + 1)
                if(!usedNames.contains(name)) {
                    usedNames = usedNames.add(name)
                    name
                } elseIf {!usedNames.contains(alternativeName)} {
                    usedNames = usedNames.add(alternativeName)
                    alternativeName
                } else {
                    usedNames = usedNames.add(alternativeName + "_" + (usedNames.size() + 1))
                    uniqueName(name)
                }
            }
            let parameters = as.collect {a =>
                let found = a.name.{
                    | Some(n) => remainingParameters.find {_.name == n}
                    | None => remainingParameters.first()
                }
                found.map {p =>
                    remainingParameters = remainingParameters.filter {_.name != p.name}
                    let t = unification.substitute(p.valueType)
                    let x = a.name.orElse {findTermName(a.value)}.else {findTypeName(t)}
                    Pair(uniqueName(x), t)
                }
            }
            let returnType = unification.substitute(instantiated.scheme.signature.returnType)
            let types = [...parameters.map {_.second}, returnType]
            let returnTypeCode = returnType.{| TVariable _ => "" | _ => ": " + returnType.show(types)}
            let parameterSnippets = parameters.map {| Pair(x, t) =>
                x + ": " + t.show(types)
            }
            let extra = "(" + parameterSnippets.join(", ") + ") {...}"
            let shortSnippet = name + "(" + parameterSnippets.join(", ") + ")" + returnTypeCode
            let longSnippet = name + "(\n    " + parameterSnippets.join("\n    ") + "\n)" + returnTypeCode
            let snippet = if(shortSnippet.size() <= 100) {shortSnippet} else {longSnippet}
            let documentation = "// Define missing function\n" + 
                if(shortSnippet.size() < 30) {shortSnippet} else {longSnippet}
            [CompletionInfo(name, extra, snippet + " {\n    $0\n}", False, returnType, documentation, None)]
    }
    if(keyword && arguments.isEmpty()) {
        ["let ", "mutable "].flatMap {k => completions.map {c =>
            c.CompletionInfo(label = k + c.label, snippet = k + c.snippet)
        }}
    } elseIf {keyword} {
        ["function "].flatMap {k => completions.map {c =>
            c.CompletionInfo(label = k + c.label, snippet = k + c.snippet)
        }}
    } else {
        completions
    }
}

namedParameterCompletion(parameter: Parameter, index: Int, preselect: Bool): CompletionInfo {
    CompletionInfo(
        label = parameter.name + " = "
        extra = "..."
        snippet = parameter.name + " = "
        member = False
        type = parameter.valueType
        documentation = showCompletionParameter("", parameter)
        expectedType = if(preselect) {parameter.valueType}
        secondarySort = (1000 + index).clamp(1000, 9999)
    )
}

toplevelCompletion(lspHook: LspHook): List[CompletionInfo] {
    [
        CompletionInfo(
            label = "package", 
            extra = " some:package:0.0.0", 
            snippet = "package ", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Declares the group, name and version of this package", 
            expectedType = None
        )
        CompletionInfo(
            label = "dependency", 
            extra = " some:package:0.0.0", 
            snippet = "dependency ", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Declares a dependency on the specified version of the package", 
            expectedType = None
        )
        CompletionInfo(
            label = "import", 
            extra = " Module from some:package", 
            snippet = "import ", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Imports a module from a package", 
            expectedType = None
        )
        CompletionInfo(
            label = "extend", 
            extra = " self[T]: SomeType[T] {...}", 
            snippet = "extend ", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Add methods to a type defined in this module", 
            expectedType = None
        )
        CompletionInfo(
            label = "data", 
            extra = " SomeType[T](...) {...}", 
            snippet = "data ", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Defines an immutable type", 
            expectedType = None
        )
        CompletionInfo(
            label = "class", 
            extra = " SomeType[T](...) {...}", 
            snippet = "class ", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Defines a mutable type", 
            expectedType = None
        )
        CompletionInfo(
            label = "capability", 
            extra = " SomeType[T](...) {...}", 
            snippet = "capability ", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Defines a type with capabilities and functions", 
            expectedType = None
        )
        CompletionInfo(
            label = "trait", 
            extra = " T: SomeTrait {...}", 
            snippet = "trait ", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Defines a trait", 
            expectedType = None
        )
        CompletionInfo(
            label = "instance", 
            extra = " SomeType: SomeTrait {...}", 
            snippet = "instance ", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Defines an instance of a trait", 
            expectedType = None
        )
        CompletionInfo(
            label = "nodeMain", 
            extra = "(system: NodeSystem) {...}", 
            snippet = "nodeMain(system: NodeSystem) {\n    $0\n}", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Main function for targetting Node.js", 
            expectedType = None
        )
        CompletionInfo(
            label = "browserMain", 
            extra = "(system: BrowserSystem) {...}", 
            snippet = "browserMain(system: BrowserSystem) {\n    $0\n}", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Main function for targetting the browser", 
            expectedType = None
        )
        CompletionInfo(
            label = "buildMain", 
            extra = "(system: BuildSystem) {...}", 
            snippet = "buildMain(system: NodeSystem) {\n    $0\n}", 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Main function for building assets", 
            expectedType = None
        )
        CompletionInfo(
            label = "webapp", 
            extra = " with frontend and backend", 
            snippet = [
                "dependency ff:httpserver:0.0.0"
                "import HttpServer from ff:httpserver"
                ""
                "browserMain(system: BrowserSystem): Unit {"
                "    let response = system.httpClient().fetch(\"http://localhost:8080/hello\")"
                "    let window = system.js().global().get(\"window\")"
                "    window.call1(\"alert\", response.readText())"
                "}"
                ""
                "nodeMain(system: NodeSystem): Unit {"
                "    HttpServer.listen(system, \"localhost\", 8080) {request, response =>"
                "        if(request.path() == \"/\") {"
                "            response.setHeader(\"Content-Type\", [\"text/html; charset=UTF-8\"])"
                "            response.writeText(\"<!doctype html>\")"
                "            response.writeText(\"<script type='module' src='/js/script/script/WebApp.mjs'></script>\")"
                "        } elseIf {request.path() == \"/hello\"} {"
                "            response.setHeader(\"Content-Type\", [\"text/plain; charset=UTF-8\"])"
                "            response.writeText(\"Hello from server!\")"
                "        } elseIf {request.path().startsWith(\"/js/\") && !request.path().contains(\"..\")} {"
                "            response.setHeader(\"Content-Type\", [\"text/javascript; charset=UTF-8\"])"
                "            response.writeText(system.assets().readText(request.path()))"
                "        } else {"
                "            response.writeStatus(404, Some(\"Not found\"))"
                "        }"
                "    }"
                "}"
                ""
                "buildMain(system: BuildSystem) {"
                "    let browser = system.compileForBrowser(\"WebApp.ff\")"
                "    let assets = AssetSystem.create().addAssets(\"/js\", browser.assets())"
                "    system.setAssets(assets)"
                "}"
                ""
                "// To run this, name your file WebApp.ff and type:"
                "// firefly WebApp.ff"
            ].join("\n"), 
            member = False, 
            type = TConstructor(lspHook.at, "", []), 
            documentation = "// Example webapp with frontend and backend", 
            expectedType = None
        )
    ]
}

showCompletionParameter(indentation: String, parameter: Parameter): String {
    if(parameter.mutable) {indentation + "mutable "} else {indentation} +
    parameter.name + ": " + parameter.valueType.show([]) +
    parameter.default.map {
        | EVariant(_, n, _, None) =>
            n.reverse().takeWhile {_.isAsciiLetterOrDigit()}.reverse()
        | EVariant(_, n, _, Some([])) =>
            n.reverse().takeWhile {_.isAsciiLetterOrDigit()}.reverse()
        | EVariant(_, n, _, _) =>
            n.reverse().takeWhile {_.isAsciiLetterOrDigit()}.reverse() + "(...)"
        | EChar(_, v) => v
        | EInt(_, v) => v
        | EFloat(_, v) => v
        | EString(_, v) => v.replace("```", "'''")
        | ELambda(_, _) => "{...}"
        | EList(_, _, []) => "[]"
        | EList(_, _, _) => "[...]"
        | _ => "..."
    }.map {" = " + _}.else {""}
}
