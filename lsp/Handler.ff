import JsEmitter from ff:compiler
import Builder from ff:compiler
import Syntax from ff:compiler
import Tokenizer from ff:compiler
import Token from ff:compiler
import LspHook from ff:compiler

class Handler(
    mutable rootUri: Option[String]
    mutable virtualFiles: Map[String, String]
    mutable cancelledRequests: Set[MessageId]
)

data MessageId {
    MessageIdInt(id: Int)
    MessageIdString(id: String)
}

capability ResultOrError {
    Result(result: JsValue)
    Error(code: Int, message: String)
}

data LanguageServerException(message: String)

data TokenLocation(
    file: String
    startLine: Int
    startColumn: Int
    endLine: Int
    endColumn: Int
    raw: String
)


extend self: Handler {

    handleNotification(system: NodeSystem, method: String, parameters: Map[String, JsValue]): Unit {
        method.{
            | "initialized" =>
            | "textDocument/didChange" => self.handleDidChange(system, parameters)
            | "textDocument/didClose" => self.handleDidClose(system, parameters)
            | "exit" => system.exit(0)
            | _ =>
        }   
    }

    handleRequest(system: NodeSystem, method: String, parameters: Map[String, JsValue]): ResultOrError {
        method.{
            | "initialize" => self.handleInitialize(system.js(), parameters)
            | "textDocument/diagnostic" => self.handleDiagnostic(system, parameters)
            | "textDocument/completion" => self.handleCompletion(system, parameters)
            //| "textDocument/signatureHelp" => self.handleSignatureHelp(system, parameters)
            | "textDocument/hover" => self.handleHover(system, parameters, goToDefinition = False)
            | "textDocument/definition" => self.handleHover(system, parameters, goToDefinition = True)
            | "textDocument/references" => self.handleReferences(system, parameters, local = False)
            | "textDocument/documentHighlight" => self.handleReferences(system, parameters, local = True)
            | "shutdown" => Result(system.js().null())
            | _ => self.handleUnsupported(system.js())
        }
    }
    
    handleUnsupported(js: JsSystem): ResultOrError {
        Error(1234, "Unsupported method")
    }
    
    handleInitialize(js: JsSystem, parameters: Map[String, JsValue]): ResultOrError {
        self.rootUri = Some(parameters.grab("rootUri").grabString())

        let anyFireflyFile = js.object()
            .with("filters", [
                js.object()
                    .with("pattern", js.object()
                        .with("glob", "**/*.ff")
                        .with("matches", "file")
                    )
            ].toArray())
    
        let o = js.object()
            .with("capabilities", js.object()
                .with("textDocumentSync", js.object()
                    .with("openClose", True)
                    .with("change", 1 /* TextDocumentSyncKind.Full */)
                )
                .with("hoverProvider", True)
                .with("definitionProvider", True)
                .with("documentHighlightProvider", True)
                .with("diagnosticProvider", js.object()
                    .with("interFileDependencies", True)
                    .with("workspaceDiagnostics", False)
                )
                .with("completionProvider", js.object()
                    .with("triggerCharacters", js.array(["."].map {js.value(_)}))
                    .with("allCommitCharacters", js.array([";"].map {js.value(_)}))
                )
                /*.with("signatureHelpProvider", js.object()
                    .with("triggerCharacters", js.array(["("].map {js.value(_)}))
                    .with("retriggerCharacters", js.array([","].map {js.value(_)}))
                )*/
                .with("referencesProvider", True)
                /*.with("workspace", js.object()
                    .with("workspaceFolders", js.object()
                         .with("supported", True)
                         .with("changeNotifications", True)
                    )
                    .with("fileOperations", js.object()
                         .with("didCreate", anyFireflyFile)
                         .with("didRename", anyFireflyFile)
                         .with("didDelete", anyFireflyFile)
                    )
                )*/
            )
            .with("serverInfo", js.object()
                .with("name", "Firefly Language Server")
                .with("version", "0.0.0")
            )
        Result(o)
    }
    
    handleDiagnostic(system: NodeSystem, parameters: Map[String, JsValue]): ResultOrError {
        let js = system.js()
        let uri = parameters.grab("textDocument").get("uri").grabString()
        let absolutePath = FileSystem.urlToPath(uri)
        let path = FileSystem.relative(system.files().workingDirectory(), absolutePath)
        let fixedPath = path.replace("\\", "/")
        let diagnostics = try {
            Builder.check(system, ".", fixedPath, self.virtualFiles, LspHook.disabled(), None, None, None, True)
            []
        } catch {| CompileError(at, message), error =>
            let tokenLocation = self.findToken(system, at)
            let diagnostic = js.object()
                .with("range", self.tokenLocationToLspRange(js, tokenLocation))
                .with("severity", 1 /* Error */)
                .with("message", message)
            [diagnostic]
        } grab()
    
        let o = js.object()
            .with("kind", "full")
            .with("items", diagnostics.toArray())
        Result(o)
    }

    handleDidChange(system: NodeSystem, parameters: Map[String, JsValue]): Unit {
        let js = system.js()
        let uri = parameters.grab("textDocument").get("uri").grabString()
        let absolutePath = FileSystem.urlToPath(uri)
        let path = FileSystem.relative(system.files().workingDirectory(), absolutePath)
        let fixedPath = path.replace("\\", "/")
        let contentChanges = parameters.grab("contentChanges").grabArray()
        if(contentChanges.size() != 1) {throw(LanguageServerException("Expected a single element in contentChanges"))} else: 
        let contentChange = contentChanges.grab(0)
        if(!contentChange.get("range").isNullOrUndefined()) {throw(LanguageServerException("Expected a complete contentChange"))} else:
        let content = contentChange.get("text").grabString()
        self.virtualFiles = self.virtualFiles.add(fixedPath, content)
    }

    handleDidClose(system: NodeSystem, parameters: Map[String, JsValue]): Unit {
        let js = system.js()
        let uri = parameters.grab("textDocument").get("uri").grabString()
        let absolutePath = FileSystem.urlToPath(uri)
        let path = FileSystem.relative(system.files().workingDirectory(), absolutePath)
        let fixedPath = path.replace("\\", "/")
        self.virtualFiles = self.virtualFiles.remove(fixedPath)
    }
    
    handleHover(system: NodeSystem, parameters: Map[String, JsValue], goToDefinition: Bool): ResultOrError {
        let hoverAt = self.grabFixedLocation(system, parameters)
        mutable hoverResult = HoverInfo(None, None, None)
        let lspHook = LspHook.make(targetAt = Some(hoverAt), sourceAt = None, inferTypes = True)
        try {
            let hover = Some(Pair(hoverAt, {hoverResult = _}))
            Builder.check(system, ".", hoverAt.file, self.virtualFiles, lspHook, hover, None, None, True)
        } catch {| CompileError(at, message), error =>
            Log.trace(message)
        } grab()
        let js = system.js()
        let o = if(goToDefinition) {
            hoverResult.at.map {at => 
                let token = self.findToken(system, at)
                self.tokenLocationToLspLocation(system, token)
            }.else {js.null()}
        } else {
            hoverResult.{
                | HoverInfo(_, Some(t), q) => 
                    let extra = q.{
                        | Some(TConstructor(_, "Q$", _)) =>
                            "This call may be asynchronous."
                        | _ => 
                            ""
                    }
                    js.object().with("contents", 
                        js.object()
                            .with("kind", "markdown")
                            .with("value", 
                                "```\n" + t.show([]) + "\n```\n" + 
                                if(extra == "") {""} else {"*" + extra + "*"})
                    )
                | _ => 
                    js.null()
            }
        }
        Result(o)
    }

    handleCompletion(system: NodeSystem, parameters: Map[String, JsValue]): ResultOrError {
        let completionAt = self.grabFixedLocation(system, parameters)
        mutable completionResult = []
        let lspHook = LspHook.make(targetAt = Some(completionAt), sourceAt = None, inferTypes = True)
        try {
            let completion = Some(Pair(completionAt, {completionResult = _}))
            Builder.check(system, ".", completionAt.file, self.virtualFiles, lspHook, None, completion, None, True)
        } catch {| CompileError(at, message), error =>
            Log.trace(message)
        } grab()
        let js = system.js()
        let o = js.object()
            .with("isIncomplete", False)
            .with("items", completionResult.distinct().toArray().map {| CompletionInfo i =>
                let isAlpha = i.label.first().any {_.isAsciiLetter()}
                let isLower = i.label.first().any {_.isAsciiLower()}
                let isUnqualified = !i.label.takeWhile {c => c != '(' && c != '[' && c != '{'}.contains(".")
                let isVariable = isLower && !i.label.contains("(") && !i.label.contains("{")
                let isParameter = i.snippet.endsWith(" = ")
                let sortText = if(isParameter) {0} else {9 - (
                    isVariable.toInt() + isUnqualified.toInt() + 
                    isAlpha.toInt() + isLower.toInt()
                )} + i.label.lower()
                let preselect = Pair(i.type, i.expectedType).{
                    | Pair(TConstructor(_, n1, _), Some(TConstructor(_, n2, _))) => n1 == n2
                    | _ => False
                }
                js.object()
                    // Property or EnumMember or Constructor or Method/Function or Field/Variable
                    .with("kind", 
                        if(isParameter) {10} else:
                        if(i.label.first().any {c => c == '{' || c == '|'}) {22} else:
                        if(i.label.first().any {_.isAsciiUpper()}) {4} else:
                        if(i.label.any {c => c == '(' || c == '{'}) {2} else {5} + if(i.member) {0} else {1}
                    )
                    .with("sortText", sortText)
                    .with("preselect", preselect)
                    .with("label", i.label)
                    .with("labelDetails", js.object()
                        .with("detail", ": " + i.type.show([]))
                    )
                    .with("insertText", i.snippet)
                    .with("insertTextFormat", 2 /* Snippet */)
                    .with("documentation", js.object()
                        .with("kind", "markdown")
                        .with("value", "```\n" + i.documentation + "\n```")
                    )
            })
        Result(o)
    }

    handleSignatureHelp(system: NodeSystem, parameters: Map[String, JsValue]): ResultOrError {
        let completionAt = self.grabFixedLocation(system, parameters)
        mutable completionResult = []
        // This happens when the cursor moves or a character is typed so it'd better be fast!
        let js = system.js()
        let label = "TODO(todo1: One, todo2: Two): Three"
        let o = js.object()
            .with("signatures", js.array([js.object()
                .with("label", label)
                .with("parameters", js.array([
                    js.object().with("label", "todo1: One")
                    js.object().with("label", "todo2: Two")
                ]))
                .with("activeParameter", 0)
            ]))
            .with("activeSignature", 0)
        Result(o)
    }

    handleReferences(system: NodeSystem, parameters: Map[String, JsValue], local: Bool): ResultOrError {
        let referencesAt = self.grabFixedLocation(system, parameters)
        mutable hoverResult = HoverInfo(None, None, None)
        let temporaryLspHook = LspHook.make(targetAt = Some(referencesAt), sourceAt = None, inferTypes = True)
        try {
            let hover = Some(Pair(referencesAt, {hoverResult = _}))
            Builder.check(system, ".", referencesAt.file, self.virtualFiles, temporaryLspHook, hover, None, None, True)
        } catch {| CompileError(at, message), error =>
            Log.trace(message)
        } grab()

        Log.trace("handleReferences hoverResult: " + Show.show(hoverResult))

        let js = system.js()
        let o = hoverResult.at.{
            | Some(definedAt) => 
                Log.trace("handleReferences definedAt: " + Show.show(definedAt))
                // TODO search all files in workspace
                let referencesResult = [definedAt].toStack()
                let lspHook = LspHook.make(targetAt = None, sourceAt = Some(definedAt), inferTypes = True)
                try {
                    let references = Some(Pair[Location, List[Location] => Unit](definedAt, {r => 
                        Log.trace("Set referencesResult: " + Show.show(r))
                        referencesResult.pushArray(r.toArray())
                    }))
                    let path = if(local) {referencesAt.file} else {FileSystem.urlToPath(self.rootUri.grab())}
                    Log.trace("path: " + path)
                    Builder.check(system, ".", path, self.virtualFiles, lspHook, None, None, references, True)
                } catch {| CompileError(at, message), error =>
                    Log.trace(message)
                } grab()
        
                let clientLocations = referencesResult.toList().filter {
                    !local || _.file == referencesAt.file
                }.map {at => 
                    let token = self.findToken(system, at)
                    self.tokenLocationToLspLocation(system, token)
                }
                js.array(clientLocations)
            | None => 
                js.null()
        }
        Result(o)
    }    
    
    makeNotificationMessage(js: JsSystem, method: String, params: JsValue): JsValue {
        js.object()
            .with("jsonrpc", "2.0")
            .with("method", method)
            .with("params", params)
    }

    findToken(system: NodeSystem, at: Location): TokenLocation {
        let fallback = TokenLocation(
            file = at.file
            startLine = at.line
            startColumn = at.column
            endLine = at.line
            endColumn = at.column + 1
            raw = ""
        )
        try {
            let code = self.virtualFiles.get(at.file).else {system.files().readText(at.file)}
            let tokens = Tokenizer.tokenize(at.file, code, None, True)
            let token = tokens.toStream().find {token =>
                at.line >= token.startLine && at.line <= token.stopLine && (
                    (at.line > token.startLine || at.column >= 1 + token.startOffset - token.startLineOffset) &&
                    (at.line < token.stopLine || at.column < 1 + token.stopOffset - token.stopLineOffset || (
                        (token.kind == LLower || token.kind == LUpper) && 
                        at.column == 1 + token.stopOffset - token.stopLineOffset
                    ))
                )
            }
            token.map {t => TokenLocation(
                file = t.file
                startLine = t.startLine
                startColumn = 1 + t.startOffset - t.startLineOffset
                endLine = t.stopLine
                endColumn = 1 + t.stopOffset - t.stopLineOffset
                raw = t.raw()
            )}.else {fallback}
        } catchAny {_ =>
            fallback
        } grab()
    }

    grabFixedLocation(system: NodeSystem, parameters: Map[String, JsValue]): Location {
        let uri = parameters.grab("textDocument").get("uri").grabString()
        let absolutePath = FileSystem.urlToPath(uri)
        let path = FileSystem.relative(system.files().workingDirectory(), absolutePath)
        let fixedPath = path.replace("\\", "/")
        let line = parameters.grab("position").get("line").grabInt() + 1
        let column = parameters.grab("position").get("character").grabInt() + 1
        let token = self.findToken(system, Location(fixedPath, line, column))
        Location(
            file = fixedPath
            line = token.startLine
            column = token.startColumn
        )
    }

    tokenLocationToLspLocation(system: NodeSystem, tokenLocation: TokenLocation): JsValue {
        let js = system.js()
        js.object()
            .with("uri", FileSystem.pathToUrl(system.files().absolutePath(tokenLocation.file)))
            .with("range", self.tokenLocationToLspRange(js, tokenLocation))
    }

    tokenLocationToLspRange(js: JsSystem, tokenLocation: TokenLocation): JsValue {
        js.object()
            .with("start", js.object()
                .with("line", tokenLocation.startLine - 1)
                .with("character", tokenLocation.startColumn - 1)
            )
            .with("end", js.object()
                .with("line", tokenLocation.endLine - 1)
                .with("character", tokenLocation.endColumn - 1)
            )
    }

}
