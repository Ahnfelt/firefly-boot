import LspHook from ff:compiler
import Syntax from ff:compiler

data DocumentSymbol(
    name: String
    kind: Int
    selectionStart: Location
    selectionEnd: Location
    start: Location
    end: Location
    children: List[DocumentSymbol]
)

data WorkspaceSymbol(
    name: String
    kind: Int
    containerName: Option[String]
    selectionStart: Location
    selectionEnd: Location
)

class Result[T](
    result: T
    remaining: List[ResultHook]
)

data ReadSymbolsError()

readAllSymbols(hooks: List[ResultHook]): List[DocumentSymbol]  {
    let result = readSymbols(hooks)
    if(!result.remaining.isEmpty()) {throw(ReadSymbolsError())}
    result.result
}

readSymbols(hooks: List[ResultHook]): Result[List[DocumentSymbol]]  {
    | [ParseSymbolBegin, ...rest] => 
        let symbol = readSymbol(rest)
        let symbols = readSymbols(symbol.remaining)
        Result([symbol.result, ...symbols.result], symbols.remaining)
    | _ => Result([], hooks)
}

readSymbol(hooks: List[ResultHook]): Result[DocumentSymbol] {
    let children = readSymbols(hooks)
    children.remaining.{
        | [ParseSymbolEnd(name, kind, selectionStart, selectionEnd, start, end), ...rest] => 
            let symbol = DocumentSymbol(name, kind, selectionStart, selectionEnd, start, end, children.result)
            Result(symbol, rest)
        | _ => throw(ReadSymbolsError())
        }
}

symbolToLsp(js: JsSystem, symbol: DocumentSymbol): JsValue {
    js.object()
        .with("name", symbol.name)
        .with("kind", symbol.kind)
        .with("range", locationsToLspRange(js, symbol.start, symbol.end))
        .with("selectionRange", locationsToLspRange(js, symbol.selectionStart, symbol.selectionEnd))
        .with("children", js.array(symbol.children.map {symbolToLsp(js, _)}))
}

locationsToLspRange(js: JsSystem, start: Location, end: Location): JsValue {
    js.object()
        .with("start", js.object()
            .with("line", start.line - 1)
            .with("character", start.column - 1)
        )
        .with("end", js.object()
            .with("line", end.line - 1)
            .with("character", end.column - 1)
        )
}

handleDocumentSymbol(system: NodeSystem, lspHook: LspHook): JsValue {
    //lspHook.results().each {Log.trace(showHook(_))}
    let symbols = readAllSymbols(lspHook.results())
    //symbols.each {Log.show(_)}
    system.js().array(symbols.map {symbolToLsp(system.js(), _)})
}

handleWorkspaceSymbol(system: NodeSystem, lspHook: LspHook, query: String): JsValue {
    let symbols = readAllSymbols(lspHook.results())
    system.js().array(symbols.map {symbolToLsp(system.js(), _)})
}

documentToWorkspaceSymbols(symbol: DocumentSymbol, parentName: Option[String]): List[WorkspaceSymbol] {
    let s = WorkspaceSymbol(
        symbol.name
        kind = symbol.kind
        containerName = parentName
        selectionStart = symbol.selectionEnd
        selectionEnd = symbol.selectionEnd
    )
    let children = symbol.children.flatMap {documentToWorkspaceSymbols(_, Some(symbol.name))}
    [s, ... children]
}

showHook(lspHook: ResultHook): String {
    | ParseSymbolBegin => "ParseSymbolBegin"
    | ParseSymbolEnd(name, kind, _, _, _, _) => "ParseSymbolEnd("+Show.show(name)+", "+Show.show(kind)+")"
    //| ParseSymbolBegin => "("
    //| ParseSymbolEnd(name, kind, symbolStart, selectionStart, selectionEnd) => ") " + name + " " + showPosition(selectionStart) + " - " + showPosition(selectionEnd)
    | _ => "other"
}

showPosition(at: Location): String {
    at.line + ":" + at.column
}