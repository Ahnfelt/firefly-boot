capability WebSocket(
    jsValue: JsValue
    mutable front: Array[JsValue] 
    mutable back: Array[JsValue]
    mutable listeners: Array[Bool => Unit]
    task: Task
)

open(browserSystem: BrowserSystem, url: String): WebSocket {
    internalOpenBrowserWebSocket(browserSystem, url)
}

extend self: WebSocket {
    
    readText(encoding: String = "utf8"): Option[String] {
        self.readAny {_} {_.toString(encoding)}
    }

    readBuffer(): Option[Buffer] {
        self.readAny {_.toBuffer()} {_}
    }
    
    readAny[T](fromText: String => T, fromBuffer: Buffer => T): Option[T] {
        Js.throwIfCancelled()
        doWhile {
            if(self.front.size() != 0) {False} else:
            while {self.back.size() != 0} {
                self.front.push(self.back.pop().grab())
            }
            if(self.front.size() != 0) {False} else:
            if(self.jsValue->readyState === 3) {False} else:
            Js.awaitCancellablePromise {resolve, reject, onSettle =>
                self.listeners.push(resolve)
                onSettle {fulfilled =>
                    if(!fulfilled) {
                        self.listeners = self.listeners.drain().filter {_! !== resolve!}.toArray()
                    }
                }
            }
        }
        if(self.jsValue->readyState === 3) {None} else:
        let message = self.front.pop().grab()
        if(!(message.instanceof(Js->MessageEvent))) {Js.throw(Js->Error->("WebSocket error"))}
        let data = message->data
        if(data.typeof() == "string") {Some(Js.await(fromText(data?)!)?)} else:
        Some(Js.await(fromBuffer(Js->DataView->(data)?)!)?)
    }
            
    writeBuffer(data: Buffer): Unit {
        Js.throwIfCancelled()
        self.jsValue->send(data)
    }

    writeText(data: String): Unit {
        Js.throwIfCancelled()
        self.jsValue->send(data)
    }
        
    close(code: Int = 1000, reason: String = ""): Unit {
        if(self.jsValue->readyState !== 2 && self.jsValue->readyState !== 3) {
            Js.await(Js->Promise->(Js->{resolve, reject =>
                self.jsValue->addEventListener("close", resolve)
                self.jsValue->close(code, if(reason != "") {reason!} else {Js.undefined()})
            }))
        }
    }

    isOpen(): Bool {
        self.jsValue->readyState === 1
    }

    isClosing(): Bool {
        self.jsValue->readyState === 2
    }

    isClosed(): Bool {
        self.jsValue->readyState === 3
    }

}

internalOpenBrowserWebSocket(browserSystem: BrowserSystem, url: String): WebSocket
    target browser async """
        if(typeof location !== 'undefined' && !url_.includes("://")) {
            if(location.href && location.href.startsWith("http")) {
                url_ = new URL(url_, location.href).href.replace(/^http/, 'ws');
            }
        }
        const socket = new WebSocket(url_);
        socket.binaryType = "arraybuffer";
        socket.ffFront = [];
        socket.ffBack = [];
        socket.ffListeners = [];
        socket.ffTask = $task;
        $task.controller_.signal.addEventListener('message', m => socket.ffBack.push(m));
        const abort = () => socket.close();
        try {
            await new Promise((resolve, reject) => {
                socket.onopen = resolve;
                socket.onerror = reject;
                $task.controller_.signal.addEventListener('abort', abort);
            });
        } finally {
            socket.onopen = null;
            socket.onerror = null;
        }
        socket.addEventListener('close', () => {
            $task.controller_.signal.removeEventListener('abort', abort);
            for(let i = 0; i < socket.ffListeners.length; i++) socket.ffListeners[i]();
            socket.ffListeners.length = 0;
        });
        socket.addEventListener('message', m => {
            socket.ffBack.push(m);
            for(let i = 0; i < socket.ffListeners.length; i++) socket.ffListeners[i]();
            socket.ffListeners.length = 0;
        });
        socket.addEventListener('error', e => {
            socket.ffBack.push(e);
            for(let i = 0; i < socket.ffListeners.length; i++) socket.ffListeners[i]();
            socket.ffListeners.length = 0;
        });
        return socket;
    """
