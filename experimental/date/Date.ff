// Temporal.ZonedDateTime but with consistent equals/compare
newtype Date(jsValue: JsValue)
newtype DateGap(jsValue: JsValue)

new(
    timeZoneId: String
    year: Int
    month: Int
    day: Int
    hour: Int = 0
    minute: Int = 0
    second: Int = 0
    millisecond: Int = 0
    microsecond: Int = 0
    nanosecond: Int = 0
    calendarId: String = "iso8601"
    offset: Option[String] = None
    earlier: Bool = True
    later: Bool = True
): Date {
    Date(Js->Temporal->ZonedDateTime->from(Js->(
        timeZone = timeZoneId
        year = year
        month = month
        day = day
        hour = hour
        minute = minute
        second = second
        millisecond = millisecond
        microsecond = microsecond
        nanosecond = nanosecond
        calendar = calendarId
        offset = offset.map {_!}.else {Js.undefined()}
    ), internalDisambiguation(earlier, later)))
}

newEra(
    calendarId: String
    timeZoneId: String
    era: String
    eraYear: Int
    month: Int
    day: Int
    hour: Int = 0
    minute: Int = 0
    second: Int = 0
    millisecond: Int = 0
    microsecond: Int = 0
    nanosecond: Int = 0
    offset: Option[String] = None
    earlier: Bool = True
    later: Bool = True
): Date {
    Date(Js->Temporal->ZonedDateTime->from(Js->(
        timeZone = timeZoneId
        era = era
        eraYear = eraYear
        month = month
        day = day
        hour = hour
        minute = minute
        second = second
        millisecond = millisecond
        microsecond = microsecond
        nanosecond = nanosecond
        calendar = calendarId
        offset = offset.map {_!}.else {Js.undefined()}
    ), internalDisambiguation(earlier, later)))
}

newRfc9557(rfc9557: String): Date {
    Date(Js->Temporal->ZonedDateTime->from(rfc9557))
}

gap(
    years: Int = 0
    months: Int = 0
    weeks: Int = 0
    days: Int = 0
    hours: Int = 0
    minutes: Int = 0
    seconds: Int = 0
    milliseconds: Int = 0
    microseconds: Int = 0
    nanoseconds: Int = 0
): DateGap {
    DateGap(Js->Temporal->Duration->(
        years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds
    ))
}

gapIso8601(iso8601: String): DateGap {
    DateGap(Js->Temporal->Duration->from(iso8601))
}


instance Date: Equal {
    equals(x: Date, y: Date): Bool {
        x.jsValue->equals(y.jsValue)?
    }    
}

instance Date: Order {
    compare(x: Date, y: Date): Ordering {
        let instant: Int = Js->Temporal->ZonedDateTime->compare(x.jsValue, y.jsValue)?
        if(instant != 0) {Ordering.fromInt(instant)} else:
        let timeZone = Ordering.compare(x.timeZoneId(), y.timeZoneId())
        if(timeZone != OrderingSame) {timeZone} else:
        Ordering.compare(x.calendarId(), y.calendarId())
    }
}

extend self: Date {
    
    timeZoneId(): String {
        self.jsValue->timeZoneId?
    }
    
    calendarId(): String {
        self.jsValue->calendarId?
    }
    
    day(): Int {
        self.jsValue->day?
    }
    
    dayOfWeek(): Int {
        self.jsValue->dayOfWeek?
    }
    
    dayOfYear(): Int {
        self.jsValue->dayOfYear?
    }
    
    daysInMonth(): Int {
        self.jsValue->daysInMonth?
    }
    
    daysInYear(): Int {
        self.jsValue->daysInYear?
    }
    
    epochMilliseconds(): Int {
        self.jsValue->epochMilliseconds?
    }
    
    era(): Option[String] {
        let era = self.jsValue->era
        if(!era.isNullOrUndefined()) {era?}
    }
    
    eraYear(): Option[Int] {
        let eraYear = self.jsValue->eraYear
        if(!eraYear.isNullOrUndefined()) {eraYear?}
    }
    
    hour(): Int {
        self.jsValue->hour?
    }
    
    hoursInDay(): Int {
        self.jsValue->hoursInDay?
    }

    inLeapYear(): Bool {
        self.jsValue->inLeapYear?
    }

    microsecond(): Int {
        self.jsValue->microsecond?
    }

    millisecond(): Int {
        self.jsValue->millisecond?
    }

    minute(): Int {
        self.jsValue->minute?
    }

    month(): Int {
        self.jsValue->month?
    }

    monthCode(): String {
        self.jsValue->monthCode?
    }

    monthsInYear(): Int {
        self.jsValue->monthsInYear?
    }

    nanosecond(): Int {
        self.jsValue->nanosecond?
    }

    offset(): String {
        self.jsValue->offset?
    }

    offsetNanoseconds(): Int {
        self.jsValue->offsetNanoseconds?
    }

    second(): Int {
        self.jsValue->second?
    }

    weekOfYear(): Int {
        self.jsValue->weekOfYear?
    }

    year(): Int {
        self.jsValue->year?
    }

    yearOfWeek(): Int {
        self.jsValue->yearOfWeek?
    }
    
    getTimeZoneTransition(): Date {
        Date(self.jsValue->getTimeZoneTransition())
    }
    
    round(smallestUnit: String = "day", increment: Int = 1, mode: String = "halfExpand"): Date {
        Date(self.jsValue->round(Js->(
            smallestUnit = smallestUnit
            roundingIncrement = increment
            roundingMode = mode
        )))
    }
    
    startOfDay(): Date {
        Date(self.jsValue->startOfDay())
    }

    toRfc9557(
        smallestUnit: Option[String] = None
        fractionalSecondDigits: Option[Int] = None
        roundingMode: String = "trunc"
        timeZoneName: String = "auto"
        offset: String = "auto"
        calendarName: String = "auto"
    ): String {
        self.jsValue->toString(Js->(
            calendarName = calendarName
            fractionalSecondDigits = fractionalSecondDigits.map {_!}.else {"auto"!}
            roundingMode = roundingMode
            smallestUnit = smallestUnit.map {_!}.else {Js.undefined()}
            timeZoneName = timeZoneName
            offset = offset
        ))?
    }
    
    withCalendar(calendarId: String): Date {
        Date(self.jsValue->withCalendar(calendarId))
    }
    
    withTimeZone(timeZoneId: String): Date {
        Date(self.jsValue->withTimeZone(timeZoneId))
    }
    
    withEra(era: String, eraYear: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(era = era, eraYear = eraYear), internalDisambiguation(earlier, later)))
    }
    
    withYear(year: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(year = year), internalDisambiguation(earlier, later)))
    }

    withMonth(month: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(month = month), internalDisambiguation(earlier, later)))
    }

    withWeek(week: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(week = week), internalDisambiguation(earlier, later)))
    }
    
    withDay(day: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(day = day), internalDisambiguation(earlier, later)))
    }
    
    withHour(hour: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(hour = hour), internalDisambiguation(earlier, later)))
    }
    
    withMinute(minute: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(minute = minute), internalDisambiguation(earlier, later)))
    }
    
    withSecond(second: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(second = second), internalDisambiguation(earlier, later)))
    }
    
    withMillisecond(millisecond: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(millisecond = millisecond), internalDisambiguation(earlier, later)))
    }
    
    withMicrosecond(microsecond: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(microsecond = microsecond), internalDisambiguation(earlier, later)))
    }
    
    withNanosecond(nanosecond: Int, earlier: Bool = True, later: Bool = True): Date {
        Date(self.jsValue->with(Js->(nanosecond = nanosecond), internalDisambiguation(earlier, later)))
    }

    
    add(gap: DateGap): Date {
        Date(self.jsValue->add(gap.jsValue))
    }
    
    subtract(gap: DateGap): Date {
        Date(self.jsValue->subtract(gap.jsValue))
    }
    
    since(that: Date): DateGap {
        DateGap(self.jsValue->since(that.jsValue))
    }
    
    until(that: Date): DateGap {
        DateGap(self.jsValue->until(that.jsValue))
    }
    
    yearsSince(that: Date): Float {
        let duration = self.jsValue->since(that.jsValue)
        duration->total(Js->(unit = "years", relativeTo = that.jsValue))?
    }
    
    monthsSince(that: Date): Float {
        let duration = self.jsValue->since(that.jsValue)
        duration->total(Js->(unit = "months", relativeTo = that.jsValue))?
    }
    
    weeksSince(that: Date): Float {
        let duration = self.jsValue->since(that.jsValue)
        duration->total(Js->(unit = "weeks", relativeTo = that.jsValue))?
    }
    
    daysSince(that: Date): Float {
        let duration = self.jsValue->since(that.jsValue)
        duration->total(Js->(unit = "days", relativeTo = that.jsValue))?
    }
    
    hoursSince(that: Date): Float {
        let duration = self.jsValue->since(that.jsValue)
        duration->total(Js->(unit = "hours", relativeTo = that.jsValue))?
    }
    
    minutesSince(that: Date): Float {
        let duration = self.jsValue->since(that.jsValue)
        duration->total(Js->(unit = "minutes", relativeTo = that.jsValue))?
    }
    
    secondsSince(that: Date): Float {
        let duration = self.jsValue->since(that.jsValue)
        duration->total(Js->(unit = "seconds", relativeTo = that.jsValue))?
    }
    
    millisecondsSince(that: Date): Float {
        let duration = self.jsValue->since(that.jsValue)
        duration->total(Js->(unit = "milliseconds", relativeTo = that.jsValue))?
    }
    
    microsecondsSince(that: Date): Float {
        let duration = self.jsValue->since(that.jsValue)
        duration->total(Js->(unit = "microseconds", relativeTo = that.jsValue))?
    }
    
    nanosecondsSince(that: Date): Float {
        let duration = self.jsValue->since(that.jsValue)
        duration->total(Js->(unit = "nanoseconds", relativeTo = that.jsValue))?
    }
    
}

extend self: DateGap {
    
    years(): Int {
        self.jsValue->years?
    }
    
    months(): Int {
        self.jsValue->months?
    }
    
    weeks(): Int {
        self.jsValue->weeks?
    }
    
    days(): Int {
        self.jsValue->days?
    }
    
    hours(): Int {
        self.jsValue->hours?
    }
    
    minutes(): Int {
        self.jsValue->minutes?
    }
    
    seconds(): Int {
        self.jsValue->seconds?
    }
    
    milliseconds(): Int {
        self.jsValue->milliseconds?
    }
    
    microseconds(): Int {
        self.jsValue->microseconds?
    }
    
    nanoseconds(): Int {
        self.jsValue->nanoseconds?
    }
    
    withYears(years: Int): DateGap {
        DateGap(self.jsValue->with(Js->(years = years)))
    }
    
    withMonths(months: Int): DateGap {
        DateGap(self.jsValue->with(Js->(months = months)))
    }
    
    withWeeks(weeks: Int): DateGap {
        DateGap(self.jsValue->with(Js->(weeks = weeks)))
    }
    
    withDays(days: Int): DateGap {
        DateGap(self.jsValue->with(Js->(days = days)))
    }
    
    withHours(hours: Int): DateGap {
        DateGap(self.jsValue->with(Js->(hours = hours)))
    }
    
    withMinutes(minutes: Int): DateGap {
        DateGap(self.jsValue->with(Js->(minutes = minutes)))
    }
    
    withSeconds(seconds: Int): DateGap {
        DateGap(self.jsValue->with(Js->(seconds = seconds)))
    }
    
    withMilliseconds(milliseconds: Int): DateGap {
        DateGap(self.jsValue->with(Js->(milliseconds = milliseconds)))
    }
    
    withMicroseconds(microseconds: Int): DateGap {
        DateGap(self.jsValue->with(Js->(microseconds = microseconds)))
    }
    
    withNanoseconds(nanoseconds: Int): DateGap {
        DateGap(self.jsValue->with(Js->(nanoseconds = nanoseconds)))
    }
    
    sign(): Int {
        self.jsValue->sign?
    }
    
    negate(): DateGap {
        DateGap(self.jsValue->negate())
    }
    
}

internalDisambiguation(earlier: Bool, later: Bool): JsValue {
    Js->(
        disambiguation = if(earlier && later) {
            "compatible"
        } elseIf {earlier} {
            "earlier"
        } elseIf {later} {
            "later"
        } else {
            "reject"
        }
    )    
}
