data Expression {
    EVariable(name: String)
    EApply(function: Expression, argument: Expression)
    ELambda(variable: String, body: Expression)
    EAnnotate(type: Type, expression: Expression)
}

data Type(name: String, typeArguments: List[Type])

data Context(
    variables: Map[String, Type]
)

data TypeError(message: String)


check(c0: Context, t0: Type, e0: Expression): Unit {
    e0.{
        | EVariable _ => 
            let t1 = infer(c0, e0)
            checkSame(t0, t1)
        | EApply _ => 
            let t1 = infer(c0, e0)
            checkSame(t0, t1)
        | ELambda(variable, body) => 
            t0.{
                | Type("Function", [t2, t3]) =>
                    let c2 = c0.Context(variables = c0.variables.add(variable, t2))
                    check(c2, t3, body)
                    t3
                | _ =>
                    throw(TypeError("Can't call non-functions"))
            }
        | EAnnotate(t1, e1) =>
            check(c0, t1, e1)
    }
}


infer(c0: Context, e0: Expression): Type {
    e0.{
        | EVariable(name) => 
            c0.variables.get(name).{
                | None => 
                    throw(TypeError("Variable not in scope: " + name))
                | Some(t1) => 
                    t1
            }
        | EApply(function, argument) => 
            let t1 = infer(c0, function)
            t1.{
                | Type("Function", [t2, t3]) =>
                    check(c0, t2, argument)
                    t3
                | _ =>
                    throw(TypeError("Can't call non-functions"))
            }
        | ELambda(variable, body) => 
            throw(TypeError("Lambda functions must be explicitly typed"))
        | EAnnotate(t1, expression) =>
            check(c0, t1, expression)
            t1
    }
}


checkSame(t1: Type, t2: Type): Unit {
    if(t1.name != t2.name) {throw(TypeError("Type mismatch: " + t1 + " vs. " + t2))}
    if(t1.typeArguments.size() != t2.typeArguments.size()) {
        throw(TypeError(
            "Type mismatch: " + t1.name + " with " + 
            t1.typeArguments.size() + " vs. " + t2.typeArguments.size() +
            " type arguments."
        ))
    }
    t1.typeArguments.zip(t2.typeArguments).each {| Pair(t3, t4) =>
        checkSame(t3, t4)
    }
}
