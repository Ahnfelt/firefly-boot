// Haskell-like Generic programming / Scrap Your Boilerplate. Thanks to nathanf for instructions.

type GFields[First, Second](
    first: First
    second: Second
)

type GNoFields()

type GField[Name, Value](value: Value)


type GConstructors[Left, Right] {
    GLeft(value: Left)
    GRight(value: Right)
}

type GNoConstructors {}

type GConstructor[Name, Value](value: Value)


trait GType[Package, Module, Name, Constructors](constructors: Constructors)

trait S: GSymbol {
    symbol(): String
}


// Example of implementing a generic instance of Show

instance GFields[A: Show, B: Show]: Show {
    show(v) { show(v.first) + ", " + show(v.second) }
}

instance GNoFields: Show {
    show(v) { "" }
}

instance GField[S: GSymbol, V: Show]: Show {
    show(v) { symbol[S]() + " = " + show(v.value) }
}

instance GConstructors[A: Show, B: Show]: Show {
    show(v) {
        | GLeft(v) => show(v)
        | GRight(v) => show(v)
    }
}

instance GConstructor[S: GSymbol, V: Show]: Show {
    show(v) { symbol[S]() + "(" + show(v.value) + ")" }
}

instance GType[P, M, N, C: Show]: Show {
    show(v) {
        show(v.constructors)
    }
}
