// Haskell-like Generic programming. Thanks to nathanf for instructions.

type GFields[First, Second](
    first: First
    second: Second
)

type GNoFields()

type GField[Name, Value](value: Value)


type GConstructors[Left, Right] {
    GLeft(value: Left)
    GRight(value: Right)
}

type GNoConstructors {}

type GConstructor[Name, Value](value: Value)


trait GType[Package, Module, Name, Constructors](constructors: Constructors)

trait S: GSymbol {
    symbol(): String
}


trait T: Generic[R] {
    toGeneric(value: T): R
    fromGeneric(generic: R): T
}


// Example of implementing a generic instance of Show

instance GFields[A: Show, B: Show]: Show {
    show(v) { show(v.first) + ", " + show(v.second) }
}

instance GNoFields: Show {
    show(v) { "" }
}

instance GField[S: GSymbol, V: Show]: Show {
    show(v) { symbol[S]() + " = " + show(v.value) }
}

instance GConstructors[A: Show, B: Show]: Show {
    show(v) {
        | GLeft(v) => show(v)
        | GRight(v) => show(v)
    }
}

instance GConstructor[S: GSymbol, V: Show]: Show {
    show(v) { symbol[S]() + "(" + show(v.value) + ")" }
}

instance GType[P, M, N, C: Show]: Show {
    show(v) {
        show(v.constructors)
    }
}

// Example of using the generic instance of Show above

trait T: Show {
    show(value: T): String {
        show(toGeneric(value)) // Type checked at each instance, not in the trait (to allow T: Generic[R])
    }
}

type User(id: Int, email: String)

instance User: Show

