// Haskell-like Generic programming. Thanks to nathanf for instructions.

type GFields[First, Second](
    first: First
    second: Second
)

type GNoFields()

type GField[Symbol, Value](value: Value)

trait S: GFieldSymbol {
    fieldName(): String
}


type GConstructors[Left, Right] {
    GLeft(value: Left)
    GRight(value: Right)
}

type GNoConstructors {}

type GConstructor[Symbol, Value](value: Value)

trait S: GConstructorSymbol {
    constructorName(): String
}


trait GType[Symbol, Constructors](constructors: Constructors)

trait S: GTypeSymbol {
    typeName(): String
    packageName(): String
    moduleName(): String
}


trait T: Generic[R] {
    toGeneric(value: T): R
    fromGeneric(generic: R): T
}


// Example of implementing a generic instance of Show

instance GFields[A: Show, B: Show]: Show {
    show(v) { show(v.first) + ", " + show(v.second) }
}

instance GNoFields: Show {
    show(v) { "" }
}

instance GField[S: GFieldSymbol, V: Show]: Show {
    show(v) { fieldName[S]() + " = " + show(v.value) }
}

instance GConstructors[A: Show, B: Show]: Show {
    show(v) {
        | GLeft(v) => show(v)
        | GRight(v) => show(v)
    }
}

instance GConstructor[S: GConstructorSymbol, V: Show]: Show {
    show(v) { constructorName[S]() + "(" + show(v.value) + ")" }
}

instance GType[S, C: Show]: Show {
    show(v) {
        show(v.constructors)
    }
}

// Example of using the generic instance of Show above

trait T: Show {
    show(value: T): String {
        show(toGeneric(value)) // Type checked at each instance, not in the trait (to allow T: Generic[R])
    }
}

type User(id: Int, email: String)

instance User: Show

