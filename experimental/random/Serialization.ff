type Person(id: Int, male: Bool, name: String)

instance Person: Serializable {
    serializeUsing(serialization: Serialization, value: Person): Unit {
        serializeUsing(serialization, value.id)
        serializeUsing(serialization, value.male)
        serializeUsing(serialization, value.name)
    }
    deserializeUsing(serialization: Serialization): Person {
        Person(
            deserializeUsing(serialization)
            deserializeUsing(serialization)
            deserializeUsing(serialization)
        )
    }
    typeChecksum(): Int {7}
}

main(system: BrowserSystem) {
    let p = Person(5, True, "Hans")
    Log.show(p)
    Log.show(serialize(p))
    Log.show(deserialize[Person](serialize(p)))

    let numbers = 1.to(1000).toArray()

    let serialized = serialize(numbers)
    let deserialized = deserialize(serialized)
    Log.show(numbers == deserialized)

    function test() {
        let persons = 1.to(1000000).map{ n =>
            Person(n, n % 2 == 0, "Person called " + n)
        }.toArray()

        let started = system.time().elapsed()
        let personsSerialized = serialize(persons)
        let deserializeStarted = system.time().elapsed()
        let personsDeserialized = deserialize(personsSerialized)
        Log.show(Duration(system.time().elapsed().seconds - deserializeStarted.seconds))
        Log.show(Duration(system.time().elapsed().seconds - started.seconds))
        Log.show(persons == personsDeserialized)
        Log.show(persons.toList().takeFirst(2))
        Log.show(personsDeserialized.toList().takeFirst(2))
    }
    test()
    //system.tasks().sleep(Duration(10.0))
    //test()
    //system.tasks().sleep(Duration(10.0))
    //test()
}

serialize[T: Serializable](value: T, initialBufferSize: Int = 1024): Buffer {
    let serialization = Serialization(Buffer.make(initialBufferSize), 4)
    serialization.buffer.setInt32(0, typeChecksum[T]())
    serializeUsing(serialization, value)
    serialization.buffer.view(0, serialization.offset)
}

deserialize[T: Serializable](buffer: Buffer): T {
    let serialization = Serialization(buffer, 4)
    let hash = serialization.buffer.grabInt32(0)
    if(hash != typeChecksum[T]()) {
        panic("Serialization type checksum mismatch. Expected: " + typeChecksum[T]() + ", got: " + hash + ".")
    }
    deserializeUsing(serialization)
}

trait T: Serializable {
    serializeUsing(serialization: Serialization, value: T): Unit
    deserializeUsing(serialization: Serialization): T
    typeChecksum(): Int
}

type Serialization(
    mutable buffer: Buffer
    mutable offset: Int
)

extend self: Serialization {
    autoResize(minSpareCapacity: Int) {
        if(self.offset + minSpareCapacity > self.buffer.size()) {
            let minSize = self.buffer.size() + minSpareCapacity
            let newBuffer = Buffer.make((self.buffer.size() * 2).max(minSize))
            newBuffer.setAll(0, self.buffer)
            self.buffer = newBuffer
        }
    }
}

instance Int: Serializable {
    serializeUsing(serialization: Serialization, value: Int): Unit {
        serialization.autoResize(8)
        serialization.buffer.setInt64(serialization.offset, value)
        serialization.offset += 8
    }
    deserializeUsing(serialization: Serialization): Int {
        let result = serialization.buffer.grabInt64(serialization.offset)
        serialization.offset += 8
        result
    }
    typeChecksum(): Int {1019}
}

instance Bool: Serializable {
    serializeUsing(serialization: Serialization, value: Bool): Unit {
        serialization.autoResize(1)
        serialization.buffer.setUint8(serialization.offset, if(value) {1} else {0})
        serialization.offset += 1
    }
    deserializeUsing(serialization: Serialization): Bool {
        let result = serialization.buffer.grabUint8(serialization.offset)
        serialization.offset += 1
        result == 1
    }
    typeChecksum(): Int {2017}
}

instance Array[T: Serializable]: Serializable {
    serializeUsing(serialization: Serialization, value: Array[T]): Unit {
        serialization.autoResize(8)
        serialization.buffer.setInt64(serialization.offset, value.size())
        serialization.offset += 8
        value.each {serializeUsing(serialization, _)}
    }
    deserializeUsing(serialization: Serialization): Array[T] {
        let size = serialization.buffer.grabInt64(serialization.offset)
        serialization.offset += 8
        Array.fillBy(size) {_ => deserializeUsing(serialization)}
    }
    typeChecksum(): Int {4079}
}

instance String: Serializable {
    serializeUsing(serialization: Serialization, value: String): Unit {
        serialization.autoResize(1 + value.size())
        serialization.buffer.setUint8(serialization.offset, value.size() + 128)
        if(value.size() < 128 && internalSetLatin1(serialization.buffer, serialization.offset + 1, value)) {
            serialization.offset += 1 + value.size()
        } else {
            let stringBuffer = value.toBuffer()
            serialization.autoResize(8 + stringBuffer.size())
            serialization.buffer.setInt64(serialization.offset, stringBuffer.size(), littleEndian = False)
            serialization.buffer.setAll(serialization.offset + 8, stringBuffer)
            serialization.offset += 8 + stringBuffer.size()
        }
    }
    deserializeUsing(serialization: Serialization): String {
        let sizePlus128 = serialization.buffer.grabUint8(serialization.offset)
        if(sizePlus128 >= 128) {
            let result = internalGrabLatin1(serialization.buffer, serialization.offset + 1, sizePlus128 - 128)
            serialization.offset += 1 + sizePlus128 - 128
            result
        } else {
            let size = serialization.buffer.grabInt64(serialization.offset, littleEndian = False)
            let stringBuffer = serialization.buffer.view(serialization.offset + 8, serialization.offset + 8 + size)
            serialization.offset += 8 + size
            stringBuffer.toString()
        }
    }
    typeChecksum(): Int {3011}
}


internalSetLatin1(self: Buffer, byteOffset: Int, value: String): Bool
    target js sync """
        for(let i = 0; i < value_.length; i++) {
            let charCode = value_.charCodeAt(i)
            if(charCode >= 256) return false
            self_.setUint8(byteOffset_ + i, charCode)
        }
        return true
    """

internalGrabLatin1(self: Buffer, byteOffset: Int, size: Int): String
    target js sync """
        const codeUnits = new Uint8Array(self_.buffer, self_.byteOffset + byteOffset_, size_)
        return String.fromCharCode.apply(null, codeUnits)
    """
