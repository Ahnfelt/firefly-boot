trait T: Serializable {
    typeHash(): Int
    serializeUsing(serialization: Serialization, value: T): Unit
    deserializeUsing(serialization: Serialization): T
}

type Serialization(
    mutable buffer: Buffer
    mutable offset: Int
)

extend self: Serialization {
    autoResize(minSpareCapacity: Int) {
        if(self.offset + minSpareCapacity > self.buffer.size()) {
            let minSize = self.buffer.size() + minSpareCapacity
            let newBuffer = Buffer.make((self.buffer.size() * 2).max(minSize))
            newBuffer.setAll(0, self.buffer)
            self.buffer = newBuffer
        }
    }
}

serialize[T: Serializable](value: T, initialBufferSize: Int = 1024): Buffer {
    let serialization = Serialization(Buffer.make(initialBufferSize), 4)
    serialization.buffer.setInt32(typeHash[T]())
    serializeUsing(serialization, value)
    serialization.buffer.view(0, serialization.offset)
}

deserialize[T: Serializable](buffer: Buffer): T {
    let serialization = Serialization(buffer, 4)
    let hash = serialization.buffer.grabInt32(0)
    if(hash != typeHash[T]()) {
        panic("Serialization type hash mismatch. Expected: " + typeHash[T]() + ", got: " + hash + ".")
    }
    deserializeUsing(serialization)
}

instance Int: Serializable {
    typeHash(): Int {1019}
    serializeUsing(serialization: Serialization, value: Int): Unit {
        serialization.autoResize(8)
        serialization.buffer.setInt64(serialization.offset, value)
        serialization.offset += 8
    }
    deserializeUsing(serialization: Serialization): Int {
        let result = serialization.buffer.grabInt64(serialization.offset)
        serialization.offset += 8
        result
    }
}
