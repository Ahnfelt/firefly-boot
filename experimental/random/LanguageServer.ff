class LanguageServer(
    mutable openFiles: Map[String, String]
)

capability Request(
    headers: Map[String, String]
    object: JsValue
)

data BadRequestException(reason: String)

/*extend self: LanguageServer {

    handleRequest(request: LanguageServerRequest): LanguageServerResponse {

    }

}*/

main(system: NodeSystem) {
    try {
        let requestPair = parseRequest(system, system.readStream())
        let request = requestPair.first
        let json = request.object
        Log.show(json.get("x").grabInt())
    } catch {| BadRequestException(reason), error =>
         system.writeErrorText(reason + "\n")
    } grab()
}

parseRequest(system: NodeSystem, input: Stream[Buffer]): Pair[Request, Stream[Buffer]] {
    let headersPair = parseHeaders(input)
    let headers = headersPair.first
    let contentLength = headers
        .get("content-length").else {throw(BadRequestException("'content-length' header is missing"))}
        .getInt().else {throw(BadRequestException("Value for 'content-length' is not an integer"))}
    let bodyPair = parseBody(system.js(), contentLength, headersPair.second)
    bodyPair.mapFirst {body => Request(headers, body)}
}

parseHeaders(input: Stream[Buffer]): Pair[Map[String, String], Stream[Buffer]] {
    let buffers = Stack.make()
    mutable buffer = input.next()
        .else{throw(BadRequestException("End of input while parsing request headers"))}
    mutable offset = 0
    mutable lastWasNewline = False
    mutable done = False
    while {!done} {
        let byte = buffer.grabUint8(offset)
        if(byte == '\n'.codeUnit) {
            if(lastWasNewline) {
                done = True
            } else {
                lastWasNewline = True
            }
        } elseIf {byte != '\r'.codeUnit && lastWasNewline} {
            lastWasNewline = False
        }
        offset += 1
        if(offset == buffer.size()) {
            offset = 0
            buffers.push(buffer)
            buffer = input.next()
                .else{throw(BadRequestException("End of input while parsing request headers"))}
        }
    }
    buffers.push(buffer.view(0, offset))
    let headers = Buffer.fromBufferArray(buffers.drain()).toString()
    let map = headers.lines().pairs().filter {_.second.size() != 0}.map {| Pair(i, line) =>
        line.splitFirst(':').else {throw(BadRequestException("Invalid header at line " + i))}
            .mapFirst {_.lower()} //.mapSecond {_.trim()}
    }.toMap()
    Pair(map, [buffer.view(offset, buffer.size())].toStream().addAll(input))
}

parseBody(js: JsSystem, contentLength: Int, input: Stream[Buffer]): Pair[JsValue, Stream[Buffer]] {
    let bodyPair = try {
        input.readBytes(contentLength) // Should Stream.readBytes return an option?
    } catchAny { error =>
        throw(BadRequestException("End of input while parsing request body"))
    } grab()
    let body = Buffer.fromBufferArray(bodyPair.first).toString()
    let json = try {
        js.parseJson(body)
    } catchAny { error =>
        throw(BadRequestException("Invalid JSON in request body"))
    } grab()
    Pair(json, bodyPair.second)
}
