type Body(term: Int)

type Constructor(
    name: String
    arity: Int
    span: Int
)

type Pattern {
    PVariable(name: String)
    PConstructor(
        constructor: Constructor
        patterns: List[Pattern]
    )
}

type Match(
    rules: List[Pair[Pattern, Body]]
)

type TermDescription {
    Positive(
        constructor: Constructor
        descriptions: List[TermDescription]
    )
    Negative(constructors: Set[Constructor])
}

type Context(
    list: List[Pair[Constructor, List[TermDescription]]]
)

type MatchResult {
    Yes
    No
    Maybe
}

type Access{
    Object
    Select(
        index: Int
        access: Access
    )
}

type Decision {
    Failure
    Success(body: Body)
    IfEqual(
        access: List[Int]
        constructor: Constructor
        left: Decision
        right: Decision
    )
}

type Work(
    pattern: Pattern
    object: List[Int]
    description: TermDescription
)

staticMatch(
    constructor: Constructor,
    description: TermDescription
) : MatchResult {
    | c1, Positive(c2, _) { c1 == c2 } => Yes
    | c1, Positive(_, _) => No
    | c1, Negative(noneOf) { noneOf.contains(c1) } => No
    | c1, Negative(noneOf) { c1.span == 1 + noneOf.size() } => Yes
    | _, Negative(_) => Maybe
}

augment(context: Context, description: TermDescription): Context {
    | Context([]), _ => Context([])
    | Context([Pair(c, ds), ...rest]), d => Context([Pair(c, [d, ...ds]), ...rest])
}

norm(context: Context): Context {
    | Context([Pair[c, ds], ..rest]) => augment(rest, Pos(c, ds.reverse()))
    | _ => panic("Norm is unexhaustive(!)")
}

compile(input: Match): Decision {

    function fail(description: Description, match: Match): Decision {
    }

    function succeed(context: Context, works: List[Work], body: Body, match: Match): Decision {
    }

    function match(pattern: Pattern, )

    fail(Negative([]), input)
}
