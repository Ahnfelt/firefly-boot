import UnsafeJs from ff:unsafejs

newtype PgPool!(jsValue: JsValue)
newtype PgConnection!(jsValue: JsValue)
newtype PgRow(jsValue: JsValue)
type PgStatement!(sql: String, parameters: Map[String, JsValue], connection: Option[PgConnection])
type PgLevel {
    PgReadCommitted
    PgRepeatableRead
    PgSerializable
}

makePool(
    system: NodeSystem
    user: String
    host: String
    database: String
    password: () => String
    port: Int = 5432
    connectionTimeout: Duration = Duration(10.0)
    idleTimeout: Duration = Duration(10.0)
    maxConnections: Int = 10
    allowExitOnIdle: Bool = True
): PgPool {
    UnsafeJs.throwIfCancelled()
    let js = UnsafeJs.jsSystem()
    let pg = UnsafeJs.import("pg").get("default")
    PgPool(pg.get("Pool").new1(js.object()
        .with("user", user)
        .with("host", host)
        .with("database", database)
        .with("password", js.function0(password))
        .with("port", port)
        .with("connectionTimeoutMillis", connectionTimeout.seconds * 1000)
        .with("idleTimeoutMillis", idleTimeout.seconds * 1000)
        .with("max", maxConnections)
        .with("allowExitOnIdle", allowExitOnIdle)
    ))
}

makePoolFromConnectionString(
    system: NodeSystem
    connectionString: String
    connectionTimeout: Duration = Duration(10.0)
    idleTimeout: Duration = Duration(10.0)
    maxConnections: Int = 10
    allowExitOnIdle: Bool = True
): PgPool {
    UnsafeJs.throwIfCancelled()
    let js = UnsafeJs.jsSystem()
    let pg = UnsafeJs.import("pg").get("default")
    PgPool(pg.get("Pool").new1(js.object()
        .with("connectionString", connectionString)
        .with("connectionTimeoutMillis", connectionTimeout.seconds * 1000)
        .with("idleTimeoutMillis", idleTimeout.seconds * 1000)
        .with("max", maxConnections)
        .with("allowExitOnIdle", allowExitOnIdle)
    ))
}

extend self: PgPool {

    connect(): PgConnection {
        UnsafeJs.throwIfCancelled()
        PgConnection(UnsafeJs.await { self.jsValue.call0("connect") })
    }

    close(): Unit {
        UnsafeJs.await { self.jsValue.call0("end") }
    }

    connectionCount(): Int {
        self.jsValue.get("totalCount").expectInt()
    }

    idleCount(): Int {
        self.jsValue.get("idleCount").expectInt()
    }

    waitingCount(): Int {
        self.jsValue.get("waitingCount").expectInt()
    }

    transaction[T](body: PgConnection => T, level: PgLevel = PgReadCommitted): T {
        let connection = self.connect()
        mutable done = False
        try {
            connection.statement("begin").run()
            level.{
                | PgReadCommitted => 0 // Default level in PostgreSQL
                | PgRepeatableRead => connection.statement("set transaction isolation level repeatable read").run()
                | PgSerializable => connection.statement("set transaction isolation level serializable").run()
            }
            let result = body(connection)
            done = True
            connection.statement("commit").run()
            result
        } finally {
            if(!done) {connection.statement("rollback").run()}
            connection.release()
        } expect()
    }

}

extend self: PgConnection {

    release(): Unit {
        if(UnsafeJs.cancelled()) {
            self.jsValue.call1("release", True)
        } else {
            self.jsValue.call0("release")
        }
    }

    statement(sql: String): PgStatement {
        PgStatement(sql, [].toMap(), Some(self))
    }

}

extend self: PgStatement {

    withBool(name: String, value: Bool): PgStatement {
        let p = UnsafeJs.jsSystem().value(value)
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withNullableBool(name: String, value: Option[Bool]): PgStatement {
        let p = value.map(UnsafeJs.jsSystem().value).else {UnsafeJs.jsSystem().null()}
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withInt(name: String, value: Int): PgStatement {
        let p = UnsafeJs.jsSystem().value(value)
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withNullableInt(name: String, value: Option[Int]): PgStatement {
        let p = value.map(UnsafeJs.jsSystem().value).else {UnsafeJs.jsSystem().null()}
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withFloat(name: String, value: Float): PgStatement {
        let p = UnsafeJs.jsSystem().value(value)
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withNullableFloat(name: String, value: Option[Float]): PgStatement {
        let p = value.map(UnsafeJs.jsSystem().value).else {UnsafeJs.jsSystem().null()}
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withString(name: String, value: String): PgStatement {
        let p = UnsafeJs.jsSystem().value(value)
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withNullableString(name: String, value: Option[String]): PgStatement {
        let p = value.map(UnsafeJs.jsSystem().value).else {UnsafeJs.jsSystem().null()}
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withBoolArray(name: String, value: Array[Bool]): PgStatement {
        let p = UnsafeJs.jsSystem().value(value)
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withNullableBoolArray(name: String, value: Option[Array[Bool]]): PgStatement {
        let p = value.map(UnsafeJs.jsSystem().value).else {UnsafeJs.jsSystem().null()}
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withIntArray(name: String, value: Array[Int]): PgStatement {
        let p = UnsafeJs.jsSystem().value(value)
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withNullableIntArray(name: String, value: Option[Array[Int]]): PgStatement {
        let p = value.map(UnsafeJs.jsSystem().value).else {UnsafeJs.jsSystem().null()}
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withFloatArray(name: String, value: Array[Float]): PgStatement {
        let p = UnsafeJs.jsSystem().value(value)
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withNullableFloatArray(name: String, value: Option[Array[Float]]): PgStatement {
        let p = value.map(UnsafeJs.jsSystem().value).else {UnsafeJs.jsSystem().null()}
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withStringArray(name: String, value: Array[String]): PgStatement {
        let p = UnsafeJs.jsSystem().value(value)
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    withNullableStringArray(name: String, value: Option[Array[String]]): PgStatement {
        let p = value.map(UnsafeJs.jsSystem().value).else {UnsafeJs.jsSystem().null()}
        self.PgStatement(parameters = self.parameters.add(name, p))
    }

    run(): Int {
        internalRunStatement(self, None)
    }

    all(body: PgRow => Bool): Bool {
        internalRunStatement(self, Some(body)) == 1
    }

    any(body: PgRow => Bool): Bool {
        !self.all { row =>
            !body(row)
        }
    }

    each(body: PgRow => Unit): Unit {
        self.all { row =>
            body(row)
            True
        }
    }

    map[T](body: PgRow => T): List[T] {
        mutable result = []
        self.each { row =>
            result = [body(row), ...result]
        }
        result.reverse()
    }

}

extend self: PgRow {

    getBool(name: String): Option[Bool] {
        internalGet(self, name) {_.expectBool()}
    }

    getInt(name: String): Option[Int] {
        internalGet(self, name) {_.expectInt()}
    }

    getFloat(name: String): Option[Float] {
        internalGet(self, name) {_.expectFloat()}
    }

    getString(name: String): Option[String] {
        internalGet(self, name) {_.expectString()}
    }

    getBoolArray(name: String): Option[Array[Bool]] {
        internalGet(self, name) {_.expectArray().map {_.expectBool()}}
    }

    getIntArray(name: String): Option[Array[Int]] {
        internalGet(self, name) {_.expectArray().map {_.expectInt()}}
    }

    getFloatArray(name: String): Option[Array[Float]] {
        internalGet(self, name) {_.expectArray().map {_.expectFloat()}}
    }

    getStringArray(name: String): Option[Array[String]] {
        internalGet(self, name) {_.expectArray().map {_.expectString()}}
    }

}

internalGet[T](row: PgRow, name: String, body: JsValue => T): Option[T] {
    if(!row.jsValue.hasOwn(name)) {panic("Column not found in result: " + name)}
    let value = row.jsValue.get(name)
    if(!value.isNull()) {Some(body(value))} else {None}
}

internalRunStatement(statement: PgStatement, body: Option[PgRow => Bool]): Int {
    let pair = internalParseParameters(statement.sql)
    let parameters = pair.second.map { name =>
        statement.parameters.get(name).else {
            panic("No value for parameter: " + name)
        }
    }.toArray()
    let unusedParameters = statement.parameters.keys().removeAll(pair.second.toSet())
    if(unusedParameters.size() > 0) {
        panic("Unused parameters: " + unusedParameters.toList().join(", "))
    }
    UnsafeJs.throwIfCancelled()
    let result = UnsafeJs.await { statement.connection.expect().jsValue.call2("query", pair.first, parameters) }
    body.{
        | None =>
            result.get("rowCount").expectInt()
        | Some(f) =>
            let all = result.get("rows").expectArray().toList().all { row =>
                f(PgRow(row))
            }
            if(all) {1} else {0}
    }
}

internalParseParameters(statementSql: String): Pair[String, List[String]] {
    mutable parameters = []
    mutable parameterIndexes = [].toMap()
    mutable i = 0
    mutable last = 0
    mutable sql = ""
    while {i < statementSql.size()} {
        if(statementSql.expect(i) == '$') {
            sql = sql + statementSql.slice(last, i)
            i += 1
            last = i
            if(statementSql.expect(i) == '$') {
                i += 1
            } else {
                while {i < statementSql.size() && statementSql.expect(i).isAsciiLetterOrDigit()} {
                    i += 1
                }
                let name = statementSql.slice(last, i)
                if(name != "") {
                    let index = parameterIndexes.get(name).else {
                        let newIndex = parameterIndexes.size() + 1
                        parameterIndexes = parameterIndexes.add(name, newIndex)
                        parameters = [name, ...parameters]
                        newIndex
                    }
                    sql = sql + "$" + index
                    last = i
                }
            }
        } else {
            i += 1
        }
    }
    sql = sql + statementSql.slice(last, i)
    Pair(sql, parameters.reverse())
}

main(system: NodeSystem): Unit {

    let pool = makePool(
        system = system
        host = system.arguments().expect(0)
        database = system.arguments().expect(1)
        user = system.arguments().expect(2)
        password = {system.arguments().expect(3)}
    )

    pool.transaction { connection =>
        let parties = connection.statement("""
            select name, listCode, entityId
            from election."PartyRow"
            where entityId < $maxEntityId
        """)
            .withInt("maxEntityId", 200)
            .map {row =>
                (
                    name = row.getString("name").expect()
                    listCode = row.getString("listcode").expect()
                    entityId = row.getInt("entityid").expect()
                )
            }
        parties.each(Log.debug)
    }
}
