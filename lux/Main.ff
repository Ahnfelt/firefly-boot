import HttpServer from ff:httpserver

import Lux
import LuxEvent
import Css

data ChatEntry(
    question: String
    answer: Option[String]
)

mainComponent(lux: Lux, http: HttpClient) {
    lux.useState([]): chat, setChat => 
    lux.useState(""): message, setMessage =>
    lux.div {
        lux.div {
            chat.each {questionComponent(lux, http, _)}
        }
        lux.form {
            lux.input {
                //.with("autofocus", "true")
                lux.setValue(message)
                lux.onInput {event => setMessage(event.text())}
            }
            lux.on("submit") {event => 
                event.preventDefault()
                setMessage("")
                setChat([...chat, message])
            }
        }
    }
}

questionComponent(lux: Lux, http: HttpClient, question: String) {
    let questionCss = CssClass([Css.marginBottom("10px")], [])
    lux.div {
        lux.cssClass(questionCss)
        lux.div {lux.text("User: " + question)}
        lux.useLazy1(question): _ =>
        lux.useSuspense {lux.div {lux.text("Assistant typing...")}}: lux =>
        let answer = http.fetch(
            url = "/chat"
            method = "POST"
            body = Some(HttpClient.bodyText(question))
        ).readText()
        lux.div {lux.text("Assistant: " + answer)}
    }
}

browserMain(system: BrowserSystem) {
    Lux.renderById(system, "main") {lux => mainComponent(lux, system.httpClient())}
}

nodeMain(system: NodeSystem) {
    let openAiKey = system.arguments().first()
    HttpServer.listen(system, "localhost", 8080) {request, response =>
        if(request.path() == "/") {
            response.setHeader("Content-Type", ["text/html; charset=UTF-8"])
            response.writeText("<!doctype html>")
            response.writeText("<div id='main'></div>")
            response.writeText("<script type='module' src='/js/script/script/Main.mjs'></script>")
        } elseIf {request.path().startsWith("/js/") && !request.path().contains("..")} {
            response.setHeader("Content-Type", ["text/javascript; charset=UTF-8"])
            response.writeText(system.assets().readText(request.path()))
        } elseIf {request.path() == "/chat"} {
            let question = request.readText()
            response.setHeader("Content-Type", ["text/plain; charset=UTF-8"])
            openAiKey.{
                | None => 
                    system.mainTask().sleep(Duration(question.size().toFloat()))
                    response.writeText("Hi! You need to give an OpenAI secret key at the command line.")
                | Some(key) => 
                    let chatJson = encodeChat(system.js(), question)
                    let answer = fetchAnswer(system.httpClient(), system.js(), key, chatJson)
                    response.writeText(answer)
            }
        } else {
            response.writeStatus(404, Some("Not found"))
        }
    }
}

fetchAnswer(httpClient: HttpClient, js: JsSystem, key: String, question: JsValue): String {
    let json = httpClient.fetch(
        url = "https://api.openai.com/v1/chat/completions"
        method = "POST"
        headers = [
            Pair("Authorization", "Bearer " + key)
            Pair("Content-Type", "application/json")
        ]
        body = Some(HttpClient.bodyText(question.toJson()))
    ).readText()
    js.parseJson(json).get("choices").get(0).get("message").get("content").grabString()
}

encodeChat(js: JsSystem, question: String): JsValue {
    let systemJson = js.object()
        .with("role", "system")
        .with("content", "You are a helpful assistant.")
    let questionJson = js.object()
        .with("role", "user")
        .with("content", question)
    let messagesJson = js.array([systemJson, questionJson])
    js.object()
        .with("model", "gpt-3.5-turbo")
        .with("messages", messagesJson)
}


/*
let
encodeMessage role content = 
    E.object  [ ("role", E.string role), ("content", E.string content) ]
encodeEntry question maybeAnswer = case maybeAnswer of
    Nothing -> [ encodeMessage "user" question ]
    Just answer -> [ encodeMessage "user" question, encodeMessage "assistant" answer ]
encodedMessages = encodeMessage "system" "You are a helpful assistant."
    :: List.concatMap (\entry -> encodeEntry entry.question entry.answer) chat
in E.object 
[ ("model", E.string "gpt-3.5-turbo")
, ("messages", E.list (\x -> x) encodedMessages)
]
*/
buildMain(system: BuildSystem) {
    let browser = system.compileForBrowser("Main.ff")
    let assets = AssetSystem.create().addAssets("/js", browser.assets())
    system.setAssets(assets)
}
