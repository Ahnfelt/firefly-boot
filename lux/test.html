<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>VDOM diff and patch test</title>
</head>
<body>
    <script>
        const empty = {key: '', children: [], callback: null, props: new Map()}
        function update(element, oldLux, newLux) {
            if(oldLux === newLux) return element
            // If it's a hook, transfer the props, invoke the callback and patch recursively
            if(typeof newLux.callback === 'function') {
                if(typeof oldLux.callback === 'function') {
                    newLux.props = oldLux.props
                }
                newLux.callback(true)
                return update(element, oldLux.children[0] || empty, newLux.children[0])
            }
            // Create the element if it doesn't already exist
            if(!element) {
                const tagEnd = newLux.key.indexOf('>')
                const tag = tagEnd === -1 ? newLux.key : newLux.key.slice(0, tagEnd)
                element = document.createElement(tag)
            }
            // Patch props
            if(oldLux.props !== newLux.props) {
                newLux.props.forEach((value, name) => {
                    const oldValue = oldLux.props.get(name)
                    if(oldValue !== value) {
                        if(name[0] === '$') element.addEventListener(name.slice(1), value)
                        else element[name] = value
                        if(oldValue !== void 0) oldLux.props.delete(name)
                    }
                })
                oldLux.props.forEach((value, name) => {
                    if(name[0] === '$') element.removeEventListener(name.slice(1), value)
                    else element[name] = void 0
                })
            }
            // Speed through matching prefix
            const oldChildren = oldLux.children
            const newChildren = newLux.children
            const minLength = Math.min(oldChildren.length, newChildren.length)
            let i = 0
            while(i < minLength && oldChildren[i] === newChildren[i]) i++
            for(; i < minLength && oldChildren[i].key === newChildren[i].key; i++) {
                update(element.childNodes[i], oldChildren[i], newChildren[i])
            }
            if(i === oldChildren.length && i === newChildren.length) return element
            // If not done, do the complicated rearrange
            const indexMap = new Map()
            // First build a multimap from old keys to indexes
            for(let j = i; j < oldChildren.length; j++) {
                const child = oldChildren[j]
                const indexes = indexMap.get(child.key)
                if(indexes === void 0) {
                    indexMap.set(child.key, j)
                } else if(typeof indexes === 'number') {
                    indexMap.set(child.key, [indexes, j])
                } else {
                    indexes.push(j)
                }
            }
            // Then go through the new children, diff and patch
            for(; i < newChildren.length; i++) {
                const child = newChildren[i]
                const indexes = indexMap.get(child.key)
                if(indexes === i) {
                    // Preserve element
                    indexMap.delete(child.key)
                    if(!newChildren[i].key.startsWith('<text')) {
                        update(element.childNodes[i], oldChildren[i], newChildren[i])
                    }
                } else if(indexes === void 0) {
                    // Create and insert new element
                    if(newChildren[i].key.startsWith('<text')) {
                        const text = newChildren[i].key.slice(newChildren[i].key.indexOf('>') + 1)
                        const newNode = document.createTextNode(text);
                        element.insertBefore(newNode, element.childNodes[i] || null)
                    } else {
                        const newElement = update(null, empty, newChildren[i])
                        element.insertBefore(newElement, element.childNodes[i] || null)
                    }
                } else {
                    // Preserve and move element
                    const index = 
                        typeof indexes === 'number' ? indexes : 
                        indexes.length === 2 ? (indexMap.set(child.key, indexes[1]), indexes[0]) :
                        indexes.shift()
                    element.insertBefore(element.childNodes[index], element.childNodes[i] || null)
                    if(!newChildren[i].key.startsWith('<text')) {
                        update(element.childNodes[i], oldChildren[index], newChildren[i])
                    }
                }
            }
            // Unmount the vdom nodes that didn't survive and delete the corresponding trailing elements
            indexMap.forEach(indexes => { 
                if(typeof indexes === 'number') unmount(oldChildren[indexes])
                else for(const index of indexes) unmount(oldChildren[index])
            })
            while(i < element.childNodes.length) {
                element.removeChild(element.childNodes[i])
            }
            return element
        }
        function unmount(oldLux) {
            if(oldLux.children) for(child of oldLux.children) unmount(child)
            if(typeof oldLux.callback === 'function') oldLux.callback(false)
        }
    </script>
    <div id="main"><hr></div>
    <script>
        function el(key) {
            const hasProps = typeof arguments[1] === 'object' && !arguments[1].key
            return {
                key: key, 
                children: ([...arguments].slice(hasProps ? 2 : 1) || []).map(c => 
                    typeof c === 'string' || typeof c === 'number' || typeof c === 'boolean' ? {key: '<text>' + c} : c
                ),
                callback: hasProps ? arguments[1].$ || null : null,
                props: new Map(Object.entries(hasProps ? arguments[1] : {})),
            }
        } // Convenience
        function useState(initialValue_, body_) {
            let vdom = null // Set this somehow
            let node = {key: '<state', children: [], callback: null, props: new Map([['value', initialValue_]])}
            const setValue = newValue => {
                node.props.set('value', newValue)
                vdom.update()
            }
            node.callback = live => {
                if(live) {
                    node.children.push(body_(node.props.get('value'), setValue))
                }
            }
            return node
        }
        update(document.getElementById("main"), 
            el("div", el("hr")), 
            el("div", el("button", "his"))
        )
        update(document.getElementById("main"), 
            el("div", el("button", "his")), 
            el("div", "ok")
        )
        update(document.getElementById("main"), 
            el("div", "ok"), 
            el("div", "now", "now", "now")
        )
        update(document.getElementById("main"), 
            el("div", "now", "now", "now"), 
            el("div", {style: 'color: red', $click: () => alert('hi')}, "cow", useState(1, v => el("b", v)), "bow")
        )
    </script>
</body>
</html>
