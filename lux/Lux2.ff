import Lux2 as Lux
import LuxEvent

capability Lux(mutable key: String) {
    LuxText()
    LuxTag(props: StringMap[JsValue], children: Stack[Lux])
    LuxHook(valueBox: Box[Any], childBox: Box[Lux], update: LuxNode => LuxNode, umount: () => Unit)
}

new(tagName: String, text: String = ""): Lux {
    LuxTag("<" + tagName + ">", StringMap.make(), if(text != "") {[LuxText("'" + text)].toStack()} else {[].toStack()})
}

useState[T: HasAnyTag](initial: T, body: (T, T => Unit) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    let valueBox = Box(Any.toAny(initial))
    let childBox = Box(LuxText(""))
    let key = "$" + location.location + "$" + Any.anyTag[T]().show() + "$"
    let update = {oldNode =>
        let oldChild = childBox.value
        mutable setValue = {_ => }
        setValue = {newValue => 
            valueBox.value = Any.toAny(newValue)
            internalRequestAnimationFrame {
                let value = Any.fromAny[T](valueBox.value).grab()
                let newChild = body(value, setValue)
                internalPatch(oldNode, oldChild, newChild)
                childBox.value = newChild
            }
        }
        let value = Any.fromAny[T](valueBox.value).grab()
        let newChild = body(value, setValue)
        let newNode = internalPatch(oldNode, oldChild, newChild)
        childBox.value = newChild
        newNode
    }
    let unmount = {internalUnmount(childBox.value)}
    LuxHook(key, valueBox, childBox, update, unmount)
}

internalRequestAnimationFrame(body: () => Unit): Unit
    target js async "requestAnimationFrame(() => body_($task))" // TODO: frame won't wait for promise
    target js sync "requestAnimationFrame(body_)"

extend self: Lux {
    
}

data LuxNode {}

internalElement(key: String): LuxNode
    target js sync """
        return document.createElement(key_.slice(1, key_.indexOf('>')))
    """

internalText(key: String): LuxNode
    target js sync """
        return document.createTextNode(key_.slice(1))
    """

internalNull(): LuxNode
    target js sync """
        return null
    """

extend self: LuxNode {
    isNull(): Bool
        target js sync """
            return !self_
        """
    setProp(name: String, value: JsValue)
        target js sync """
            self_[name_] = value_
        """
    clearProp(name: String)
        target js sync """
            self_[name_] = null
        """
    grab(index: Int): LuxNode
        target js sync """
            return self_[index_]
        """
    insertAt(index: Int, node: LuxNode): LuxNode
        target js sync """
            return self_.insertBefore(node_, self_[index_])
        """
    delete(): LuxNode
        target js sync """
            return self_.parentElement.removeChild(self_)
        """
}

internalPatch(oldNode: LuxNode, old: Lux, new: Lux): LuxNode {
    | _, _, _ {same(old, new)} => 
        oldNode
    | _, LuxHook(_, oldValueBox, oldChildBox, _, _), LuxHook(_, newValueBox, newChildBox, update, _) =>
        newValueBox.value = oldValueBox.value
        newChildBox.value = oldChildBox.value
        update(oldNode)
    | _, _, LuxHook(_, _, _, update, _) =>
        update(oldNode)
    | _, LuxTag(_, oldProps, oldChildren), LuxTag(newKey, newProps, newChildren) => 
        let element = oldNode
        if(!same(oldProps, newProps)) {internalPatchProps(element, oldProps, newProps)}
        if(!same(oldChildren, newChildren)) {internalPatchChildren(element, oldChildren, newChildren)}
        element
    | _, _, LuxTag(newKey, newProps, newChildren) => 
        let element = internalElement(newKey)
        if(newProps.size() != 0) {internalPatchProps(element, StringMap.make(), newProps)}
        if(newChildren.size() != 0) {internalPatchChildren(element, [].toStack(), newChildren)}
        element
    | _, _, LuxText(newKey) {old.key == ""} => // We use LuxText("") as "no vnode"
        internalText(newKey)
    | _, _, _ => 
        oldNode
}

internalPatchProps(element: LuxNode, oldProps: StringMap[JsValue], newProps: StringMap[JsValue]) {
    newProps.each {name, value =>
        oldProps.get(name).{
            | None => element.setProp(name, value)
            | Some(oldValue) {!same(value, oldValue)} => element.setProp(name, value)
            | _ =>
        }
    }
    oldProps.each {name, _ =>
        if(!newProps.has(name)) {
            element.clearProp(name)
        }
    }
}

internalPatchChildren(element: LuxNode, oldChildren: Stack[Lux], newChildren: Stack[Lux]) {
    mutable oldStart = 0
    mutable newStart = 0
    mutable oldStop = oldChildren.size() - 1
    mutable newStop = newChildren.size() - 1
    let stop = oldStop.min(newStop)
    // If we're not yet done, patch key equal nodes from both ends
    while {oldStart < stop && oldChildren.grab(oldStart).key == newChildren.grab(newStart).key} {
        let oldLux = oldChildren.grab(oldStart)
        let newLux = newChildren.grab(newStart)
        if(!same(oldLux, newLux)) {internalPatch(element.grab(oldStart), oldLux, newLux)}
        oldStart += 1
        newStart += 1
    }
    while {oldStop > oldStart && newStop > newStart && oldChildren.grab(oldStop).key == newChildren.grab(newStop).key} {
        let oldLux = oldChildren.grab(oldStop)
        let newLux = newChildren.grab(newStop)
        if(!same(oldLux, newLux)) {internalPatch(element.grab(oldStop), oldLux, newLux)}
        oldStop -= 1
        newStop -= 1
    }
    // If we only need to delete nodes or only need to add nodes, do that
    if(newStart == newStop) {
        while {oldStart < oldStop} {
            internalUnmount(oldChildren.grab(oldStop))
            element.grab(oldStop).delete()
            oldStop -= 1
        }
    } elseIf {oldStart == oldStop} {
        while {newStart < newStop} {
            let childElement = internalPatch(internalNull(), LuxText(""), newChildren.grab(newStart))
            element.insertAt(newStart, childElement)
            newStart += 1
        }
    } else:
    // Otherwise, build an index multimap to, do out-of-order patching, and delete excess nodes
    let multiMap = StringMap.make()
    while {oldStart < oldStop} {
        let stack = multiMap.getOrSet(oldChildren.grab(oldStop).key) {Stack.make()}
        stack.push(Pair(oldStop, element.grab(oldStop)))
        oldStop -= 1
    }
    let emptyNode = LuxText("")
    let emptyStack = Stack.make()
    while {newStart < newStop} {
        let newLux = newChildren.grab(newStart)
        let oldPairs = multiMap.get(newLux.key).else {emptyStack}
        oldPairs.pop().{
            | None =>
                internalPatch(element.grab(newStart), emptyNode, newLux)
            | Some(Pair(oldIndex, oldNode)) =>
                element.insertAt(newStart, oldNode)
                let oldLux = oldChildren.grab(oldIndex)
                internalPatch(oldNode, oldLux, newLux)
        }
        newStart += 1
    }
    multiMap.each {_, pairs => 
        pairs.each {| Pair(oldIndex, oldNode) =>
            internalUnmount(oldChildren.grab(oldIndex))
            oldNode.delete()
        }
    }
}

internalUnmount(lux: Lux) {
    | LuxHook(_, _, _, _, umount) => umount()
    | LuxTag(_, _, children) => children.each {internalUnmount(_)}
    | LuxText(_) => 
}
