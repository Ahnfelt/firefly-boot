import Lux2 as Lux
import LuxEvent

capability Lux(mutable key: String) {
    LuxText()
    LuxTag(props: StringMap[JsValue], children: Stack[Lux])
    LuxHook(valueBox: Box[Any], childBox: Box[Lux], update: LuxNode => LuxNode, umount: () => Unit)
}

new(tagName: String, text: String = ""): Lux {
    LuxTag("<" + tagName + ">", StringMap.make(), if(text != "") {[LuxText("'" + text)].toStack()} else {[].toStack()})
}

useState[T: HasAnyTag](initial: T, body: (T, T => Unit) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    let valueBox = Box(Any.toAny(initial))
    let childBox = Box(LuxText(""))
    let key = "$" + location.location + "$" + Any.anyTag[T]().show() + "$"
    let update = {oldNode =>
        let oldChild = childBox.value
        mutable setValue = {_ => }
        setValue = {newValue => 
            valueBox.value = Any.toAny(newValue)
            internalRequestAnimationFrame {
                let value = Any.fromAny[T](valueBox.value).grab()
                let newChild = body(value, setValue)
                internalPatch(oldNode, oldChild, newChild)
                childBox.value = newChild
            }
        }
        let value = Any.fromAny[T](valueBox.value).grab()
        let newChild = body(value, setValue)
        let newNode = internalPatch(oldNode, oldChild, newChild)
        childBox.value = newChild
        newNode
    }
    let unmount = {internalUnmount(childBox.value)}
    LuxHook(key, valueBox, childBox, update, unmount)
}

internalRequestAnimationFrame(body: () => Unit): Unit
    target js async "requestAnimationFrame(() => body_($task))" // TODO: frame won't wait for promise
    target js sync "requestAnimationFrame(body_)"

extend self: Lux {
    
}

data LuxNode {}

internalElement(key: String): LuxNode
    target js sync """
        return document.createElement(key_.slice(1, key_.indexOf('>')))
    """

internalText(key: String): LuxNode
    target js sync """
        return document.createTextNode(key_.slice(1))
    """

internalNull(): LuxNode
    target js sync """
        return null
    """

extend self: LuxNode {
    isNull(): Bool
        target js sync """
            return !self_
        """
}

internalPatch(oldNode: LuxNode, old: Lux, new: Lux): LuxNode {
    | _, _, _ {same(old, new)} => 
        oldNode
    | _, LuxHook(_, oldValueBox, oldChildBox, _, _), LuxHook(_, newValueBox, newChildBox, update, _) =>
        newValueBox.value = oldValueBox.value
        newChildBox.value = oldChildBox.value
        update(oldNode)
    | _, _, LuxHook(_, _, _, update, _) =>
        update(oldNode)
    | _, LuxTag(_, oldProps, oldChildren), LuxTag(newKey, newProps, newChildren) => 
        let element = oldNode
        if(!same(oldProps, newProps)) {internalPatchProps(element, oldProps, newProps)}
        if(!same(oldChildren, newChildren)) {internalPatchChildren(element, oldChildren, newChildren)}
        element
    | _, _, LuxTag(newKey, newProps, newChildren) => 
        let element = internalElement(newKey)
        if(newProps.size() != 0) {internalPatchProps(element, StringMap.make(), newProps)}
        if(newChildren.size() != 0) {internalPatchChildren(element, [].toStack(), newChildren)}
        element
    | _, _, LuxText(newKey) {old.key == ""} => // We use LuxText("") as "no vnode"
        internalText(newKey)
    | _, _, _ => 
        oldNode
}

internalPatchProps(element: LuxNode, oldProps: StringMap[JsValue], newProps: StringMap[JsValue]) {
    newProps.each {name, value =>
        oldProps.get(name).{
            | None => element.setProp(name)
            | Some(oldValue) {!same(value, oldValue)} => element.setProp(name, value)
            | _ =>
        }
    }
    oldProps.each {name, _ =>
        if(!newProps.has(name)) {
            element.clearProp(name)
        }
    }
}

internalPatchChildren(element: LuxNode, oldChildren: Stack[Lux], newChildren: Stack[Lux]) {
    mutable oldStart = 0
    mutable newStart = 0
    mutable oldStop = oldChildren.size() - 1
    mutable newStop = newChildren.size() - 1
    let stop = oldStop.min(newStop)
    // Skip reference equal nodes from both ends
    while(oldStart < stop && same(oldChildren.grab(oldStart), newChildren.grab(newStart))) {
        oldStart += 1
        newStart += 1
    }
    while(oldStop > oldStart && newStop > newStart && same(oldChildren.grab(oldStop), newChildren.grab(newStop))) {
        oldStop -= 1
        newStop -= 1
    }
    if(oldStart != oldStop || newStart != newStop):
    // If we're not yet done, patch key equal nodes from both ends
    while(oldStart < stop && oldChildren.grab(oldStart).key == newChildren.grab(newStart).key) {
        internalPatch(element.childNodeAt(oldStart), oldChildren.grab(oldStart), newChildren.grab(newStart))
        oldStart += 1
        newStart += 1
    }
    while(oldStop > oldStart && newStop > newStart && oldChildren.grab(oldStop).key == newChildren.grab(newStop).key) {
        internalPatch(element.nodeAt(oldStop), oldChildren.grab(oldStop), newChildren.grab(newStop))
        oldStop -= 1
        newStop -= 1
    }
    // If we only need to delete nodes or only need to add nodes, do that
    if(newStart == newStop) {
        while {oldStart < oldStop} {
            internalUnmount(oldChildren.grab(oldStop))
            element.deleteNodeAt(oldStop)
            oldStop -= 1
        }
    } elseIf {oldStart == oldStop} {
        while {newStart < newStop} {
            let childElement = internalPatch(internalNull(), LuxText(""), newChildren.grab(newStart))
            element.insertNodeAt(newStart, childElement)
            newStart += 1
        }
    } else:
    // Otherwise, build an index multimap to and do out-of-order patching
    let multiMap = StringMap.make()
    while {oldStart < oldStop} {
        multiMap.getOrSet(oldChildren.grab(oldStop).key) {Stack.make()}.push(oldStop)
        oldStop -= 1
    }
    while(newStart < newStop) {
        
        newStart += 1
    }
    multiMap.each {_, indexes => 
        indexes.each {index =>
            internalUnmount(oldChildren.grab(index))
            element.deleteNodeAt(newStop)
        }
    }
}

internalUnmount(lux: Lux) {
    | LuxHook(_, _, _, _, umount) => umount()
    | LuxTag(_, _, children) => children.each {internalUnmount(_)}
    | LuxText(_) => 
}
