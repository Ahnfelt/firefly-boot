import Lux2 as Lux
import LuxEvent

capability Lux(mutable internalKey: String) {
    LuxText()
    LuxTag(props: StringMap[JsValue], children: Stack[Lux])
    LuxHook(valueBox: Box[Any], childBox: Box[Lux], frameBox: Box[Int], update: LuxNode => LuxNode, umount: () => Unit)
}

new(tagName: String, text: String = ""): Lux {
    LuxTag("<" + tagName + ">", StringMap.make(), if(text != "") {[LuxText("'" + text)].toStack()} else {[].toStack()})
}

useState[T: HasAnyTag](initial: T, body: (T, T => Unit) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    let valueBox = Box(Any.toAny(initial))
    let childBox = Box(LuxText(""))
    let frameBox = Box(0)
    let key = "$S$" + location.location + "$" + Any.anyTag[T]().show()
    let update = {node =>
        if(frameBox.value != 0) {internalCancelAnimationFrame(frameBox.value)}
        mutable currentNode = node
        mutable setValue = {_ => }
        function render(): LuxNode {
            let value = Any.fromAny[T](valueBox.value).grab()
            let newChild = body(value, setValue)
            currentNode = internalPatch(currentNode, childBox.value, newChild)
            childBox.value = newChild
            currentNode
        }
        setValue = {newValue => 
            valueBox.value = Any.toAny(newValue)
            if(frameBox.value != 0) {internalCancelAnimationFrame(frameBox.value)}
            frameBox.value = internalRequestAnimationFrame {render()}
        }
        render()
    }
    let unmount = {internalUnmount(childBox.value)}
    LuxHook(key, valueBox, childBox, frameBox, update, unmount)
}

internalUseMemo[I: Equal: HasAnyTag, O: HasAnyTag](input: I, compute: I => O, body: O => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    let valueBox = Box(Any.toAny[Pair[I, Option[O]]](Pair(input, None)))
    let childBox = Box(LuxText(""))
    let key = "$M$" + location.location + "$" + Any.anyTag[Pair[I, Option[O]]]().show()
    let update = {node =>
        let pair = Any.fromAny[Pair[I, Option[O]]](valueBox.value).grab()
        let value = if(pair.second.isEmpty() || pair.first != input) {compute(input)} else {pair.second.grab()}
        valueBox.value = Any.toAny[Pair[I, Option[O]]](Pair(input, Some(value)))
        let newChild = body(value)
        let currentNode = internalPatch(node, childBox.value, newChild)
        childBox.value = newChild
        currentNode
    }
    let unmount = {internalUnmount(childBox.value)}
    LuxHook(key, valueBox, childBox, Box(0), update, unmount)
}

useMemo0[O: HasAnyTag](compute: () => O, body: O => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    internalUseMemo(Unit, {_ => compute()}, body, location)
}

useMemo1[A1: Equal: HasAnyTag, O: HasAnyTag](a1: A1, compute: A1 => O, body: O => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    internalUseMemo(a1, compute, body, location)
}

useMemo2[A1: Equal: HasAnyTag, A2: Equal: HasAnyTag, O: HasAnyTag](a1: A1, a2: A2, compute: (A1, A2) => O, body: O => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    internalUseMemo(Pair(a1, a2), {pair => compute(pair.first, pair.second)}, body, location)
}

useCallback1[A1: HasAnyTag, R: HasAnyTag](callback: A1 => R, body: (A1 => R) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    let childBox = Box(LuxText(""))
    let valueBox = Box(Any.toAny[LuxCallback1[A1, R]](LuxCallback1(
        wrapper = internalFunctionToJsValue1(callback)
        callback = internalFunctionToJsValue1(callback)
    )))
    Any.fromAny[LuxCallback1[A1, R]](valueBox.value).grab().wrapper =  internalFunctionToJsValue1 {a1 => 
        internalJsValueToFunction1(Any.fromAny[LuxCallback1[A1, R]](valueBox.value).grab().callback)(a1)
    }
    let key = "$C$" + location.location + "$" + Any.anyTag[LuxCallback1[A1, R]]().show()
    let update = {node =>
        let luxCallback = Any.fromAny[LuxCallback1[A1, R]](valueBox.value).grab()
        luxCallback.callback = internalFunctionToJsValue1(callback)
        let newChild = body(internalJsValueToFunction1(luxCallback.wrapper))
        let currentNode = internalPatch(node, childBox.value, newChild)
        childBox.value = newChild
        currentNode
    }
    let unmount = {internalUnmount(childBox.value)}
    LuxHook(key, Box(Any.toAny(Unit)), childBox, Box(0), update, unmount)
}

class LuxCallback1[A1, R](mutable wrapper: JsValue, mutable callback: JsValue)
instance LuxCallback1[A1: HasAnyTag, R: HasAnyTag]: HasAnyTag {
    anyTag(): AnyTag[LuxCallback1[A1, R]] {
        Any.internalAnyTag("LuxCallback1[" + Any.anyTag[Pair[A1, R]]().show() + "]")
    }
}

internalFunctionToJsValue1[A1, R](callback: A1 => R): JsValue
    target js async """return a1 => callback_(a1, $task)"""
    target js sync """return callback_"""

internalJsValueToFunction1[A1, R](value: JsValue): A1 => R
    target js sync """return value_"""
        
extend self: Lux {
    
    key(key: String): Lux {
        self.{
            | LuxHook lux => lux.LuxHook(internalKey = lux.internalKey + "|" + key)
            | LuxTag lux => lux.LuxTag(internalKey = lux.internalKey + "|" + key)
            | _ =>
        }
        self
    }
    
    add(lux: Lux): Lux {
        self.{
            | LuxTag(_, _, children) => children.push(lux)
            | _ => 
        }
        self
    }
    
    addList(list: List[Lux]): Lux {
        self.{
            | LuxTag(_, _, children) => list.each {children.push(_)}
            | _ => 
        }
        self
    }
    
    addArray(array: Array[Lux]): Lux {
        self.{
            | LuxTag(_, _, children) => children.pushArray(array)
            | _ => 
        }
        self
    }
    
    addText(text: String): Lux {
        self.{
            | LuxTag(_, _, children) => children.push(LuxText("'" + text))
            | _ => 
        }
        self
    }
    
    with[V: IsJsValue](name: String, value: V): Lux {
        self.{
            | LuxTag lux => lux.props.set(name, internalJsValue(value))
            | _ =>
        }
        self
    }

    on(event: String, handler: LuxEvent => Unit): Lux {
        self.{
            | LuxTag lux => lux.props.set("@" + event, internalJsHandler(handler))
            | _ =>
        }
        self
    }
    
}


data LuxNode {}

mount(element: LuxNode, lux: Lux): Unit {
    internalPatch(element, Lux.new("div"), Lux.new("div").add(lux))
}

mountById(system: BrowserSystem, id: String, lux: Lux): Unit {
    mount(internalElementById(id), lux)
}

internalRequestAnimationFrame(body: () => Unit): Int
    target js async "return requestAnimationFrame(() => body_($task))" // TODO: frame won't wait for promise
    target js sync "return requestAnimationFrame(body_)"

internalCancelAnimationFrame(handle: Int): Unit
    target js sync "return cancelAnimationFrame(handle_)"

internalJsValue[V: IsJsValue](value: V): JsValue
    target js sync "return value_"
    
internalJsHandler(handler: LuxEvent => Unit): JsValue
    target js async "return event => handler_(event, $task)"
    target js sync "return handler_"
    
internalElement(key: String): LuxNode
    target js sync """
        return document.createElement(key_.slice(1, key_.indexOf('>')))
    """

internalText(key: String): LuxNode
    target js sync """
        return document.createTextNode(key_.slice(1))
    """

internalNull(): LuxNode
    target js sync """
        return null
    """

internalElementById(id: String): LuxNode
    target js sync """
        return document.getElementById(id_)
    """

extend self: LuxNode {
    isNull(): Bool
        target js sync """
            return !self_
        """
    setProp(name: String, value: JsValue)
        target js sync """
            self_[name_] = value_
        """
    clearProp(name: String)
        target js sync """
            self_[name_] = null
        """
    addEventListener(name: String, value: JsValue)
        target js sync """
            self_.addEventListener(name_, value_)
        """
    removeEventListener(name: String, value: JsValue)
        target js sync """
            self_.removeEventListener(name_, value_)
        """
    grab(index: Int): LuxNode
        target js sync """
            return self_.childNodes[index_]
        """
    insertAt(index: Int, node: LuxNode): Unit
        target js sync """
            self_.insertBefore(node_, self_.childNodes[index_])
        """
    delete(): Unit
        target js sync """
            self_.parentElement.removeChild(self_)
        """
}

internalPatch(oldNode: LuxNode, old: Lux, new: Lux): LuxNode {
    | _, _, _ {same(old, new)} => 
        oldNode
    | _, LuxHook oldLux, LuxHook newLux =>
        newLux.valueBox.value = oldLux.valueBox.value
        newLux.childBox.value = oldLux.childBox.value
        newLux.frameBox.value = oldLux.frameBox.value
        newLux.update.{_(oldNode)} // Workaround for apparent type checker bug
    | _, _, LuxHook(_, _, _, _, update, _) =>
        update(oldNode)
    | _, LuxTag(_, oldProps, oldChildren), LuxTag(newKey, newProps, newChildren) => 
        let element = oldNode
        if(!same(oldProps, newProps)) {internalPatchProps(element, oldProps, newProps)}
        if(!same(oldChildren, newChildren)) {internalPatchChildren(element, oldChildren, newChildren)}
        element
    | _, _, LuxTag(newKey, newProps, newChildren) => 
        let element = internalElement(newKey)
        if(newProps.size() != 0) {internalPatchProps(element, StringMap.make(), newProps)}
        if(newChildren.size() != 0) {internalPatchChildren(element, [].toStack(), newChildren)}
        element
    | _, _, LuxText(newKey) {old.internalKey != newKey} =>
        internalText(newKey)
    | _, _, _ => 
        oldNode
}

internalPatchProps(element: LuxNode, oldProps: StringMap[JsValue], newProps: StringMap[JsValue]) {
    newProps.each {name, value =>
        oldProps.get(name).{
            | None => 
                if(name.startsWith("@")) {
                    element.addEventListener(name.dropFirst(), value)
                } else {
                    element.setProp(name, value)
                }
            | Some(oldValue) {!same(value, oldValue)} =>
                if(name.startsWith("@")) {
                    element.removeEventListener(name.dropFirst(), oldValue)
                    element.addEventListener(name.dropFirst(), value)
                } else {
                    element.setProp(name, value)
                }
            | _ =>
        }
    }
    oldProps.each {name, value =>
        if(!newProps.has(name)) {
            if(name.startsWith("@")) {
                element.removeEventListener(name.dropFirst(), value)
            } else {
                element.clearProp(name)
            }
        }
    }
}

internalPatchChildren(element: LuxNode, oldChildren: Stack[Lux], newChildren: Stack[Lux]) {
    mutable oldStart = 0
    mutable newStart = 0
    mutable oldStop = oldChildren.size() - 1
    mutable newStop = newChildren.size() - 1
    // If we're not yet done, patch key equal nodes from both ends
    while {
        oldStart <= oldStop && newStart <= newStop && 
        oldChildren.grab(oldStart).internalKey == newChildren.grab(newStart).internalKey
    } {
        let oldLux = oldChildren.grab(oldStart)
        let newLux = newChildren.grab(newStart)
        if(!same(oldLux, newLux)) {internalPatch(element.grab(oldStart), oldLux, newLux)}
        oldStart += 1
        newStart += 1
    }
    while {
        oldStop >= oldStart && newStop >= newStart && 
        oldChildren.grab(oldStop).internalKey == newChildren.grab(newStop).internalKey
    } {
        let oldLux = oldChildren.grab(oldStop)
        let newLux = newChildren.grab(newStop)
        if(!same(oldLux, newLux)) {internalPatch(element.grab(oldStop), oldLux, newLux)}
        oldStop -= 1
        newStop -= 1
    }
    // If it's a single swap, or we only need to delete nodes or only need to add nodes, do that
    if(newStart == newStop && oldStart == oldStop) {
        let oldLux = oldChildren.grab(oldStop)
        let newLux = newChildren.grab(newStop)
        internalUnmount(oldLux)
        element.grab(oldStop).delete()
        let childElement = internalPatch(internalNull(), LuxText(""), newLux)
        element.insertAt(newStart, childElement)
    } elseIf {newStart > newStop} {
        while {oldStart <= oldStop} {
            internalUnmount(oldChildren.grab(oldStop))
            element.grab(oldStop).delete()
            oldStop -= 1
        }
    } elseIf {oldStart > oldStop} {
        let emptyNode = LuxText("")
        while {newStart <= newStop} {
            let childElement = internalPatch(internalNull(), emptyNode, newChildren.grab(newStart))
            element.insertAt(newStart, childElement)
            newStart += 1
        }
    } else:
    // Otherwise, build an index multimap to, do out-of-order patching, and delete excess nodes
    let multiMap = StringMap.make()
    while {oldStart <= oldStop} {
        let stack = multiMap.getOrSet(oldChildren.grab(oldStop).internalKey) {Stack.make()}
        stack.push(Pair(oldChildren.grab(oldStop), element.grab(oldStop)))
        oldStop -= 1
    }
    let emptyNode = LuxText("")
    let emptyStack = Stack.make()
    while {newStart <= newStop} {
        let newLux = newChildren.grab(newStart)
        let oldPairs = multiMap.get(newLux.internalKey).else {emptyStack}
        oldPairs.pop().{
            | None =>
                let newNode = internalPatch(internalNull(), emptyNode, newLux)
                element.insertAt(newStart, newNode)
            | Some(Pair(oldLux, oldNode)) =>
                element.insertAt(newStart, oldNode)
                internalPatch(oldNode, oldLux, newLux)
        }
        newStart += 1
    }
    multiMap.each {_, pairs => 
        pairs.each {| Pair(oldLux, oldNode) =>
            internalUnmount(oldLux)
            oldNode.delete()
        }
    }
}

internalUnmount(lux: Lux) {
    | LuxHook(_, _, _, _, _, umount) => umount()
    | LuxTag(_, _, children) => children.each {internalUnmount(_)}
    | LuxText(_) => 
}

// HTML tags
a(text: String = ""): Lux {Lux.new("a", text)}
abbr(text: String = ""): Lux {Lux.new("abbr", text)}
address(text: String = ""): Lux {Lux.new("address", text)}
area(text: String = ""): Lux {Lux.new("area", text)}
article(text: String = ""): Lux {Lux.new("article", text)}
aside(text: String = ""): Lux {Lux.new("aside", text)}
audio(text: String = ""): Lux {Lux.new("audio", text)}
b(text: String = ""): Lux {Lux.new("b", text)}
base(text: String = ""): Lux {Lux.new("base", text)}
bdi(text: String = ""): Lux {Lux.new("bdi", text)}
bdo(text: String = ""): Lux {Lux.new("bdo", text)}
blockquote(text: String = ""): Lux {Lux.new("blockquote", text)}
body(text: String = ""): Lux {Lux.new("body", text)}
br(text: String = ""): Lux {Lux.new("br", text)}
button(text: String = ""): Lux {Lux.new("button", text)}
canvas(text: String = ""): Lux {Lux.new("canvas", text)}
caption(text: String = ""): Lux {Lux.new("caption", text)}
cite(text: String = ""): Lux {Lux.new("cite", text)}
code(text: String = ""): Lux {Lux.new("code", text)}
col(text: String = ""): Lux {Lux.new("col", text)}
colgroup(text: String = ""): Lux {Lux.new("colgroup", text)}
data(text: String = ""): Lux {Lux.new("data", text)}
datalist(text: String = ""): Lux {Lux.new("datalist", text)}
dd(text: String = ""): Lux {Lux.new("dd", text)}
del(text: String = ""): Lux {Lux.new("del", text)}
details(text: String = ""): Lux {Lux.new("details", text)}
dfn(text: String = ""): Lux {Lux.new("dfn", text)}
dialog(text: String = ""): Lux {Lux.new("dialog", text)}
div(text: String = ""): Lux {Lux.new("div", text)}
dl(text: String = ""): Lux {Lux.new("dl", text)}
dt(text: String = ""): Lux {Lux.new("dt", text)}
em(text: String = ""): Lux {Lux.new("em", text)}
embed(text: String = ""): Lux {Lux.new("embed", text)}
fieldset(text: String = ""): Lux {Lux.new("fieldset", text)}
figcaption(text: String = ""): Lux {Lux.new("figcaption", text)}
figure(text: String = ""): Lux {Lux.new("figure", text)}
footer(text: String = ""): Lux {Lux.new("footer", text)}
form(text: String = ""): Lux {Lux.new("form", text)}
h1(text: String = ""): Lux {Lux.new("h1", text)}
head(text: String = ""): Lux {Lux.new("head", text)}
header(text: String = ""): Lux {Lux.new("header", text)}
hgroup(text: String = ""): Lux {Lux.new("hgroup", text)}
hr(text: String = ""): Lux {Lux.new("hr", text)}
html(text: String = ""): Lux {Lux.new("html", text)}
i(text: String = ""): Lux {Lux.new("i", text)}
iframe(text: String = ""): Lux {Lux.new("iframe", text)}
img(text: String = ""): Lux {Lux.new("img", text)}
input(text: String = ""): Lux {Lux.new("input", text)}
ins(text: String = ""): Lux {Lux.new("ins", text)}
kbd(text: String = ""): Lux {Lux.new("kbd", text)}
label(text: String = ""): Lux {Lux.new("label", text)}
legend(text: String = ""): Lux {Lux.new("legend", text)}
li(text: String = ""): Lux {Lux.new("li", text)}
link(text: String = ""): Lux {Lux.new("link", text)}
main(text: String = ""): Lux {Lux.new("main", text)}
map(text: String = ""): Lux {Lux.new("map", text)}
mark(text: String = ""): Lux {Lux.new("mark", text)}
menu(text: String = ""): Lux {Lux.new("menu", text)}
meta(text: String = ""): Lux {Lux.new("meta", text)}
meter(text: String = ""): Lux {Lux.new("meter", text)}
nav(text: String = ""): Lux {Lux.new("nav", text)}
noscript(text: String = ""): Lux {Lux.new("noscript", text)}
object(text: String = ""): Lux {Lux.new("object", text)}
ol(text: String = ""): Lux {Lux.new("ol", text)}
optgroup(text: String = ""): Lux {Lux.new("optgroup", text)}
option(text: String = ""): Lux {Lux.new("option", text)}
output(text: String = ""): Lux {Lux.new("output", text)}
p(text: String = ""): Lux {Lux.new("p", text)}
picture(text: String = ""): Lux {Lux.new("picture", text)}
portal(text: String = ""): Lux {Lux.new("portal", text)}
xperimenta(text: String = ""): Lux {Lux.new("xperimenta", text)}
pre(text: String = ""): Lux {Lux.new("pre", text)}
progress(text: String = ""): Lux {Lux.new("progress", text)}
q(text: String = ""): Lux {Lux.new("q", text)}
rp(text: String = ""): Lux {Lux.new("rp", text)}
rt(text: String = ""): Lux {Lux.new("rt", text)}
ruby(text: String = ""): Lux {Lux.new("ruby", text)}
s(text: String = ""): Lux {Lux.new("s", text)}
samp(text: String = ""): Lux {Lux.new("samp", text)}
script(text: String = ""): Lux {Lux.new("script", text)}
search(text: String = ""): Lux {Lux.new("search", text)}
section(text: String = ""): Lux {Lux.new("section", text)}
select(text: String = ""): Lux {Lux.new("select", text)}
slot(text: String = ""): Lux {Lux.new("slot", text)}
small(text: String = ""): Lux {Lux.new("small", text)}
source(text: String = ""): Lux {Lux.new("source", text)}
span(text: String = ""): Lux {Lux.new("span", text)}
strong(text: String = ""): Lux {Lux.new("strong", text)}
style(text: String = ""): Lux {Lux.new("style", text)}
sub(text: String = ""): Lux {Lux.new("sub", text)}
summary(text: String = ""): Lux {Lux.new("summary", text)}
sup(text: String = ""): Lux {Lux.new("sup", text)}
table(text: String = ""): Lux {Lux.new("table", text)}
tbody(text: String = ""): Lux {Lux.new("tbody", text)}
td(text: String = ""): Lux {Lux.new("td", text)}
template(text: String = ""): Lux {Lux.new("template", text)}
textarea(text: String = ""): Lux {Lux.new("textarea", text)}
tfoot(text: String = ""): Lux {Lux.new("tfoot", text)}
th(text: String = ""): Lux {Lux.new("th", text)}
thead(text: String = ""): Lux {Lux.new("thead", text)}
time(text: String = ""): Lux {Lux.new("time", text)}
title(text: String = ""): Lux {Lux.new("title", text)}
tr(text: String = ""): Lux {Lux.new("tr", text)}
track(text: String = ""): Lux {Lux.new("track", text)}
u(text: String = ""): Lux {Lux.new("u", text)}
ul(text: String = ""): Lux {Lux.new("ul", text)}
var(text: String = ""): Lux {Lux.new("var", text)}
video(text: String = ""): Lux {Lux.new("video", text)}
wbr(text: String = ""): Lux {Lux.new("wbr", text)}
