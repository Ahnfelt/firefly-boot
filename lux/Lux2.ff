import Lux2 as Lux
import LuxEvent

capability Lux(mutable key: String) {
    LuxText()
    LuxTag(props: StringMap[JsValue], children: Stack[Lux])
    LuxHook(valueBox: Box[Any], childBox: Box[Lux], update: LuxNode => LuxNode, umount: () => Unit)
}

new(tagName: String, text: String = ""): Lux {
    LuxTag("<" + tagName + ">", StringMap.make(), if(text != "") {[LuxText("'" + text)].toStack()} else {[].toStack()})
}

useState[T: HasAnyTag](initial: T, body: (T, T => Unit) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    let valueBox = Box(Any.toAny(initial))
    let childBox = Box(LuxText(""))
    let key = "$" + location.location + "$" + Any.anyTag[T]().show() + "$"
    let update = {oldNode =>
        let oldChild = childBox.value
        mutable setValue = {_ => }
        setValue = {newValue => 
            valueBox.value = Any.toAny(newValue)
            internalRequestAnimationFrame {
                let value = Any.fromAny[T](valueBox.value).grab()
                let newChild = body(value, setValue)
                internalPatch(oldNode, oldChild, newChild)
                childBox.value = newChild
            }
        }
        let value = Any.fromAny[T](valueBox.value).grab()
        let newChild = body(value, setValue)
        let newNode = internalPatch(oldNode, oldChild, newChild)
        childBox.value = newChild
        newNode
    }
    let unmount = {internalUnmount(childBox.value)}
    LuxHook(key, valueBox, childBox, update, unmount)
}

internalRequestAnimationFrame(body: () => Unit): Unit
    target js async "requestAnimationFrame(() => body_($task))" // TODO: frame won't wait for promise
    target js sync "requestAnimationFrame(body_)"

extend self: Lux {
    
}

data LuxNode {}

internalElement(key: String): LuxNode
    target js sync """
        return document.createElement(key_.slice(1, key_.indexOf('>')))
    """

internalText(key: String): LuxNode
    target js sync """
        return document.createTextNode(key_.slice(1))
    """

extend self: LuxNode {
    isNull(): Bool
        target js sync """
            return !self_
        """
}

internalPatch(oldNode: LuxNode, old: Lux, new: Lux): LuxNode {
    | _, _, _ {same(old, new)} => 
        oldNode
    | _, LuxHook(_, oldValueBox, oldChildBox, _, _), LuxHook(_, newValueBox, newChildBox, update, _) =>
        newValueBox.value = oldValueBox.value
        newChildBox.value = oldChildBox.value
        update(oldNode)
    | _, _, LuxHook(_, _, _, update, _) =>
        update(oldNode)
    | _, LuxTag(_, oldProps, oldChildren), LuxTag(newKey, newProps, newChildren) => 
        let element = oldNode
        if(!same(oldProps, newProps)) {internalPatchProps(element, oldProps, newProps)}
        if(!same(oldChildren, newChildren)) {internalPatchChildren(element, oldChildren, newChildren)}
        element
    | _, _, LuxTag(newKey, newProps, newChildren) => 
        let element = internalElement(newKey)
        if(newProps.size() != 0) {internalPatchProps(element, StringMap.make(), newProps)}
        if(newChildren.size() != 0) {internalPatchChildren(element, [].toStack(), newChildren)}
        element
    | _, _, LuxText(newKey) {old.key == ""} => // We use LuxText("") as "no vnode"
        internalText(newKey)
    | _, _, _ => 
        oldNode
}

internalPatchProps(element: LuxNode, oldProps: StringMap[JsValue], newProps: StringMap[JsValue]) {
    
}

internalPatchChildren(element: LuxNode, oldChildren: Stack[Lux], newChildren: Stack[Lux]) {
    
}

internalUnmount(lux: Lux) {
    | LuxHook(_, _, _, _, umount) => umount()
    | LuxTag(_, _, children) => children.each {internalUnmount(_)}
    | LuxText(_) => 
}
