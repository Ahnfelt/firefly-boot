import Lux2 as Lux
import LuxEvent

capability Lux(mutable key: String) {
    LuxText()
    LuxTag(props: StringMap[JsValue], children: Stack[Lux])
    LuxHook(box: Box[Any], update: (LuxNode, Any, Bool) => LuxNode)
}

new(tagName: String, text: String = ""): Lux {
    LuxTag("<" + tagName + ">", Map.empty(), if(text == "") {[LuxText("'" + text)].toArray()} else {Array.empty()})
}

useState[T: HasAnyTag](initial: T, body: (T, T => Unit) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    let box = Box(Any.toAny(initial))
    mutable oldChild = LuxText("")
    LuxHook("$" + location.location + "$" + Any.anyTag[T]().show() + "$", box, {oldNode, unmount =>
        let value: T = Any.fromAny(box.get())
    })
}

extend self: Lux {
    
}

data LuxNode {}

internalElement(key: String): LuxNode
    target js sync """
        return document.createElement(key_.slice(1, key_.indexOf('>')))
    """

internalText(key: String): LuxNode
    target js sync """
        return document.createTextNode(key_.slice(1))
    """

extend self: LuxNode {
    isNull(): Bool
        target js sync """
            return !self_
        """
}

internalPatch(oldNode: LuxNode, old: Lux, new: Lux): LuxElement {
    | _, _, _ {same(old, new)} => 
        oldNode
    | _, LuxHook(_, oldBox, _), LuxHook(_, newBox, update) =>
        newBox.set(oldBox.get())
        update(oldNode, False)
    | _, _, LuxHook(_, newBox, update) =>
        update(oldNode, False)
    | _, LuxTag(_, oldProps, oldChildren), LuxTag(newKey, newProps, newChildren) => 
        let element = oldNode
        if(!same(oldProps, newProps)) {internalPatchProps(element, oldProps, newProps)}
        if(!same(oldChildren, newChildren)) {internalPatchChildren(element, oldChildren, newChildren)}
        element
    | _, _, LuxTag(newKey, newProps, newChildren) => 
        let element = internalElement(newKey)
        if(newProps.size() != 0) {internalPatchProps(element, StringMap.make(), newProps)}
        if(newChildren.size() != 0) {internalPatchChildren(element, [].toStack(), newChildren)}
        element
    | _, _, LuxText(newKey) {old.key == ""} => // We use LuxText("") as "no vnode"
        internalText(newKey)
    | _, _, _ => 
        oldNode
}

internalPatchProps(element: LuxNode, oldProps: StringMap[JsValue], newProps: StringMap[JsValue]) {
    
}

internalPatchChildren(element: LuxNode, oldChildren: Stack[Lux], newChildren: Stack[Lux]) {
    
}
