import Lux2 as Lux
import LuxEvent

capability Lux(
    document: LuxDocument
    hooks: Stack[LuxHook]
    mutable render: Option[() => Unit]
    mutable element: LuxElement
    mutable keys: Option[StringMap[JsValue]]
    mutable key: String
)

capability LuxHook(name: String, tag: AnyTag, location: SourceLocation)

class LuxElement(element: JsValue, mutable child: Int)

class LuxDocument(document: JsValue)

extend self: LuxElement {
    childAt(index: Int): JsValue {
        self.element.call0("childNodes").get(index)
    }
    insertBefore(newNode: JsValue, referenceNode: JsValue): JsValue {
        self.element.call2("insertBefore", newNode, referenceNode)
    }
    removeAt(index: Int): Bool {
        let node = self.childAt(index)
        let remove = !node.isNullOrUndefined()
        if(remove) {
            self.element.call1("removeChild", node)
        }
        remove
    }
}

extend self: LuxDocument {
    createTextNode(value: String): JsValue {
        self.document.call1("createTextNode", value)
    }

    createElement(tagName: String): JsValue {
        self.document.call1("createElement", tagName)
    }
}

extend self: Lux {
    
    text(value: String) {
        let oldNode = self.element.childAt(self.element.child)
        let oldValue = oldNode.get("data")
        if(oldValue.isNullOrUndefined() || oldValue.grabString() != value) {
            let node = self.document.createTextNode(value)
            self.element.insertBefore(node, oldNode)
        }
        self.element.child += 1
    }
    
    new(tagName: String, body: () => Unit = {}) {
        let newKey = if(self.key != "") {tagName.upper() + ">" + self.key} else {""}
        let oldNode = self.element.childAt(self.element.child)
        let oldKey = oldNode.get("luxKey")
        let match = if(newKey != "") {
            !oldKey.isNullOrUndefined() && 
            oldKey.grabString() == newKey
        } else {
            oldKey.isNullOrUndefined() && 
            !oldNode.get("tagName").isNullOrUndefined() && 
            oldNode.get("tagName").grabString() == tagName.upper()
        }
        let node = if(match) {
            oldNode
        } else {
            let newNode = if(newKey == "") {self.document.createElement(tagName)} else {
                let keys = self.keys.else {
                    let map = StringMap.make()
                    mutable i = self.element.child
                    mutable c = self.element.childAt(i)
                    while {!c.isNullOrUndefined()} {
                        let k = c.get("luxKey")
                        if(!k.isNullOrUndefined()) {map.set(k.grabString(), c)}
                        c = self.element.childAt(i)
                        i += 1
                    }
                    self.keys = Some(map)
                    map
                }
                if(keys.has(newKey)) {
                    let foundNode = keys.grab(newKey)
                    keys.remove(newKey)
                    foundNode
                } else {
                    let createdNode = self.document.createElement(tagName)
                    createdNode.set("luxKey", newKey)
                    createdNode
                }
            }
            self.element.insertBefore(newNode, oldNode)
            newNode
        }
        let oldKeys = self.keys
        let oldElement = self.element
        self.element = LuxElement(node, 0)
        self.key = ""
        try {
            body()
        } finally {
            doWhile {self.element.removeAt(self.element.child)}
            self.keys = oldKeys
            self.element = oldElement
            self.element.child += 1
        } grab()
    }

    div(body: () => Unit = {}) {self.new("div", body)}
    label(body: () => Unit = {}) {self.new("label", body)}
    button(body: () => Unit = {}) {self.new("button", body)}
    form(body: () => Unit = {}) {self.new("form", body)}
    input(body: () => Unit = {}) {self.new("input", body)}

    keyed(key: String, body: () => Unit): Unit {
        self.key = key
        try {
            body()
        } finally {
            self.key = ""
        } grab()
    }
        
    with(property: String, value: String) {
    
    }
    
    css(property: String, value: String) {
        
    }
    
    cssColor(value: String) {self.css("color", "red")}
    
    on(event: String, handler: LuxEvent => Unit) {
        
    }

    onClick(handler: LuxEvent => Unit) {self.on("click", handler)}
    onInput(handler: LuxEvent => Unit) {self.on("input", handler)}
        
    useState[T: HasAnyTag](initialValue: T, body: (T, T => Unit) => Unit, location: SourceLocation = SourceLocation.callSite()) {
        //let hook = UseState(initialValue, body, location)
        //self.hooks.push(Any.toAny(hook))
    }

    useMemo1[A1, T](a1: A1, compute: A1 => T, body: T => Unit = {_ => }) {
        
    }
    
    useSuspense(suspense: () => Unit, body: () => Unit) {
        
    }

}

render(element: JsValue, body: Lux => Unit) {
    mutable document = element
    while {!document.get("parentNode").isNullOrUndefined()} {
        document = document.get("parentNode")
    }
    let lux = Lux(
        document = LuxDocument(document)
        hooks = Stack.make()
        render = None
        element = LuxElement(element, 0)
        keys = None
        key = ""
    )
    body(lux)
}

renderById(browserSystem: BrowserSystem, id: String, body: Lux => Unit) {
    let element = browserSystem.js().global().get("document").call1("getElementById", id)
    render(element, body)
}

buttonWithLabel(lux: Lux) {
    lux.useState(0): count, setCount =>
    lux.div {
        lux.label {
            lux.css("color", "red")
            lux.text("Click this:")
        }
        lux.button {
            lux.text("Clicked " + count + " times")
            lux.onClick {_ => setCount(count + 1)}
        }
    }
}


mainComponent(lux: Lux, http: HttpClient) {
    lux.useState([]): chat, setChat => 
    lux.useState(""): message, setMessage =>
    lux.div {
        lux.div {
            chat.each {questionComponent(lux, http, _)}
        }
        lux.form {
            lux.input {
                lux.with("autofocus", "true")
                lux.with("value", message)
                lux.on("input") {event => setMessage(event.text())}
            }
            lux.on("submit") {event => 
                event.preventDefault()
                setMessage("")
                setChat([...chat, message])
            }
        }
    }
}

questionComponent(lux: Lux, http: HttpClient, question: String) {
    lux.div {
        lux.css("margin-bottom", "10px")
        lux.div {lux.text("User: " + question)}
        lux.useMemo1(question): _ =>
        lux.useSuspense {lux.div {lux.text("Assistant typing...")}}:
        let answer = http.fetch(
            url = "/chat"
            method = "POST"
            body = Some(HttpClient.bodyText(question))
        ).readText()
        lux.div {lux.text("Assistant: " + answer)}
    }
}
