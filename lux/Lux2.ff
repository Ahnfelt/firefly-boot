import Lux2 as Lux
import LuxEvent

capability Lux(
    document: LuxDocument
    hooks: Stack[LuxHook]
    mutable render: Option[() => Unit]
    mutable element: LuxElement
)

capability LuxHook(name: String, tag: AnyTag, location: SourceLocation)

class LuxElement(element: JsValue, mutable child: Int)

class LuxDocument(document: JsValue)

extend self: LuxElement {
    childAt(index: Int): JsValue {
        self.element.call0("childNodes").get(index)
    }
    insertBefore(newNode: JsValue, referenceNode: JsValue): JsValue {
        self.element.call2("insertBefore", newNode, referenceNode)
    }
    removeAt(index: Int): Bool {
        let node = self.childAt(index)
        let remove = !node.isNullOrUndefined()
        if(remove) {
            self.element.call1("removeChild", node)
        }
        remove
    }
}

extend self: LuxDocument {
    createTextNode(value: String): JsValue {
        self.document.call1("createTextNode", value)
    }

    createElement(tagName: String): JsValue {
        self.document.call1("createElement", tagName)
    }
}

extend self: Lux {
    
    text(value: String) {
        let oldNode = self.element.childAt(self.element.child)
        let oldValue = oldNode.get("data")
        if(oldValue.isNullOrUndefined() || oldValue.grabString() != value) {
            let node = self.document.createTextNode(value)
            self.element.insertBefore(node, oldNode)
        }
        self.element.child += 1
    }
    
    new(tagName: String, body: () => Unit = {}) {
        let oldNode = self.element.childAt(self.element.child)
        let oldTagName = oldNode.get("tagName")
        let node = if(!oldTagName.isNullOrUndefined() && oldTagName.grabString() == tagName.upper()) {
            oldNode
        } else {
            let newNode = self.document.createElement(tagName)
            self.element.insertBefore(newNode, oldNode)
            newNode
        }
        let oldElement = self.element
        self.element = LuxElement(node, 0)
        try {
            body()
        } finally {
            while {self.element.removeAt(self.element.child)} {
                self.element.child += 1
            }
            self.element = oldElement
            self.element.child += 1
        } grab()
    }

    div(body: () => Unit = {}) {self.new("div", body)}
    label(body: () => Unit = {}) {self.new("label", body)}
    button(body: () => Unit = {}) {self.new("button", body)}
    form(body: () => Unit = {}) {self.new("form", body)}
    input(body: () => Unit = {}) {self.new("input", body)}

    with(property: String, value: String) {
    
    }
    
    css(property: String, value: String) {
        
    }
    
    cssColor(value: String) {self.css("color", "red")}
    
    on(event: String, handler: LuxEvent => Unit) {
        
    }

    onClick(handler: LuxEvent => Unit) {self.on("click", handler)}
    onInput(handler: LuxEvent => Unit) {self.on("input", handler)}
        
    useState[T: HasAnyTag](initialValue: T, body: (T, T => Unit) => Unit, location: SourceLocation = SourceLocation.callSite()) {
        //let hook = UseState(initialValue, body, location)
        //self.hooks.push(Any.toAny(hook))
    }

    useMemo1[A1, T](a1: A1, compute: A1 => T, body: T => Unit = {_ => }) {
        
    }
    
    useSuspense(suspense: () => Unit, body: () => Unit) {
        
    }

}

render(element: JsValue, body: Lux => Unit) {
    
}

buttonWithLabel(lux: Lux) {
    lux.useState(0): count, setCount =>
    lux.div {
        lux.label {
            lux.css("color", "red")
            lux.text("Click this:")
        }
        lux.button {
            lux.text("Clicked " + count + " times")
            lux.onClick {_ => setCount(count + 1)}
        }
    }
}


mainComponent(lux: Lux, http: HttpClient) {
    lux.useState([]): chat, setChat => 
    lux.useState(""): message, setMessage =>
    lux.div {
        lux.div {
            chat.each {questionComponent(lux, http, _)}
        }
        lux.form {
            lux.input {
                lux.with("autofocus", "true")
                lux.with("value", message)
                lux.on("input") {event => setMessage(event.text())}
            }
            lux.on("submit") {event => 
                event.preventDefault()
                setMessage("")
                setChat([...chat, message])
            }
        }
    }
}

questionComponent(lux: Lux, http: HttpClient, question: String) {
    lux.div {
        lux.css("margin-bottom", "10px")
        lux.div {lux.text("User: " + question)}
        lux.useMemo1(question): _ =>
        lux.useSuspense {lux.div {lux.text("Assistant typing...")}}:
        let answer = http.fetch(
            url = "/chat"
            method = "POST"
            body = Some(HttpClient.bodyText(question))
        ).readText()
        lux.div {lux.text("Assistant: " + answer)}
    }
}
