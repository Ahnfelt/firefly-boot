import Lux
import LuxEvent

class Lux {}

data LuxException(message: String)


new(tagName: String, text: String = ""): Lux
    target js sync """
        if(tagName_.charCodeAt(0) === 60) throw new Error('Invalid tag name: ' + tagName_)
        const children = text_ === '' ? [] : [{key: '<text>' + text_}];
        return {key: tagName_, children: children, callback: null, props: new Map()}
    """

mount(element: JsValue, lux: Lux): Lux {
    update(element, Lux.new("div"), Lux.new("div").add(lux))
    lux
}

extend self: Lux {

    key(key: String): Lux
        target js sync """
            if(self_.key.startsWith("<text>")) return self_
            self_.key = self_.key + '>' + key_
            return self_
        """
    
    with[V: IsJsValue](name: String, value: V): Lux
        target js sync """
            if(!self_.props || self_.key.startsWith("<")) return self_
            self_.props.set(name_, value_)
            return self_
        """
    
    withIf[V: IsJsValue](condition: Bool, name: String, body: () => V): Lux {
        if(condition) {self.with(name, body())} else {self}
    }
    
    style(property: String, value: String): Lux
        target js sync """
            if(!self_.props || self_.key.startsWith("<")) return self_
            self_.props.set("style", (self_.props.get("style") || '') + '; ' + property_ + ': ' + value_)
            return self_
        """
        
    styleIf(condition: Bool, property: String, value: String): Lux {
        if(condition) {self.style(property, value)} else {self}
    }
    
    class(className: String): Lux
        target js sync """
            if(!self_.props || self_.key.startsWith("<")) return self_
            self_.props.set("className", (self_.props.get("className") || '') + ' ' + className_)
            return self_
        """

    classIf(condition: Bool, className: String): Lux {
        if(condition) {self.class(className)} else {self}
    }
    
    on(event: String, body: LuxEvent => Unit): Lux
        target js async """
            if(self_.key.charCodeAt(0) === 60) return self_
            self_.props.set('$' + event_, body_)
            return self_
        """
        target js sync """
            if(self_.key.charCodeAt(0) === 60) return self_
            self_.props.set('$' + event_, body_)
            return self_
        """

    onIf(condition: Bool, event: String, body: LuxEvent => Unit): Lux {
        if(condition) {self.on(event, body)} else {self}
    }
    
    add(node: Lux): Lux
        target js sync """
            if(!self_.children) return self_
            self_.children.push(node_)
            return self_
        """

    addIf(condition: Bool, body: () => Lux): Lux {
        if(condition) {self.add(body())} else {self}
    }

    addList(nodes: List[Lux]): Lux
        target js sync """
            if(!self_.children) return self_
            let n = nodes_
            while(n.tail_) { 
                n = n.tail_
                self_.children.push(n.head_)
            }
            return self_
        """
        
    addArray(nodes: Array[Lux]): Lux
        target js sync """
            if(!self_.children) return self_
            for(let i = 0; i < nodes_.length; i++) {
                self_.children.push(nodes_[i])
            }
            return self_
        """
        
    addText(text: String): Lux
        target js sync """
            if(!self_.children) return self_
            self_.children.push({key: '<text>' + text_})
            return self_
        """

    textIf(condition: Bool, body: () => String): Lux
        target js async """
            if(!self_.children) return self_
            if(condition_) self_.children.push({key: '<text>' + await body_()})
            return self_
        """
        target js sync """
            if(!self_.children) return self_
            if(condition_) self_.children.push({key: '<text>' + body_()})
            return self_
        """

}


useState[T](initialValue: T, body: (T, T => Unit) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux
    target js sync """
        const node = {key: '<state_' + location_, children: [], callback: null, props: new Map([['value', initialValue_]])}
        node.callback = rerender => {
            if(rerender) {
                const setValue = newValue => {
                    node.props.set('value', newValue)
                    node.children[0] = body_(newValue, setValue)
                    rerender()
                }
                node.children[0] = body_(node.props.get('value'), setValue)
            }
        }
        return node
    """

useBox[T](initialValue: T, body: Box[T] => Lux, location: SourceLocation = SourceLocation.callSite()): Lux
    target js sync """
        const ref = ff_core_Box.Box(initialValue_)
        const node = {key: '<box_' + location_, children: [], callback: null, props: new Map([['value', ref]])}
        node.callback = rerender => {
            if(rerender) {
                node.children[0] = body_(node.props.get('value'))
            }
        }
        return node
    """

useReducer[T, A](initialValue: T, reducer: (T, A) => T, body: (T, A => Unit) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    useState(
        initialValue
        {state, setState =>
            useCallback1(
                {action => setState(reducer(state, action))}
                {dispatch => body(state, dispatch)}
                location
            )
        }
        location
    )
}

useCallback0[R](f: () => R, body: (() => R) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    internalUseCallback(f, body, location)
}

useCallback1[A1, R](f: (A1) => R, body: (A1 => R) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    internalUseCallback(f, body, location)
}

useCallback2[A1, A2, R](f: (A1, A2) => R, body: ((A1, A2) => R) => Lux, location: SourceLocation = SourceLocation.callSite()): Lux {
    internalUseCallback(f, body, location)
}

internalUseCallback[F, G, R](f: F, body: G, location: SourceLocation): Lux
    target js sync """
        const node = {key: '<callback_' + location_, children: [], callback: null, props: new Map([['value', {
            f: f_,
            g: (...functionArguments) => node.props.get('value').f.apply(null, functionArguments)
        }]])}
        node.callback = rerender => {
            if(rerender) {
                const value = node.props.get('value')
                value.f = f_
                node.children[0] = body_(value.g)
            }
        }
        return node
    """

useMemo0[R](compute: () => R, body: R => Lux, location: SourceLocation = SourceLocation.callSite()): Lux
    target js sync """
        const node = {key: '<memo_' + location_, children: [], callback: null, props: new Map([['value', {
            r: null,
            first: true
        }]])}
        node.callback = rerender => {
            if(rerender) {
                const value = node.props.get('value')
                if(value.first) {
                    value.first = false
                    value.r = compute_()
                }
                node.children[0] = body_(value.r)
            }
        }
        return node
    """

useMemo1[A1, R](a1: A1, compute: A1 => R, body: R => Lux, location: SourceLocation = SourceLocation.callSite()): Lux
    target js sync """
        const node = {key: '<memo_' + location_, children: [], callback: null, props: new Map([['value', {
            a1: a1_,
            r: null,
            first: true
        }]])}
        node.callback = rerender => {
            if(rerender) {
                const value = node.props.get('value')
                if(value.first || value.a1 !== a1_) {
                    value.first = false
                    value.a1 = a1_
                    value.r = compute_(a1_)
                }
                node.children[0] = body_(value.r)
            }
        }
        return node
    """

useMemo2[A1, A2, R](a1: A1, a2: A2, compute: (A1, A2) => R, body: R => Lux, location: SourceLocation = SourceLocation.callSite()): Lux
    target js sync """
        const node = {key: '<memo_' + location_, children: [], callback: null, props: new Map([['value', {
            a1: a1_,
            a2: a2_,
            r: null,
            first: true
        }]])}
        node.callback = rerender => {
            if(rerender) {
                const value = node.props.get('value')
                if(value.first || value.a1 !== a1_ || value.a2 !== a2_) {
                    value.first = false
                    value.a1 = a1_
                    value.a2 = a2_
                    value.r = compute_(a1_, a2_)
                }
                node.children[0] = body_(value.r)
            }
        }
        return node
    """

useEffect0[R](setup: () => (() => Unit), body: () => Lux, location: SourceLocation = SourceLocation.callSite()): Lux
    target js sync """
        const node = {key: '<effect_' + location_, children: [], callback: null, props: new Map([['value', {
            clean: () => {},
            first: true
        }]])}
        node.callback = rerender => {
            const value = node.props.get('value')
            value.clean()
            if(rerender) {
                if(value.first) {
                    value.first = false
                    value.clean = setup_()
                }
                node.children[0] = body_()
            }
        }
        return node
    """

useEffect1[A1, R](a1: A1, setup: A1 => (() => Unit), body: () => Lux, location: SourceLocation = SourceLocation.callSite()): Lux
    target js sync """
        const node = {key: '<effect_' + location_, children: [], callback: null, props: new Map([['value', {
            a1: a1_,
            clean: () => {},
            first: true
        }]])}
        node.callback = rerender => {
            const value = node.props.get('value')
            value.clean()
            if(rerender) {
                if(value.first || value.a1 !== a1_) {
                    value.first = false
                    value.a1 = a1_
                    value.clean = setup_(a1_)
                }
                node.children[0] = body_()
            }
        }
        return node
    """

useEffect2[A1, A2, R](a1: A1, a2: A2, setup: (A1, A2) => (() => Unit), body: () => Lux, location: SourceLocation = SourceLocation.callSite()): Lux
    target js sync """
        const node = {key: '<effect_' + location_, children: [], callback: null, props: new Map([['value', {
            a1: a1_,
            a2: a2_,
            clean: () => {},
            first: true
        }]])}
        node.callback = rerender => {
            const value = node.props.get('value')
            value.clean()
            if(rerender) {
                if(value.first || value.a1 !== a1_ || value.a2 !== a2_) {
                    value.first = false
                    value.a1 = a1_
                    value.a2 = a2_
                    value.clean = setup_(a1_, a2_)
                }
                node.children[0] = body_()
            }
        }
        return node
    """

// TODO: Hooks with the same general type but different state types can still be mixed up.
// It can be fixed by useState[T: Typeable] and then using Typeable.show[T]() as part of the key.

update(element: JsValue, old: Lux, new: Lux): Unit
    target js sync """
        const empty = {key: '', children: [], callback: null, props: new Map()}
        function update(element, oldLux, newLux) {
            if(oldLux === newLux || newLux.key.startsWith('<text')) return element
            // If it's a hook, transfer the props, invoke the callback and patch recursively
            if(typeof newLux.callback === 'function') {
                if(typeof oldLux.callback === 'function') newLux.props = oldLux.props
                let oldChild = oldLux.children[0] || empty
                const rerender = renderNow => {
                    const render = () => {
                        element = update(element, oldChild, newLux.children[0])
                        oldChild = newLux.children[0]
                    }
                    if(renderNow) render()
                    else requestAnimationFrame(render)
                }
                newLux.callback(rerender)
                rerender(true)
                return element
            }
            // Create the element if it doesn't already exist
            if(!element) {
                const tagEnd = newLux.key.indexOf('>')
                const tag = tagEnd === -1 ? newLux.key : newLux.key.slice(0, tagEnd)
                element = document.createElement(tag)
            }
            // Patch props
            if(oldLux.props !== newLux.props) {
                newLux.props.forEach((value, name) => {
                    const oldValue = oldLux.props.get(name)
                    if(oldValue !== value) {
                        if(name[0] === '$') {
                            if(oldValue !== void 0) element.removeEventListener(name.slice(1), oldValue)
                            element.addEventListener(name.slice(1), value)
                        } else element[name] = value
                    }
                    if(oldValue !== void 0) oldLux.props.delete(name)
                })
                oldLux.props.forEach((value, name) => {
                    if(name[0] === '$') element.removeEventListener(name.slice(1), value)
                    else element[name] = void 0
                })
            }
            // Speed through matching prefix
            const oldChildren = oldLux.children
            const newChildren = newLux.children
            const minLength = Math.min(oldChildren.length, newChildren.length)
            let i = 0
            while(i < minLength && oldChildren[i] === newChildren[i]) i++
            for(; i < minLength && oldChildren[i].key === newChildren[i].key; i++) {
                update(element.childNodes[i], oldChildren[i], newChildren[i])
            }
            if(i === oldChildren.length && i === newChildren.length) return element
            // If not done, do the complicated rearrange
            const indexMap = new Map()
            // First build a multimap from old keys to indexes
            for(let j = i; j < oldChildren.length; j++) {
                const child = oldChildren[j]
                const indexes = indexMap.get(child.key)
                if(indexes === void 0) {
                    indexMap.set(child.key, j)
                } else if(typeof indexes === 'number') {
                    indexMap.set(child.key, [indexes, j])
                } else {
                    indexes.push(j)
                }
            }
            // Then go through the new children, diff and patch
            for(; i < newChildren.length; i++) {
                const child = newChildren[i]
                const indexes = indexMap.get(child.key)
                if(indexes === i) {
                    // Preserve element
                    indexMap.delete(child.key)
                    if(!newChildren[i].key.startsWith('<text')) {
                        update(element.childNodes[i], oldChildren[i], newChildren[i])
                    }
                } else if(indexes === void 0) {
                    // Create and insert new element
                    if(newChildren[i].key.startsWith('<text')) {
                        const text = newChildren[i].key.slice(newChildren[i].key.indexOf('>') + 1)
                        const newNode = document.createTextNode(text);
                        element.insertBefore(newNode, element.childNodes[i] || null)
                    } else {
                        const newElement = update(null, empty, newChildren[i])
                        element.insertBefore(newElement, element.childNodes[i] || null)
                    }
                } else {
                    // Preserve and move element
                    const index = 
                        typeof indexes === 'number' ? indexes : 
                        indexes.length === 2 ? (indexMap.set(child.key, indexes[1]), indexes[0]) :
                        indexes.shift()
                    element.insertBefore(element.childNodes[index], element.childNodes[i] || null)
                    if(!newChildren[i].key.startsWith('<text')) {
                        update(element.childNodes[i], oldChildren[index], newChildren[i])
                    }
                }
            }
            // Unmount the vdom nodes that didn't survive and delete the corresponding trailing elements
            indexMap.forEach(indexes => { 
                if(typeof indexes === 'number') unmount(oldChildren[indexes])
                else for(const index of indexes) unmount(oldChildren[index])
            })
            while(i < element.childNodes.length) {
                element.removeChild(element.childNodes[i])
            }
            return element
        }
        function unmount(oldLux) {
            if(oldLux.children) for(const child of oldLux.children) unmount(child)
            if(typeof oldLux.callback === 'function') oldLux.callback(null)
        }
        if(old_.key !== new_.key) throw new Error('Tried to update mismatching keys: ' + old_.key + ' vs. ' + new_.key)
        update(element_, old_, new_)
    """

// HTML tags
a(text: String = ""): Lux {Lux.new("a", text)}
abbr(text: String = ""): Lux {Lux.new("abbr", text)}
address(text: String = ""): Lux {Lux.new("address", text)}
area(text: String = ""): Lux {Lux.new("area", text)}
article(text: String = ""): Lux {Lux.new("article", text)}
aside(text: String = ""): Lux {Lux.new("aside", text)}
audio(text: String = ""): Lux {Lux.new("audio", text)}
b(text: String = ""): Lux {Lux.new("b", text)}
base(text: String = ""): Lux {Lux.new("base", text)}
bdi(text: String = ""): Lux {Lux.new("bdi", text)}
bdo(text: String = ""): Lux {Lux.new("bdo", text)}
blockquote(text: String = ""): Lux {Lux.new("blockquote", text)}
body(text: String = ""): Lux {Lux.new("body", text)}
br(text: String = ""): Lux {Lux.new("br", text)}
button(text: String = ""): Lux {Lux.new("button", text)}
canvas(text: String = ""): Lux {Lux.new("canvas", text)}
caption(text: String = ""): Lux {Lux.new("caption", text)}
cite(text: String = ""): Lux {Lux.new("cite", text)}
code(text: String = ""): Lux {Lux.new("code", text)}
col(text: String = ""): Lux {Lux.new("col", text)}
colgroup(text: String = ""): Lux {Lux.new("colgroup", text)}
data(text: String = ""): Lux {Lux.new("data", text)}
datalist(text: String = ""): Lux {Lux.new("datalist", text)}
dd(text: String = ""): Lux {Lux.new("dd", text)}
del(text: String = ""): Lux {Lux.new("del", text)}
details(text: String = ""): Lux {Lux.new("details", text)}
dfn(text: String = ""): Lux {Lux.new("dfn", text)}
dialog(text: String = ""): Lux {Lux.new("dialog", text)}
div(text: String = ""): Lux {Lux.new("div", text)}
dl(text: String = ""): Lux {Lux.new("dl", text)}
dt(text: String = ""): Lux {Lux.new("dt", text)}
em(text: String = ""): Lux {Lux.new("em", text)}
embed(text: String = ""): Lux {Lux.new("embed", text)}
fieldset(text: String = ""): Lux {Lux.new("fieldset", text)}
figcaption(text: String = ""): Lux {Lux.new("figcaption", text)}
figure(text: String = ""): Lux {Lux.new("figure", text)}
footer(text: String = ""): Lux {Lux.new("footer", text)}
form(text: String = ""): Lux {Lux.new("form", text)}
h1(text: String = ""): Lux {Lux.new("h1", text)}
head(text: String = ""): Lux {Lux.new("head", text)}
header(text: String = ""): Lux {Lux.new("header", text)}
hgroup(text: String = ""): Lux {Lux.new("hgroup", text)}
hr(text: String = ""): Lux {Lux.new("hr", text)}
html(text: String = ""): Lux {Lux.new("html", text)}
i(text: String = ""): Lux {Lux.new("i", text)}
iframe(text: String = ""): Lux {Lux.new("iframe", text)}
img(text: String = ""): Lux {Lux.new("img", text)}
input(text: String = ""): Lux {Lux.new("input", text)}
ins(text: String = ""): Lux {Lux.new("ins", text)}
kbd(text: String = ""): Lux {Lux.new("kbd", text)}
label(text: String = ""): Lux {Lux.new("label", text)}
legend(text: String = ""): Lux {Lux.new("legend", text)}
li(text: String = ""): Lux {Lux.new("li", text)}
link(text: String = ""): Lux {Lux.new("link", text)}
main(text: String = ""): Lux {Lux.new("main", text)}
map(text: String = ""): Lux {Lux.new("map", text)}
mark(text: String = ""): Lux {Lux.new("mark", text)}
menu(text: String = ""): Lux {Lux.new("menu", text)}
meta(text: String = ""): Lux {Lux.new("meta", text)}
meter(text: String = ""): Lux {Lux.new("meter", text)}
nav(text: String = ""): Lux {Lux.new("nav", text)}
noscript(text: String = ""): Lux {Lux.new("noscript", text)}
object(text: String = ""): Lux {Lux.new("object", text)}
ol(text: String = ""): Lux {Lux.new("ol", text)}
optgroup(text: String = ""): Lux {Lux.new("optgroup", text)}
option(text: String = ""): Lux {Lux.new("option", text)}
output(text: String = ""): Lux {Lux.new("output", text)}
p(text: String = ""): Lux {Lux.new("p", text)}
picture(text: String = ""): Lux {Lux.new("picture", text)}
portal(text: String = ""): Lux {Lux.new("portal", text)}
xperimenta(text: String = ""): Lux {Lux.new("xperimenta", text)}
pre(text: String = ""): Lux {Lux.new("pre", text)}
progress(text: String = ""): Lux {Lux.new("progress", text)}
q(text: String = ""): Lux {Lux.new("q", text)}
rp(text: String = ""): Lux {Lux.new("rp", text)}
rt(text: String = ""): Lux {Lux.new("rt", text)}
ruby(text: String = ""): Lux {Lux.new("ruby", text)}
s(text: String = ""): Lux {Lux.new("s", text)}
samp(text: String = ""): Lux {Lux.new("samp", text)}
script(text: String = ""): Lux {Lux.new("script", text)}
search(text: String = ""): Lux {Lux.new("search", text)}
section(text: String = ""): Lux {Lux.new("section", text)}
select(text: String = ""): Lux {Lux.new("select", text)}
slot(text: String = ""): Lux {Lux.new("slot", text)}
small(text: String = ""): Lux {Lux.new("small", text)}
source(text: String = ""): Lux {Lux.new("source", text)}
span(text: String = ""): Lux {Lux.new("span", text)}
strong(text: String = ""): Lux {Lux.new("strong", text)}
style(text: String = ""): Lux {Lux.new("style", text)}
sub(text: String = ""): Lux {Lux.new("sub", text)}
summary(text: String = ""): Lux {Lux.new("summary", text)}
sup(text: String = ""): Lux {Lux.new("sup", text)}
table(text: String = ""): Lux {Lux.new("table", text)}
tbody(text: String = ""): Lux {Lux.new("tbody", text)}
td(text: String = ""): Lux {Lux.new("td", text)}
template(text: String = ""): Lux {Lux.new("template", text)}
textarea(text: String = ""): Lux {Lux.new("textarea", text)}
tfoot(text: String = ""): Lux {Lux.new("tfoot", text)}
th(text: String = ""): Lux {Lux.new("th", text)}
thead(text: String = ""): Lux {Lux.new("thead", text)}
time(text: String = ""): Lux {Lux.new("time", text)}
title(text: String = ""): Lux {Lux.new("title", text)}
tr(text: String = ""): Lux {Lux.new("tr", text)}
track(text: String = ""): Lux {Lux.new("track", text)}
u(text: String = ""): Lux {Lux.new("u", text)}
ul(text: String = ""): Lux {Lux.new("ul", text)}
var(text: String = ""): Lux {Lux.new("var", text)}
video(text: String = ""): Lux {Lux.new("video", text)}
wbr(text: String = ""): Lux {Lux.new("wbr", text)}
