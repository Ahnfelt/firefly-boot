import LuxEvent

class Lux {}
data LuxException(message: String)

new(tagName: String): Lux
    target js sync """
        return {key: '', tag: tagName_, props: [], children: []}
    """

useState[T](initialValue: T, body: (T, T => Unit) => Lux): Lux
    target js async """
        return {key: '', hook: 'stateAsync', value: initialValue_, callback: null, body: body_}
    """
    target js sync """
        return {key: '', hook: 'stateSync', value: initialValue_, callback: null, body: body_}
    """

useEffect[T: Equal](dependency: T, update: T => (() => Unit), body: () => Lux): Lux
    target js async """
        return {key: '', hook: 'effectAsync', value: dependency_, callback: update_, body: body_}
    """
    target js sync """
        return {key: '', hook: 'effectSync', value: dependency_, callback: update_, body: body_}
    """

useMemo[T: Equal, R](dependency: T, update: T => R, body: R => Lux): Lux
    target js async """
        return {key: '', hook: 'memoAsync', value: dependency_, callback: update_, body: body_}
    """
    target js sync """
        return {key: '', hook: 'memoSync', value: dependency_, callback: update_, body: body_}
    """

unsupported() {
    throw(LuxException("Lux should not be used directly in async or non-js contexts."))
}

extend self: Lux {

    key(key: String): Lux
        target js sync """
            self_.key = key_
            return self_
        """
    
    with(name: String, value: String): Lux
        target js sync """
            if(!self_.props) return self_
            self_.props.push({name: name_, value: value_})
            return self_
        """

    withIf(name: String, condition: Bool, body: () => String): Lux
        target js async """
            if(!self_.props) return self_
            if(condition_) self_.props.push({name: name_, value: body_()})
            return self_
        """
        target js sync """
            if(!self_.props) return self_
            if(condition_) self_.props.push({name: name_, value: body_()})
            return self_
        """

    on(event: String, body: LuxEvent => Unit): Lux
        target js async """
            if(self_.hook) return self_
            self_.props.push({name: name_, value: body_})
            return self_
        """
        target js sync """
            if(self_.hook) return self_
            self_.props.push({name: name_, value: body_})
            return self_
        """

    onIf(event: String, condition: Bool, body: LuxEvent => Unit): Lux
        target js async """
            if(self_.hook) return self_
            if(condition) self_.props.push({name: name_, value: body_})
            return self_
        """
        target js sync """
            if(self_.hook) return self_
            if(condition) self_.props.push({name: name_, value: body_})
            return self_
        """

    add(node: Lux): Lux
        target js sync """
            if(!self_.children) return self_
            self_.children.push(node_)
            return self_
        """

    addIf(condition: Bool, body: () => Lux): Lux
        target js async """
            if(!self_.children) return self_
            if(condition_) self_.children.push(body_())
            return self_
        """
        target js sync """
            if(!self_.children) return self_
            if(condition_) self_.children.push(body_())
            return self_
        """

    addList(nodes: List[Lux]): Lux
        target js sync """
            if(!self_.children) return self_
            let n = nodes_
            while(n.tail_) { 
                n = n.tail_
                self_.children.push(n.head_)
            }
            return self_
        """
        
    addArray(nodes: Array[Lux]): Lux
        target js sync """
            if(!self_.children) return self_
            for(let i = 0; i < nodes_.length; i++) {
                self_.children.push(nodes_[i])
            }
            return self_
        """
        
    text(text: String): Lux
        target js sync """
            if(!self_.children) return self_
            self_.children.push(text_)
            return self_
        """

    textIf(condition: Bool, body: () => String): Lux
        target js async """
            if(!self_.children) return self_
            if(condition_) self_.children.push(body_())
            return self_
        """
        target js sync """
            if(!self_.children) return self_
            if(condition_) self_.children.push(body_())
            return self_
        """

}

update(element: JsValue, old: Lux, new: Lux): Lux
    target js sync """
        function update(element, oldLux, newLux) {
            if(oldLux === newLux) return newLux
            const children = new Map()
            for(const child of oldLux.children_) {
                if(child.key_ != '') child.set(child.key_, child)
            }
            for(const child of newLux.children_) {
                if(child.key_ != '') {
                    const old = children.get(child.key_)
                    if(old !== void 0) {
                        children.delete(child.key_)
                        update(childElement, old, child)
                    } else {
                        childElement.insertBeforeThis(...)
                    }
                } else {
                    
                }
            }
        }
        update(element_, old_, new_)
    """
