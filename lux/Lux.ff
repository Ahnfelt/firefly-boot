import Lux
import LuxEvent
import Css

capability Lux(
    document: LuxDocument
    jsSystem: JsSystem
    mutable dry: Option[Array[DryNode]]
    mutable cssClasses: StringMap[CssClass]
    mutable renderLock: Lock
    mutable task: Task
    mutable renderQueue: Array[RenderQueueItem]
    mutable element: LuxElement
    mutable depth: Int
    mutable keys: Option[StringMap[JsValue]]
    mutable key: String
    mutable attributes: Option[StringMap[String]]
    mutable texts: Array[String]
)

capability RenderQueueItem(
    luxCopy: Lux
    render: () => Unit
)

class LuxElement(element: JsValue, mutable child: Int, mutable keepChildren: Bool)

class LuxDocument(document: JsValue)

data LuxInvaldNameException(name: String)

class DryNode {
    DryElement(tagName: String, attributes: StringMap[String], children: Array[DryNode])
    DryFragment(children: Array[DryNode])
    DryText(text: String)
}

extend self: DryNode {
    toHtml(): String {
        // https://www.w3.org/TR/xml/ - wrt. checkXmmlName, we only accept the ASCII subset
        function checkXmlName(name: String): String {
            if(name.size() == 0) {throw(LuxInvaldNameException(name))}
            if(!name.grabFirst().isAsciiLetter() && !name.startsWith(":") && !name.startsWith("_")) {throw(LuxInvaldNameException(name))}
            if(!name.all {c => c.isAsciiLetterOrDigit() || c == ':' || c == '_' || c == '-' || c == '.'}) {throw(LuxInvaldNameException(name))}
            name
        }
        function escapeAttributeValue(value: String): String {
            value.replace("&", "&#x26;").replace("<", "&#x3C;").replace(">", "&#x3E;").replace("\"", "&#x22;")
        }
        function escapeText(text: String): String {
            text.replace("&", "&#x26;").replace("<", "&#x3C;").replace(">", "&#x3E;")
        }
        let voidHtmlElements = [
            "area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"
        ].toSet()
        function toHtml(node: DryNode): String {
            | DryElement(tagName, attributes, children) => 
                let attributeHtml = attributes.toList().map {| Pair(name, value) => 
                    " " + checkXmlName(name) + "=\"" + escapeAttributeValue(value) + "\""
                }.join()
                let childrenHtml = children.toList().map {toHtml(_)}.join()
                let endHtml = if(voidHtmlElements.contains(tagName)) {""} else {"</" + tagName + ">"}
                "<" + checkXmlName(tagName) + attributeHtml + ">" + childrenHtml + endHtml
            | DryFragment(children) => 
                children.toList().map {toHtml(_)}.join()
            | DryText(text) => 
                escapeText(text)
        }
        toHtml(self)
    }
}

extend self: LuxElement {
    childAt(index: Int): JsValue {
        self.element->childNodes.get(index)
    }
    insertBefore(newNode: JsValue, referenceNode: JsValue): JsValue {
        self.element->insertBefore(newNode, referenceNode)
    }
    removeAt(index: Int): Bool {
        let node = self.childAt(index)
        let remove = !node.isNullOrUndefined()
        if(remove) {
            self.element->removeChild(node)
        }
        remove
    }
}

extend self: LuxDocument {
    createTextNode(value: String): JsValue {
        self.document->createTextNode(value)
    }

    createElement(tagName: String): JsValue {
        self.document->createElement(tagName)
    }
    
    createFragment(): JsValue {
        self.document->createDocumentFragment()
    }
}

extend self: Lux {
    
    copyFrom(lux: Lux) {
        self.renderLock = lux.renderLock
        self.renderQueue = lux.renderQueue
        self.element = lux.element.LuxElement()
        self.depth = lux.depth
        self.keys = lux.keys
        self.key = lux.key
        self.attributes = lux.attributes
    }
    
    text(value: String) {
        if(value.size() != 0) {
            self.texts.push(value)
        }
    }
    
    add(tagName: String, body: () => Unit = {}) {
        patchText(self)
        self.dry.map {dry => 
            self.dry = Some([].toArray())
            let savedAttributes = self.attributes
            let savedKeys = self.keys
            self.attributes = if(self.key != "") {
                let attributes = StringMap.new()
                attributes.set("data-lux-key", tagName.upper() + ">" + self.key)
                attributes
            }
            self.key = ""
            self.depth += 1
            try {
                body()
            } finally {
                patchText(self)
                dry.push(DryElement(tagName, self.attributes.else {StringMap.new()}, self.dry.grab()))
                self.depth -= 1
                self.attributes = savedAttributes
                self.keys = savedKeys
                self.element.child += 1
                self.dry = Some(dry)
            }
        }.else:
        let node = patchElement(self, tagName)
        if(!node->luxHandlers.isNullOrUndefined()) {
            node->luxHandlers.grabArray().each {pair =>
                node->removeEventListener(pair->event, pair->handler)
            }
            node->luxHandlers = self.jsSystem.array([])
        }
        let savedAttributes = self.attributes
        let savedKeys = self.keys
        let savedElement = self.element
        self.attributes = if(self.key != "") {
            let attributes = StringMap.new()
            attributes.set("data-lux-key", tagName.upper() + ">" + self.key)
            attributes
        }
        self.element = LuxElement(node, 0, keepChildren = False)
        //self.element.element->classList->value = ""
        self.keys = None
        self.key = ""
        self.depth += 1
        try {
            body()
        } finally {
            patchText(self)
            if(!self.element.keepChildren) {
                doWhile {removeCurrentChild(self, self.depth)}
            }
            patchAttributes(self)
            self.depth -= 1
            self.attributes = savedAttributes
            self.keys = savedKeys
            self.element = savedElement
            self.element.child += 1
        }
    }

    div(body: () => Unit = {}) {self.add("div", body)}
    span(body: () => Unit = {}) {self.add("span", body)}
    label(body: () => Unit = {}) {self.add("label", body)}
    button(body: () => Unit = {}) {self.add("button", body)}
    form(body: () => Unit = {}) {self.add("form", body)}
    input(body: () => Unit = {}) {self.add("input", body)}
        
    keyed(key: String, body: () => Unit) {
        try {
            self.key = key
            body()
        } finally {
            self.key = ""
        }
    }
    
    keyedList[T](values: List[T], getKey: T => String, body: T => Unit) {
        try {
            values.each {item =>
                self.key = getKey(item)
                body(item)
            }
        } finally {
            self.key = ""
        }
    }

    set(attribute: String, value: String) {
        let attributes = self.attributes.else {
            let map = StringMap.new()
            self.attributes = Some(map)
            map
        }
        attributes.set(attribute, value)
    }
    
    setId(value: String) {self.set("id", value)}
    
    setValue(value: String) { // TODO: Not an attribute
        self.dry.map {_ => self.set("value", value)}.else:
        self.element.element->value = value
    }
    
    css(style: Css) {
        let attributes = self.attributes.else {
            let map = StringMap.new()
            self.attributes = Some(map)
            map
        }
        if(attributes.has("style")) {
            attributes.set("style", attributes.grab("style") + ";" + style.property + ":" + style.value)
        } else {
            attributes.set("style", style.property + ":" + style.value)
        }
    }
    
    cssClass(class: CssClass) {
        if(!self.cssClasses.has(class.name())) {
            self.cssClasses.set(class.name(), class)
            if(self.dry.isEmpty()):
            let styleSheet = self.document.createElement("style")
            styleSheet->textContent = class.show()
            self.document.document->head->appendChild(styleSheet)
        }
        let classNames = self.attributes.flatMap {_.get("class")}.map {_ + " "}.else {""}
        self.set("class", classNames + class.name())
    }
    
    on(event: String, handler: LuxEvent => Unit) {
        if(self.dry.isEmpty()):
        let jsHandler = Js->{jsEvent =>
            self.renderLock.do {
                handler(LuxEvent(jsEvent))
                processRenderQueue(self)!
            }
        }
        self.element.element->addEventListener(event, jsHandler)
        if(self.element.element->luxHandlers.isNullOrUndefined()) {
            self.element.element->luxHandlers = self.jsSystem.array([])
        }
        self.element.element->luxHandlers->push(
            self.jsSystem.object().with("event", event).with("handler", jsHandler)
        )
    }

    onClick(handler: LuxEvent => Unit) {self.on("click", handler)}
    onInput(handler: LuxEvent => Unit) {self.on("input", handler)}

    useHook[T](body: LuxHook[T] => Unit) {
        // if(!self.canHook) {throw(LuxHookException)}
        // self.canHook = False
        self.depth += 1
        try {
            if(self.dry.isEmpty()) {
                self.element.element.set("_lux$C" + self.depth, {}!)
            }
            body(LuxHook(self.Lux(element = self.element.LuxElement())))
        } finally {
            self.depth -= 1
        }
    }

    useState[T: HasAnyTag](initialValue: T, body: (T, T => Unit) => Unit) {
        self.useHook: hook =>
        if(hook.dry()) {body(initialValue, {_ => })} else:
        let value = if(hook.hasValue()) {hook.grabValue()} else {initialValue}
        mutable i = 0
        while {i < self.renderQueue.size()} {
            let item = self.renderQueue.grab(i)
            if(item.luxCopy.element.element.equals(self.element.element) && item.luxCopy.depth == self.depth) {
                self.renderQueue.delete(i, 1)
            } else {
                i += 1
            }
        }
        function setState(newValue: T): Unit {
            hook.setValue(newValue)
            self.renderQueue.push(RenderQueueItem(
                luxCopy = hook.luxCopy
                render = {
                    body(newValue, {setState(_)})
                }
            ))
        }
        body(value, {setState(_)})
    }

    useCallback1[A1](callback: A1 => Unit, body: (A1 => Unit) => Unit) {
        self.useHook: hook =>
        if(hook.dry()) {body(callback)} else:
        hook.setValue(callback)
        body {a1 =>
            let latestCallback = hook.grabValue()
            self.renderLock.do {
                latestCallback(a1)
                processRenderQueue(self)
            }
        }
    }

    useLazy1[A1: Equal: HasAnyTag](a1: A1, body: A1 => Unit = {_ => }) {
        self.useHook: hook =>
        if(hook.dry()) {body(a1)} else:
        if(!hook.hasValue() || hook.grabValue() != a1) {
            hook.setValue(a1)
            body(a1)
        } else {
            self.element.keepChildren = True
        }
    }

    useMemo1[A1: Equal: HasAnyTag, T: HasAnyTag](a1: A1, compute: A1 => T, body: T => Unit) {
        self.useHook: hook =>
        if(hook.dry()) {body(compute(a1))} else:
        if(hook.hasValue()) {
            let pair: Pair[A1, T] = hook.grabValue()
            if(pair.first == a1) {
                body(pair.second)
            } else {
                let value = compute(a1)
                hook.setValue(Pair(a1, value))
                body(value)
            }
        } else {
            let value = compute(a1)
            hook.setValue(Pair(a1, value))
            body(value)
        }
    }

    useSuspense(suspense: () => Unit, body: Lux => Unit) {
        self.useHook: hook =>
        if(hook.dry()) {suspense()} else:
        hook.cleanup()
        let fragment = hook.luxCopy.document.createFragment()
        let subtask = hook.luxCopy.task.spawn {task =>
            let lux = hook.luxCopy.Lux(
                task = task
                renderLock = task.lock()
                renderQueue = Array.new()
                element = hook.luxCopy.element.LuxElement(element = fragment)
            )
            try {
                body(lux)
                task.throwIfAborted()
                lux.copyFrom(hook.luxCopy)
                lux.renderLock.do {
                    replaceWithFragment(lux.element.element, fragment, lux.depth)
                }
            } catchAny {error =>
                if(error.name() != "AbortError") {
                    error.rethrow()
                }
            }
        }
        hook.setCleanup {subtask.abort()}
        suspense()
    }

    useWebSocket(
        url: String
        onMessage: Buffer => Unit
        body: (Buffer => Unit) => Unit
    ) {
        self.useHook: hook =>
        if(hook.dry()) {} else:
        self.useCallback1 {buffer => 
            onMessage(buffer)
        }: onMessage =>
        function createWebSocket(): JsValue {
            let socket = Js->WebSocket->(url)
            hook.setValue(Pair(socket, url))
            hook.setCleanup {
                socket->close()
            }
            socket->binaryType = "arraybuffer"
            Js.awaitCancellablePromise {resolve, reject, onSettle =>
                socket->onopen = Js->{resolve(Unit)}
                socket->onclose = Js->{reject(_?)}
            }
            socket->onopen = Js.null()
            socket->onclose = Js.null()
            socket->addEventListener("close", Js->{
                Log.debug("Closed")
            })
            socket->addEventListener("message", Js->{m =>
                let buffer = Js->DataView->(m->data).grabBuffer() // TODO: Handle text
                onMessage(buffer)
            })
            socket->addEventListener("error", Js->{e =>
                Log.debug("Error")
            })
            socket
        }
        let socket = if(!hook.hasValue()) {
            createWebSocket()
        } else {
            let pair = hook.grabValue()
            let oldSocket: JsValue = pair.first
            let oldUrl: String = pair.second
            if(oldUrl == url) {
                oldSocket
            } else {
                hook.cleanup()
                createWebSocket()
            }
        }
        let send: Buffer => Unit = {buffer => socket->send(buffer)}
        body(send)
    }

}

capability LuxHook[T](luxCopy: Lux)

extend self[T]: LuxHook[T] {
    dry(): Bool {
        !self.luxCopy.dry.isEmpty()
    }
    setValue(value: T) {
        self.luxCopy.element.element.set("_lux$S" + self.luxCopy.depth, value!)
    }
    hasValue(): Bool {
        self.luxCopy.element.element.hasOwn("_lux$S" + self.luxCopy.depth)
    }
    grabValue(): T {
        let value = self.luxCopy.element.element.get("_lux$S" + self.luxCopy.depth)
        if(value.isUndefined() && !self.hasValue()) {
            throw(GrabException)
        }
        value? // If value is an async function, will the effect type system see through this?
    }
    setCleanup(body: () => Unit) {
        self.luxCopy.element.element.set("_lux$C" + self.luxCopy.depth, body!)
    }
    cleanup() {
        let key = "_lux$C" + self.luxCopy.depth
        let cleanupFunction = self.luxCopy.element.element.get(key)
        self.luxCopy.element.element.set(key, {}!)
        cleanupFunction?() // Async cleanup is not waited for. Is that ok?
    }
}

cleanupElement(element: JsValue, depth: Int) {
    mutable d = depth
    doWhile {
        let cleanupFunction = element.get("_lux$C" + d)
        if(cleanupFunction.isUndefined()) {
            False
        } else {
            Js->Reflect->deleteProperty(element, "_lux$C" + d)
            Js->Reflect->deleteProperty(element, "_lux$S" + d)
            cleanupFunction?() // Async cleanup is not waited for. Is that ok?
            d += 1
            True
        }
    }
    element->children.each {child => 
        cleanupElement(child, d + 1)
    }
}

replaceWithFragment(element: JsValue, fragment: JsValue, depth: Int) {
    cleanupElement(element, depth) // Assumes that hooks have no siblings
    mutable d = depth
    doWhile {
        let cleanupFunction = fragment.get("_lux$C" + d)
        if(cleanupFunction.isUndefined()) {
            False
        } else {
            element.set("_lux$C" + d, cleanupFunction)
            if(fragment.hasOwn("_lux$S" + d)) {element.set("_lux$S" + d, fragment.get("_lux$S" + d))}
            d += 1
            True
        }
    }
    element->replaceChildren(fragment)
}

processRenderQueue(self: Lux) {
    self.renderQueue.sortBy {-_.luxCopy.depth}
    let newLux = self.Lux(element = self.element.LuxElement())
    try {
        while {!self.renderQueue.isEmpty()} {
            let item = self.renderQueue.pop().grab()
            self.copyFrom(item.luxCopy)
            item.render()
        }
    } finally {
        self.copyFrom(newLux)
    }
}

removeCurrentChild(self: Lux, depth: Int): Bool {
    let child = self.element.childAt(self.element.child)
    if(!child.isNullOrUndefined() && !child->children.isNullOrUndefined()) {
        cleanupElement(child, depth)
    }
    self.element.removeAt(self.element.child)
}

patchText(self: Lux) {
    if(!self.texts.isEmpty()):
    let value = self.texts.drain().join()
    self.dry.map {_.push(DryText(value))}.else:
    let oldNode = self.element.childAt(self.element.child)
    let oldValue = if(!oldNode.isNullOrUndefined()) {oldNode->data} else {oldNode}
    if(oldValue.isNullOrUndefined() || oldValue.grabString() != value) {
        let node = self.document.createTextNode(value)
        self.element.insertBefore(node, oldNode)
    }
    self.element.child += 1
}

patchElement(self: Lux, tagName: String): JsValue {
    let newKey = if(self.key != "") {tagName.upper() + ">" + self.key} else {""}
    let oldNode = self.element.childAt(self.element.child)
    let oldKey = if(!oldNode.isNullOrUndefined() && !oldNode->getAttribute.isNullOrUndefined()) {
        oldNode->getAttribute("data-lux-key")
    } else {oldNode}
    let match = if(newKey != "") {
        !oldKey.isNullOrUndefined() && 
        oldKey.grabString() == newKey
    } else {
        oldKey.isNullOrUndefined() && 
        !oldNode.isNullOrUndefined() &&
        !oldNode->tagName.isNullOrUndefined() && 
        oldNode->tagName.grabString() == tagName.upper()
    }
    if(match) {
        oldNode
    } else {
        let newNode = if(newKey == "") {self.document.createElement(tagName)} else {
            let keys = self.keys.else {
                let map = StringMap.new()
                mutable i = self.element.child
                mutable c = self.element.childAt(i)
                while {!c.isNullOrUndefined()} {
                    if(!c->getAttribute.isNullOrUndefined()) {
                        let k = c->getAttribute("data-lux-key")
                        if(!k.isNullOrUndefined()) {map.set(k.grabString(), c)}
                    }
                    i += 1
                    c = self.element.childAt(i)
                }
                self.keys = Some(map)
                map
            }
            if(keys.has(newKey)) {
                let foundNode = keys.grab(newKey)
                keys.remove(newKey)
                foundNode
            } else {
                let createdNode = self.document.createElement(tagName)
                createdNode->setAttribute("data-lux-key", newKey)
                createdNode
            }
        }
        self.element.insertBefore(newNode, oldNode)
        newNode
    }
}

patchAttributes(self: Lux) {
    let attributes = self.element.element->attributes
    self.attributes.{
        | None => 
            mutable i = attributes->length.grabInt() - 1
            while {i >= 0} {
                let attribute = attributes.get(i)
                self.element.element->removeAttribute(attribute->name)
                i -= 1
            }
        | Some(map) => 
            mutable i = attributes->length.grabInt() - 1
            while {i >= 0} {
                let attribute = attributes.get(i)
                if(!map.has(attribute->name.grabString())) {
                    self.element.element->removeAttribute(attribute->name)
                }
                i -= 1
            }
            map.each {name, value =>
                let oldValue = self.element.element->getAttribute(name)
                if(oldValue.isNullOrUndefined() || !oldValue.equals(value)) {
                    self.element.element->setAttribute(name, value)
                }
            }
    }    
}

render(browserSystem: BrowserSystem, element: JsValue, body: Lux => Unit) {
    mutable document = element
    while {!document->parentNode.isNullOrUndefined()} {
        document = document->parentNode
    }
    // [...document.querySelectorAll("[lux-class]")].map(x => x.getAttribute("lux-class")) 
    let staticCssClasses = StringMap.new()
    let dummyCssClass = CssClass([], [], [])
    document->querySelectorAll("[lux-class]").each {e => 
        staticCssClasses.set(e->getAttribute("lux-class").grabString(), dummyCssClass)
    }
    let lux = Lux(
        jsSystem = browserSystem.js()
        renderLock = browserSystem.mainTask().lock()
        dry = None
        cssClasses = staticCssClasses
        task = browserSystem.mainTask()
        depth = 0
        document = LuxDocument(document)
        element = LuxElement(element, 0, keepChildren = False)
        keys = None
        key = ""
        attributes = None
        texts = Array.new()
        renderQueue = Array.new()
    )
    lux.renderLock.do {
        body(lux)
        patchText(lux)
    }
}

renderById(browserSystem: BrowserSystem, id: String, body: Lux => Unit) {
    let element = browserSystem.js()->document->getElementById(id)
    render(browserSystem, element, body)
}

renderToString(nodeSystem: NodeSystem, body: Lux => Unit): Pair[String, String] {
    let children = [].toArray()
    let lux = Lux(
        jsSystem = nodeSystem.js()
        renderLock = nodeSystem.mainTask().lock()
        dry = Some(children)
        cssClasses = StringMap.new()
        task = nodeSystem.mainTask()
        depth = 0
        document = LuxDocument(nodeSystem.js().null())
        element = LuxElement(nodeSystem.js().null(), 0, keepChildren = False)
        keys = None
        key = ""
        attributes = None
        texts = Array.new()
        renderQueue = Array.new()
    )
    body(lux)
    patchText(lux)
    let styleTags = lux.cssClasses.values().map {c => 
        "<style lux-class=\"" + c.name() + "\">" + c.show() + "</style>"
    }.join()
    Pair(children.toList().map {_.toHtml()}.join(), styleTags)
}
