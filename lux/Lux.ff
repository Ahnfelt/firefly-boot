import Lux
import LuxEvent

class Lux {}
data LuxException(message: String)

new(tagName: String): Lux
    target js sync """
        if(tagName_.charCodeAt(0) === 60) throw new Error('Invalid tag name: ' + tagName_)
        return {key: tagName_, props: new Map(), children: []}
    """

useState[T](initialValue: T, body: (T, T => Unit) => Lux): Lux
    target js async """
        return {key: '<state', value: initialValue_, callback: null, body: body_}
    """
    target js sync """
        return {key: '<state', value: initialValue_, callback: null, body: body_}
    """

useEffect[T: Equal](dependency: T, update: T => (() => Unit), body: () => Lux): Lux
    target js async """
        return {key: '<effect', value: dependency_, callback: update_, body: body_}
    """
    target js sync """
        return {key: '<effect', value: dependency_, callback: update_, body: body_}
    """

useMemo[T: Equal, R](dependency: T, update: T => R, body: R => Lux): Lux
    target js async """
        return {key: '<memo', value: dependency_, callback: update_, body: body_}
    """
    target js sync """
        return {key: '<memo', value: dependency_, callback: update_, body: body_}
    """

extend self: Lux {

    key(key: String): Lux
        target js sync """
            const k = self_.key + '>'
            self_.key = k.slice(0, k.indexOf('>') + 1) + key_
            return self_
        """
    
    with[V: IsJsValue](name: String, value: V): Lux
        target js sync """
            if(!self_.props) return self_
            self_.props.set(name_, value_)
            return self_
        """

    withIf[V: IsJsValue](name: String, condition: Bool, body: () => V): Lux
        target js async """
            if(!self_.props) return self_
            if(condition_) self_.props.set(name_, await body_())
            return self_
        """
        target js sync """
            if(!self_.props) return self_
            if(condition_) self_.props.set(name_, body_())
            return self_
        """

    on(event: String, body: LuxEvent => Unit): Lux
        target js async """
            if(self_.tag.charCodeAt(0) === 60) return self_
            self_.props.push({name: '$' + event_, value: body_})
            return self_
        """
        target js sync """
            if(self_.tag.charCodeAt(0) === 60) return self_
            self_.props.push({name: '$' + event_, value: body_})
            return self_
        """

    onIf(event: String, condition: Bool, body: LuxEvent => Unit): Lux
        target js async """
            if(self_.tag.charCodeAt(0) === 60) return self_
            if(condition) self_.props.push({name: '!' + event_, value: body_})
            return self_
        """
        target js sync """
            if(self_.tag.charCodeAt(0) === 60) return self_
            if(condition) self_.props.push({name: '!' + event_, value: body_})
            return self_
        """

    add(node: Lux): Lux
        target js sync """
            if(!self_.children) return self_
            self_.children.push(node_)
            return self_
        """

    addIf(condition: Bool, body: () => Lux): Lux
        target js async """
            if(!self_.children) return self_
            if(condition_) self_.children.push(await body_())
            return self_
        """
        target js sync """
            if(!self_.children) return self_
            if(condition_) self_.children.push(body_())
            return self_
        """

    addList(nodes: List[Lux]): Lux
        target js sync """
            if(!self_.children) return self_
            let n = nodes_
            while(n.tail_) { 
                n = n.tail_
                self_.children.push(n.head_)
            }
            return self_
        """
        
    addArray(nodes: Array[Lux]): Lux
        target js sync """
            if(!self_.children) return self_
            for(let i = 0; i < nodes_.length; i++) {
                self_.children.push(nodes_[i])
            }
            return self_
        """
        
    text(text: String): Lux
        target js sync """
            if(!self_.children) return self_
            self_.children.push({key: '<text>' + text_})
            return self_
        """

    textIf(condition: Bool, body: () => String): Lux
        target js async """
            if(!self_.children) return self_
            if(condition_) self_.children.push({key: '<text>' + await body_()})
            return self_
        """
        target js sync """
            if(!self_.children) return self_
            if(condition_) self_.children.push({key: '<text>' + body_()})
            return self_
        """

}

mount(element: JsValue, lux: Lux): Lux {
    update(element, Lux.new("div"), Lux.new("div").add(lux))
}

update(element: JsValue, old: Lux, new: Lux): Lux
    target js sync """
        const empty = {key: '', props: new Map(), children: []}
        function update(element, oldLux, newLux) {
            if(oldLux === newLux) return newLux
            // Patch props
            if(oldLux.props !== newLux.props) {
                newLux.props.forEach((value, name) => {
                    const oldValue = oldLux.props.get(name)
                    if(oldValue !== value) {
                        if(name[0] === '$') element.addEventListener(name.slice(1), value)
                        else element[name] = value
                        if(oldValue !== void 0) oldLux.props.delete(name)
                    }
                })
                oldLux.props.forEach((value, name) => {
                    if(name[0] === '$') element.removeEventListener(name.slice(1), value)
                    else element[name] = void 0
                })
            }
            // Speed through matching prefix
            const oldChildren = oldLux.children
            const newChildren = newLux.children
            const minLength = Math.min(oldChildren.length, newChildren.length)
            let i = 0
            while(i < minLength && oldChildren[i] === newChildren[i]) i++
            for(; i < minLength && oldChildren[i].key === newChildren[i].key; i++) {
                update(element.childNodes[i], oldChildren[i], newChildren[i])
            }
            if(i === oldChildren.length && i === newChildren.length) return newLux
            // If not done, do the complicated rearrange
            const indexMap = new Map()
            // First build a multimap from old keys to indexes
            for(let j = i; j < oldChildren.length; j++) {
                const child = oldChildren[j]
                const indexes = indexMap.get(child.key)
                if(indexes === void 0) {
                    indexMap.set(child.key, j)
                } else if(typeof indexes === 'number') {
                    indexMap.set(child.key, [indexes, j])
                } else {
                    indexes.push(j)
                }
            }
            // Then go through the new children, diff and patch
            for(; i < newChildren.length; i++) {
                const child = newChildren[i]
                const indexes = indexMap.get(child.key)
                if(indexes === i) {
                    // Preserve element
                    indexMap.delete(child.key)
                    if(!newChildren[i].key.startsWith('<text')) {
                        update(element.childNodes[i], oldChildren[i], newChildren[i])
                    }
                } else if(indexes === void 0) {
                    // Create and insert new element
                    if(newChildren[i].key.startsWith('<text')) {
                        const text = newChildren[i].key.slice(newChildren[i].key.indexOf('>') + 1)
                        const newNode = document.createTextNode(text);
                        element.insertBefore(newNode, element.childNodes[i] || null)
                    } else {
                        const tagEnd = newChildren[i].key.indexOf('>')
                        const tag = tagEnd === -1 ? newChildren[i].key : newChildren[i].key.slice(0, tagEnd)
                        const newElement = document.createElement(tag)
                        element.insertBefore(newElement, element.childNodes[i] || null)
                        update(newElement, empty, newChildren[i])
                        if(newChildren[i].mount) newChildren[i].mount(newElement)
                    }
                } else {
                    // Preserve and move element
                    const index = 
                        typeof indexes === 'number' ? indexes : 
                        indexes.length === 2 ? (indexMap.set(child.key, indexes[1]), indexes[0]) :
                        indexes.shift()
                    element.insertBefore(element.childNodes[index], element.childNodes[i] || null)
                    if(!newChildren[i].key.startsWith('<text')) {
                        update(element.childNodes[i], oldChildren[index], newChildren[i])
                    }
                }
            }
            // Unmount the vdom nodes that didn't survive and delete the corresponding trailing elements
            indexMap.forEach(indexes => { 
                if(typeof indexes === 'number') {
                    if(oldChildren[indexes].unmount) oldChildren[indexes].unmount()
                } else {
                    for(const index of indexes) {
                        if(oldChildren[index].unmount) oldChildren[index].unmount()
                    }
                }
            })
            while(i < element.childNodes.length) {
                element.removeChild(element.childNodes[i])
            }
            return newLux
        }
        if(old_.key !== new_.key) throw new Error('Tried to update mismatching keys: ' + old_.key + ' vs. ' + new_.key)
        update(element_, old_, new_)
    """
