capability BuildSystem {}

extend self: BuildSystem {

    compileForBrowser(mainFiles: List[String]): AssetSystem {
        // TODO: Check that the mainFile is in the current package directory
        internalCompile(self, mainFiles.map {internalPath(self, _)}, "browser")
        let streams = internalListDirectory(internalPath(self, ".firefly/output/browser"))
        let mainPackagePair = internalMainPackagePair(self)
        AssetSystem(streams.toMap())
    }

    bundleForBrowser(mainFiles: List[String], minify: Bool = True, sourceMaps: Bool = False): AssetSystem {
        internalCompile(self, mainFiles.map {internalPath(self, _)}, "browser")
        let browserOutputPath = internalPath(self, ".firefly/output/browser")
        let runPaths = internalListPath(browserOutputPath).filter {_.base().endsWith(".run.mjs")}.toList()
        if(Js.globalThis()->ffDevelopMode.typeof() == "undefined") {
            let outputPath = runPaths.grabFirst().parent().grab()
            let start = self.mainTask().elapsed()
            internalBrowserCallEsBuild(self, runPaths.map {_.absolute()}, outputPath.absolute(), minify, sourceMaps)
            let bundlePaths = runPaths.flatMap {p =>
                let outputPath = p.parent().grab()
                let bundlePath = outputPath.slash(p.base().removeLast(".mjs").grab() + ".bundle.js")
                let mapPath = outputPath.slash(p.base().removeLast(".mjs").grab() + ".bundle.js.map")
                [bundlePath, mapPath]
            }
            AssetSystem(bundlePaths.map {p => 
                Pair("/" + p.relativeListTo(browserOutputPath).join("/"), {p.readStream()})
            }.toMap())
        } else {
            mutable built = Set.new()
            let lock = self.mainTask().lock()
            AssetSystem(runPaths.flatMap {p =>
                let outputPath = p.parent().grab()
                let bundlePath = outputPath.slash(p.base().removeLast(".mjs").grab() + ".bundle.js")
                let mapPath = outputPath.slash(p.base().removeLast(".mjs").grab() + ".bundle.js.map")
                let bundleAssetPath = "/" + bundlePath.relativeListTo(browserOutputPath).join("/")
                let mapAssetPath = "/" + mapPath.relativeListTo(browserOutputPath).join("/")
                function bundle() {
                    lock.do {
                        if(!built.contains(p.absolute())) {
                            internalBrowserCallEsBuild(self, [p.absolute()], outputPath.absolute(), minify, sourceMaps)
                            built = built.add(p.absolute())
                        }
                        bundlePath.readStream()
                    }
                }
                let bundleEntry = Pair(bundleAssetPath, {
                    bundle()
                    bundlePath.readStream()
                })
                let mapEntry = Pair(mapAssetPath, {
                    bundle()
                    mapPath.readStream()
                })
                [bundleEntry, mapEntry]
            }.toMap())
        }
    }

    buildMode(): Bool {
        !!self!->"buildMode_"?
    }
    
    setAssets(assetSystem: AssetSystem): Unit {
        self!->"assets_" = assetSystem!
    }

    packageAssets(): AssetSystem {
        let streams = internalListDirectory(internalPath(self, "."))
        AssetSystem(streams.toMap())
    }

    dependencyAssets(user: String, package: String): AssetSystem {
        panic("dependencyAssets not yet implemented")
    }

    arguments(): List[String] {
        self!->"array_"?
    }

    mainTask(): Task {
        self!->"task_"?
    }

    crypto(): Crypto {
        Js->crypto?
    }
        
}

internalBrowserCallEsBuild(
    self: BuildSystem
    mainJsFiles: List[String]
    outputPath: String
    minify: Bool
    sourceMap: Bool
): Unit {
    let esbuild = Js.import(internalEsbuildPath())
    Js.await(esbuild->build(Js->(
        entryPoints = mainJsFiles
        bundle = True
        minify = minify
        sourcemap = sourceMap
        platform = "browser"
        target = "es2017"
        outdir = outputPath
        outExtension = Js.object().with(".js", ".bundle.js")
    )))
}

internalNodeCallEsBuild(
    self: NodeSystem
    mainJsFile: String
    outputPath: String
    minify: Bool
): Unit {
    let esbuild = Js.import(internalEsbuildPath())
    Js.await(esbuild->build(Js->(
        entryPoints = [mainJsFile]
        bundle = True
        minify = minify
        sourcemap = True
        platform = "node"
        target = "es2017"
        external = [internalEsbuildPath(), "uws.js"]
        loader = Js.object().with(".node", "copy")
        outdir = outputPath
    )))
}

internalNodeCallEsBuildContext(
    self: NodeSystem
    mainJsFile: String
    outputPath: String
    minify: Bool
): JsValue {
    let esbuild = Js.import(internalEsbuildPath())
    Js.await(esbuild->context(Js->(
        entryPoints = [mainJsFile]
        bundle = True
        minify = minify
        sourcemap = True
        platform = "node"
        target = "es2017"
        external = [internalEsbuildPath(), "uws.js"]
        loader = Js.object().with(".node", "copy")
        outfile = outputPath
    )))    
}

internalListDirectory(path: Path): List[Pair[String, () => Stream[Buffer]]] {
    function go(currentPath: Path): Stream[Path] {
        currentPath.entries().flatMap {file =>
            if(file.isDirectory()) {
                go(file.path())
            } else {
                [file.path()].toStream()
            }
        }
    }
    go(path).map {file =>
        Pair("/" + file.relativeTo(path).replace("\\", "/"), {file.readStream()})
    }.toList()
}

internalListPath(path: Path): Stream[Path] {
    path.entries().flatMap {file =>
        if(file.isDirectory()) {
            internalListPath(file.path())
        } else {
            [file.path()].toStream()
        }
    }
}

internalPath(buildSystem: BuildSystem, absoluteOrRelative: String): Path {
    let nodePath = Js.import("path")
    Path(nodePath->resolve(absoluteOrRelative)?)
}

internalCompile(buildSystem: BuildSystem, mainFiles: List[Path], target: String): Unit {
    if(Js.globalThis()->ffDevelopMode.typeof() != "undefined") {
        Js->process->send(Js->(
            ffDevelopMode = "internalCompile"
            mainFiles = mainFiles.map {_.absolute()}
            target = target
        ))
        Js.awaitCancellablePromise {resolve, reject, cleanup =>
            Js->process->on("message", Js->{message => 
                if(message->ffDevelopMode === "internalCompile") {
                    resolve(Unit) // Handle errors?
                }
            })
        }
    } else:
    // Ported from the old FFI. It's quite fragile w.r.t. changes in code generation.
    Js.await(Js.rawIdentifier("$firefly_compiler")->"buildViaBuildSystem_$"(
        buildSystem! 
        internalPath(buildSystem, buildSystem!->"fireflyPath_"?)!
        mainFiles!
        target
        Js.undefined()
        Js.undefined()
        Js.currentTask()!
    ))
}

internalMainPackagePair(buildSystem: BuildSystem): Pair[String, String] {
    Pair(buildSystem!->"mainPackagePair_"->"group_"?, buildSystem!->"mainPackagePair_"->"name_"?)
}

internalWriteAssets(system: NodeSystem, assetSystem: AssetSystem): Unit {
    let path = system.path(".").slash(".firefly").path("output").slash("assets")
    if(path.exists()) {path.delete()}
    path.createDirectory()
    Log.debug("Writing assets to " + path.absolute())
    assetSystem.files.each {p, s =>
        Log.debug(p)
        if(!p.contains("..")) {
            let assetPath = path.slash(p)
            assetPath.parent().grab().createDirectory(createParentDirectories = True)
            assetPath.writeStream(s())
        }
    }
}

internalEsbuildPath(): String {
    panic("This call should have been eliminated by the compiler")
}
