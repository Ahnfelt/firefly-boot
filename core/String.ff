data String {}

extend self: String {

    size(): Int {
        self!->length?
    }

    grab(index: Int): Char {
        if(index < 0 || index >= self.size()) {
            throw(GrabException())
        }
        self!->charCodeAt(index)?
    }
    
    replace(needle: String, replacement: String): String {
        self!->replaceAll(needle, replacement)?
    }

    replaceFirst(needle: String, replacement: String): String {
        self!->replace(needle, replacement)?
    }

    reverse(): String {
        self!->split("")->reverse()->join("")?
    }

    repeat(count: Int): String {
        self!->repeat(count)?
    }

    trim(): String {
        self!->trim()?
    }

    trimStart(): String {
        self!->trimStart()?
    }

    trimEnd(): String {
        self!->trimEnd()?
    }

    lower(): String {
        self!->toLowerCase()?
    }

    upper(): String {
        self!->toUpperCase()?
    }

    dropWhile(p: Char => Bool): String {
        mutable i = 0
        while {i < self.size() && p(self!->charCodeAt(i)?)} {
            i += 1
        }
        self!->slice(i)?
    }

    takeWhile(p: Char => Bool): String {
        mutable i = 0
        while {i < self.size() && p(self!->charCodeAt(i)?)} {
            i += 1
        }
        self!->slice(0, i)?
    }

    slice(from: Int, until: Int): String {
        self!->slice(from, until)?
    }

    split(char: Char): List[String] {
        self!->split(Js->String->fromCharCode(char))?
    }
    
    splitFirst(char: Char): Option[Pair[String, String]] {
        let array: List[String] = self!->split(Js->String->fromCharCode(char), 2)?
        if(array.size() == 2) {
            Pair(array!.get(0)?, array!.get(1)?)
        }
    }    

    lines(): List[String] {
        self!->split(
            Js->RegExp->("[" + Js->String->fromCharCode(13)? + "]?[" + Js->String->fromCharCode(10)? + "]", "g")
        )?
    }

    dropFirst(count: Int = 1): String {
        self!->slice(count)?
    }

    dropLast(count: Int = 1): String {
        self!->slice(0, self.size() - count)?
    }
    
    getInt(): Option[Int] {
        if(self.size() > 0 && self.all {c => 48 <= c.codeUnit && c.codeUnit <= 57}) {
            Js->parseInt(self!, 10)?
        }
    }
            
    getFloat(): Option[Float] {
        // TODO return None for invalid input
        let result = Js->parseFloat(self!, 10)
        if(Js->isFinite(result)?) {result?}
    }

    grabInt(): Int {
        self.getInt().else {
            throw(GrabException())
        }
    }
        
    grabFloat(): Float {
        self.getFloat().else {
            throw(GrabException())
        }
    }

    first(): Option[Char] {
        if(self.size() > 0) {
            Char(self!->charCodeAt(0)?)
        }
    }

    last(): Option[Char] {
        if(self.size() > 0) {
            Char(self!->charCodeAt(self.size() - 1)?)
        }
    }

    grabFirst(): Char {
        self.first().else {
            throw(GrabException())
        }
    }

    grabLast(): Char {
        self.last().else {
            throw(GrabException())
        }
    }

    contains(substring: String): Bool
        target js sync "return self_.includes(substring_)"

    startsWith(prefix: String, offset: Int = 0): Bool
        target js sync "return self_.startsWith(prefix_, offset_)"

    endsWith(prefix: String): Bool
        target js sync "return self_.endsWith(prefix_)"

    removeFirst(prefix: String): Option[String] {
        if(self.startsWith(prefix)) {Some(self.dropFirst(prefix.size()))} else {None}
    }

    removeLast(suffix: String): Option[String] {
        if(self.endsWith(suffix)) {Some(self.dropLast(suffix.size()))} else {None}
    }
    
    padStart(length: Int, padding: String = " "): String
        target js sync """
            return self_.padStart(length_, padding_);
        """

    padEnd(length: Int, padding: String = " "): String
        target js sync """
            return self_.padEnd(length_, padding_);
        """

    any(body: Char => Bool): Bool
        target js sync """
            for(let i = 0; i < self_.length; i++) {
                if(body_(self_.charCodeAt(i))) return true;
            }
            return false;
        """
        target js async """
            for(let i = 0; i < self_.length; i++) {
                if(await body_(self_.charCodeAt(i), $task)) return true;
            }
            return false;
        """

    all(body: Char => Bool): Bool
        target js sync """
            for(let i = 0; i < self_.length; i++) {
                if(!body_(self_.charCodeAt(i))) return false;
            }
            return true;
        """
        target js async """
            for(let i = 0; i < self_.length; i++) {
                if(!await body_(self_.charCodeAt(i), $task)) return false;
            }
            return true;
        """

    filter(body: Char => Bool): String
        target js sync """
            const result = [];
            for(let i = 0; i < self_.length; i++) {
                if(body_(self_.charCodeAt(i))) result.push(self_.charAt(i));
            }
            return result.join("");
        """
        target js async """
            const result = [];
            for(let i = 0; i < self_.length; i++) {
                if(await body_(self_.charCodeAt(i))) result.push(self_.charAt(i));
            }
            return result.join("");
        """

    toBuffer(): Buffer
        target js sync """
            const encoded = new TextEncoder().encode(self_)
            return new DataView(encoded.buffer, encoded.byteOffset, encoded.byteLength)
        """

}
