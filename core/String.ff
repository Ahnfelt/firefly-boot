type String {}
    scala "java.lang.String"

extend self: String {

    size(): Int { panic("magic") }
        scala "self_.size"
        javascript "return self_.length"

    expect(index: Int): Char { panic("magic") }
        scala "self_(index_)"
        javascript "return self_.charCodeAt(index_)"

    replace(needle: String, replacement: String): String { panic("magic") }
        scala "self_.replaceAllLiterally(needle_, replacement_)"
        javascript "return self_.replaceAll(needle_, replacement_)"

    replaceFirst(needle: String, replacement: String): String { panic("magic") }
        scala "self_.replaceFirst(scala.util.matching.Regex.quote(needle_), replacement_)"
        javascript "return self_.replace(needle_, replacement_)"

    reverse(): String { panic("magic") }
        scala "self_.reverse"
        javascript "return [...self_].reverse().join('')"

    dropWhile(p: Char => Bool): String { panic("magic") }
        scala "self_.dropWhile(p_)"
        javascript """
            let i = 0
            for(; i < self_.length && p_(self_.codePointAt(i)); i++);
            return self_.slice(i)
        """

    takeWhile(p: Char => Bool): String { panic("magic") }
        scala "self_.takeWhile(p_)"
        javascript """
            let i = 0
            for(; i < self_.length && p_(self_.codePointAt(i)); i++);
            return self_.slice(0, i)
        """

    slice(from: Int, until: Int): String { panic("magic") }
        scala "self_.slice(from_, until_)"
        javascript "return self_.slice(from_, until_)"

    split(char: Char): Array[String] { panic("magic") }
        scala "List_toArray(self_.split(char_).toList)" // We probably do not want the Scala semantics for this in the future
        javascript "return self_.split(String.fromCharCode(char_))"

    dropFirst(count: Int = 1): String { panic("magic") }
        scala "self_.drop(count_)"
        javascript "return self_.slice(count_)"

    dropLast(count: Int = 1): String { panic("magic") }
        scala "self_.dropRight(count_)"
        javascript "return self_.slice(0, self_.length - count_)"

    expectInt(): Int { panic("magic") }
        scala "self_.toInt"
        javascript "return parseInt(self_)"

    first(): Option[Char] { panic("magic") }
        scala "self_.headOption"
        javascript """
            return self_.length > 0
                ? ff_core_Option.Some(self_.charCodeAt(0))
                : ff_core_Option.None()
        """

    last(): Option[Char] { panic("magic") }
        scala "self_.lastOption"
        javascript """
            return self_.length > 0
                ? ff_core_Option.Some(self_.charCodeAt(self_.length - 1))
                : ff_core_Option.None()
        """

    expectFirst(): Char { self.first().else { panic("expectFirst() on empty string") } }
        scala "self_.head"

    expectLast(): Char { self.last().else { panic("expectFirst() on empty string") } }
        scala "self_.last"

    contains(substring: String) : Bool { panic("magic") }
        scala "self_.contains(substring_)"
        javascript "return self_.includes(substring_)"

    startsWith(prefix: String, offset: Int = 0) : Bool { panic("magic") }
        scala """
            if(offset_ == 0) self_.startsWith(prefix_)
            else self_.regionMatches(false, offset_, prefix_, 0, prefix_.size)
        """
        javascript "return self_.startsWith(prefix_, offset_)"

    any(body: Char => Bool): Bool { panic("magic") }
        scala "self_.exists(body_)"
        javascript """
            for(let i = 0; i < self_.length; i++) {
                if(body_(self_.charCodeAt(i))) return true;
            }
            return false;
        """

    all(body: Char => Bool): Bool { panic("magic") }
        scala "self_.forall(body_)"
        javascript """
            for(let i = 0; i < self_.length; i++) {
                if(!body_(self_.charCodeAt(i))) return false;
            }
            return true;
        """

}
