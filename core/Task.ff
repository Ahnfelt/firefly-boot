capability Task {}

extend self: Task {
    // Spawns a task running body. The return value as well as the argument to body is the task handle.
    // Automatically aborts and then joins subtasks when body returns or throws an unhandled exception.
    // If body throws, the parent task is also aborted with the dueToSubtask flag set to true.
    spawn(body: Task => Unit): Task
        target js async """
            return ff_core_Task.Task_spawn(self_)
        """
        target js sync """
            ff_core_Task.Task_throwIfAborted(self_)
            const task = {controller: new AbortController(), subtasks: new Set()}
            self_.subtasks.add(task)
            task.promise = Promise.resolve(task).then(async () => {
                try {
                    await body_(task, task)
                } catch(e) {
                    await ff_core_Task.Task_abort$(self_)
                    throw e
                } finally {
                    for(const subtask of task.subtasks) subtask.controller.abort()
                    await Promise.allSettled([...task.subtasks].map(subtask => subtask.promise))
                    self_.subtasks.delete(task)
                }
            })
            return task
        """

    // If the aborted flag is set for the current task, clears it and throws TaskAbortedException.
    // You don't normally need to call this, but you might want to before doing an expensive computation.
    throwIfAborted(): Unit
        target js async """
            ff_core_Task.Task_throwIfAborted(self_)
        """
        target js sync """
            if(self_.controller.signal.aborted) {
                const signal = self_.controller.signal
                self_.controller = new AbortController()
                signal.throwIfAborted()
            }
        """

    // Sets the tasks aborted flag, which causes the ongoing/next async call to throw TaskAbortedException.
    abort(): Unit
        target js async """
            self_.controller.abort()
        """

    // Create a channel
    channel[T](capacity: Int = 0): Channel[T]
        target js async """return ff_core_Task.Task_channel(capacity_)"""
        target js sync """return {capacity: capacity_, buffer: [], readers: new Set(), writers: new Set()}"""

}

// Convenience methods
extend self: Task {

    sleep(duration: Duration): Unit {
        Channel.
            readOr(self.channel()) {_ => }.
            timeout(duration) {}
    }

    all[T](tasks: List[() => T]): List[T] {
        let successChannel = self.channel()
        let failureChannel = self.channel()
        self.spawn {t =>
            let channel = t.channel()
            try {
                tasks.pairs().each {| Pair(i, task) =>
                    t.spawn {_ =>
                        channel.write(Pair(i, task()))
                    }
                }
                let result = tasks.map {_ =>
                    channel.read()
                }.sortBy {_.first}.map {_.second}
                successChannel.write(result)
            } catchAny {error =>
                failureChannel.write(error)
                t.abort()
            } grab()
        }
        Channel.
            readOr(successChannel, {_}).
            readOr(failureChannel, {_.rethrow()}).
            wait()
    }

    race[T](tasks: List[() => T]): T {
        let successChannel = self.channel()
        let failureChannel = self.channel()
        mutable live = tasks.size()
        let started = tasks.map {task =>
            self.spawn {_ =>
                try {
                    successChannel.write(task())
                } catchAny {e =>
                    live -= 1 // Not thread safe (but OK in JS)
                    if(live == 0) {
                        failureChannel.write(e)
                    }
                } grab()
            }
        }
        try {
            Channel.
                readOr(successChannel, {_}).
                readOr(failureChannel, {_.rethrow()}).
                wait()
        } finally {
            started.each {_.abort()}
        } grab()
    }
            
}
