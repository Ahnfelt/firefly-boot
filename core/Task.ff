capability Task {}

extend self: Task {
    // Spawns a task running body. The return value as well as the argument to body is the task handle.
    // Automatically aborts and then joins subtasks when body returns or throws an unhandled exception.
    // If body throws, the parent task is also aborted with the dueToSubtask flag set to true.
    spawn(body: Task => Unit): Task
        target js async """
            ff_core_Task.Task_throwIfAborted(self_)
            const task = {controller: new AbortController(), subtasks: new Set()}
            self_.subtasks.add(task)
            task.promise = Promise.resolve(task).then(async () => {
                try {
                    await body_(task)
                } catch(e) {
                    await ff_core_TaskSystem.Task_abort$(self_)
                    throw e
                } finally {
                    for(const subtask of task.subtasks) subtask.controller.abort()
                    await Promise.allSettled([...task.subtasks].map(subtask => subtask.promise))
                    self_.subtasks.delete(task)
                }
            })
        """

    // If the aborted flag is set for the current task, clears it and throws TaskAbortedException.
    // You don't normally need to call this, but you might want to before doing an expensive computation.
    throwIfAborted(): Unit
        target js async """
            ff_core_Task.Task_throwIfAborted(self_)
        """
        target js sync """
            if(self_.controller.signal.aborted) {
                const signal = self_.controller.signal
                self_.controller = new AbortController()
                signal.throwIfAborted()
            }
        """

    // Sets the tasks aborted flag, which causes the ongoing/next async call to throw TaskAbortedException.
    abort(): Unit
        target js async """
            self_.controller.abort()
        """
}
