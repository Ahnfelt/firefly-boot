type Channel![T] {}

extend self[T]: Channel[T] {

    read(): T {
        readOr(self, {_}).wait()
    }

    write(message: T): Unit {
        writeOr(self, message, {}).wait()
    }

}


type ChannelAction![T] {}

extend self[T]: ChannelAction[T] {

    readOr[M](channel: Channel[M], body: M => T): ChannelAction[T] { panic("magic") }
        javascriptasync "return {channel: channel_, body: body_, previous: self_}"

    writeOr[M](channel: Channel[M], message: M, body: () => T): ChannelAction[T] { panic("magic") }
        javascriptasync "return {channel: channel_, body: body_, message: message_, previous: self_}"

    wait(): T {
        internalRunChannelAction(self, None)
    }

    timeout(duration: Duration, body: () => T): T {
        internalRunChannelAction(self, Some(Pair(body, Some(duration))))
    }

    immediately(body: () => T): T {
        internalRunChannelAction(self, Some(Pair(body, None)))
    }

}

readOr[M, T](channel: Channel[M], body: M => T): ChannelAction[T] { panic("magic") }
    javascriptasync "return {channel: channel_, body: body_, previous: null}"

writeOr[M, T](channel: Channel[M], message: M, body: () => T): ChannelAction[T] { panic("magic") }
    javascriptasync "return {channel: channel_, body: body_, message: message_, previous: null}"


internalRunChannelAction[T](action: ChannelAction[T], mode: Option[Pair[() => T, Option[Duration]]]): T { panic("magic") }
    javascriptasync """
        if($c.signal.aborted) throw new Error("Cancelled", {cause: $c.reasonWorkaround})
        let actions = []
        while(action_ != null) {
            actions.push(action_)
            action_ = action_.previous
        }
        actions.reverse()
        for(let action of actions) {
            if(action.hasOwnProperty("message")) {
                if(action.channel.readers.size != 0) {
                    let reader = action.channel.readers.values().next().value
                    action.channel.readers.delete(reader)
                    reader.resolve(action.message)
                    return await action.body($c)
                } else if(action.channel.buffer.length < action.channel.capacity) {
                    action.channel.buffer.push(action.message)
                    return await action.body($c)
                }
            } else {
                if(action.channel.buffer.length != 0) {
                    return await action.body(action.channel.buffer.shift(), $c)
                } else if(action.channel.writers.size != 0) {
                    let writer = action.channel.writers.values().next().value
                    action.channel.writers.delete(writer)
                    writer.resolve()
                    return await action.body(writer.message, $c)
                }
            }
        }
        if(mode_.value_ && mode_.value_.second_.value_ == null) return await mode_.value_.first_($c)
        let abort = null
        let finish = null
        let cleanups = []
        function doCleanup() {
            for(let cleanup of cleanups) cleanup()
        }
        let promise = new Promise((resolve, reject) => {
            if(mode_.value_) finish = () => {doCleanup(); resolve(() => mode_.value_.first_($c))}
            abort = () => {doCleanup(); reject(new Error("Cancelled", {cause: $c.reasonWorkaround}))}
            for(let action of actions) {
                if(action.hasOwnProperty("message")) {
                    let writer = {
                        resolve: () => {
                            doCleanup()
                            resolve(() => action.body($c))
                        },
                        message: action.message
                    }
                    cleanups.push(() => action.channel.writers.delete(writer))
                    action.channel.writers.add(writer)
                } else {
                    let reader = {
                        resolve: m => {
                            doCleanup()
                            resolve(() => action.body(m, $c))
                        }
                    }
                    cleanups.push(() => action.channel.readers.delete(reader))
                    action.channel.readers.add(reader)
                }
            }
        })
        let timeout = null
        try {
            $c.signal.addEventListener('abort', abort)
            if(finish != null) timeout = setTimeout(finish, mode_.value_.second_.value_)
            let body = await promise
            if(timeout != null) { clearTimeout(timeout); timeout = null }
            return await body()
        } finally {
            if(timeout != null) clearTimeout(timeout)
            $c.signal.removeEventListener('abort', abort)
        }
    """


