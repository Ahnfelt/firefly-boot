class Buffer {}

new(size: Int, shared: Bool = False): Buffer
    target js sync "return new DataView(shared_ ? new SharedArrayBuffer(size_) : new ArrayBuffer(size_))"

extend self: Buffer {

    /*grabBigInt64(byteOffset: Int, littleEndian: Bool = True): BigInt
        target js sync "return self_.getBigInt64(byteOffset_, littleEndian_)"*/

    /*grabBigUint64(byteOffset: Int, littleEndian: Bool = True): BigInt
        target js sync "return self_.getBigUint64(byteOffset_, littleEndian_)"*/

    grabUint64(byteOffset: Int, littleEndian: Bool = True): Int {
        let js = Js.jsSystem()
        let high = self!->getUint32(byteOffset + if(littleEndian) {4} else {0}, littleEndian)
        let low = self!->getUint32(byteOffset + if(littleEndian) {0} else {4}, littleEndian)
        let result = (high? * 0x100000000) + low?
        if(!js->Number->isSafeInteger(result)?) {
            throw(GrabException)
        }
        result
    }
    
    grabInt64(byteOffset: Int, littleEndian: Bool = True): Int {
        let js = Js.jsSystem()
        let high = self!->getInt32(byteOffset + if(littleEndian) {4} else {0}, littleEndian)
        let low = self!->getUint32(byteOffset + if(littleEndian) {0} else {4}, littleEndian)
        let result = (high? * 0x100000000) + low?
        if(!js->Number->isSafeInteger(result)?) {
            throw(GrabException()) //grabInt64 out of range (consider grabBigInt64)'
        }
        result
    }

    grabFloat32(byteOffset: Int, littleEndian: Bool = True): Float {
        self!->getFloat32(byteOffset, littleEndian)?
    }
    
    grabFloat64(byteOffset: Int, littleEndian: Bool = True): Float {
        self!->getFloat64(byteOffset, littleEndian)?
    }

    grabInt16(byteOffset: Int, littleEndian: Bool = True): Int {
        self!->getInt16(byteOffset, littleEndian)?
    }

    grabInt32(byteOffset: Int, littleEndian: Bool = True): Int {
        self!->getInt32(byteOffset, littleEndian)?
    }

    grabInt8(byteOffset: Int): Int {
        self!->getInt8(byteOffset)?
    }

    grabUint16(byteOffset: Int, littleEndian: Bool = True): Int {
        self!->getUint16(byteOffset, littleEndian)?
    }

    grabUint32(byteOffset: Int, littleEndian: Bool = True): Int {
        self!->getUint32(byteOffset, littleEndian)?
    }

    grabUint8(byteOffset: Int): Int {
        self!->getUint8(byteOffset)?
    }

    /*setBigInt64(byteOffset: Int, value: BigInt, littleEndian: Bool = False): Unit
        target js sync "self_.setBigInt64(byteOffset_, value_, littleEndian_)"*/

    /*setBigUint64(byteOffset: Int, value: BigInt, littleEndian: Bool = False): Unit
        target js sync "self_.setBigUint64(byteOffset_, value_, littleEndian_)"*/

    setUint64(byteOffset: Int, value: Int, littleEndian: Bool = True): Unit {
        self!->setUint32(byteOffset + if(littleEndian) {4} else {0}, value.bitRight(16, False).bitRight(16, False), littleEndian)
        self!->setUint32(byteOffset + if(littleEndian) {0} else {4}, value.bitAnd(0xffffffff), littleEndian)
    }
        
    setInt64(byteOffset: Int, value: Int, littleEndian: Bool = True): Unit {
        self!->setUint32(byteOffset + if(littleEndian) {4} else {0}, value.bitRight(16, True).bitRight(16, True), littleEndian)
        self!->setUint32(byteOffset + if(littleEndian) {0} else {4}, value.bitAnd(0xffffffff), littleEndian)
    }

    setFloat32(byteOffset: Int, value: Float, littleEndian: Bool = True): Unit {
        self!->setFloat32(byteOffset, value, littleEndian)
    }

    setFloat64(byteOffset: Int, value: Float, littleEndian: Bool = True): Unit {
        self!->setFloat64(byteOffset, value, littleEndian)
    }

    setInt16(byteOffset: Int, value: Int, littleEndian: Bool = True): Unit {
        self!->setInt16(byteOffset, value, littleEndian)
    }

    setInt32(byteOffset: Int, value: Int, littleEndian: Bool = True): Unit {
        self!->setInt32(byteOffset, value, littleEndian)
    }

    setInt8(byteOffset: Int, value: Int): Unit {
        self!->setInt8(byteOffset, value)
    }

    setUint16(byteOffset: Int, value: Int, littleEndian: Bool = True): Unit {
        self!->setUint16(byteOffset, value, littleEndian)
    }

    setUint32(byteOffset: Int, value: Int, littleEndian: Bool = True): Unit {
        self!->setUint32(byteOffset, value, littleEndian)
    }

    setUint8(byteOffset: Int, value: Int): Unit {
        self!->setUint8(byteOffset, value)
    }

    setAll(byteOffset: Int, buffer: Buffer): Unit {
        let js = Js.jsSystem()
        let sourceBuffer = js->Uint8Array->(buffer!->buffer, buffer!->byteOffset, buffer!->byteLength)
        let targetBuffer = js->Uint8Array->(self!->buffer, self!->byteOffset, self!->byteLength)
        targetBuffer->set(sourceBuffer, byteOffset)
    }

    size(): Int
        target js sync "return self_.byteLength"

    shared(): Bool {
        let js = Js.jsSystem()
        js->SharedArrayBuffer.typeof() != "undefined" && self!->buffer.instanceof(js->SharedArrayBuffer)
    }
        //target js sync "return typeof SharedArrayBuffer !== 'undefined' && self_.buffer instanceof SharedArrayBuffer"

    view(begin: Int, end: Int): Buffer
        target js sync "return new DataView(self_.buffer, self_.byteOffset + begin_, end_ - begin_)"

    copy(): Buffer
        target js sync "return new DataView(self_.buffer.slice(self_.byteOffset, self_.byteOffset + self_.byteLength))"

    toString(encoding: String = "utf8"): String
        target js sync """
            if(encoding_ === "utf8") {
                if(typeof TextDecoder.ffSingleton === 'undefined') TextDecoder.ffSingleton = new TextDecoder()
                return TextDecoder.ffSingleton.decode(self_)
            }
            return new TextDecoder().decode(self_)
        """

    toByteArray(): List[Int]
        target js sync "return [...new Uint8Array(self_.buffer, self_.byteOffset, self_.byteLength)]"

    toHex(): String
        target js sync """
            let hex = ''
            for (let i = 0; i < self_.byteLength; i++) {
                hex += self_.getUint8(i).toString(16).padStart(2, '0')
            }
            return hex
        """

    toBase64(): String
        target js sync """
            const view = new Uint8Array(self_.buffer, self_.byteOffset, self_.byteLength);
            return btoa(String.fromCharCode(...view));
        """

}

fromByteList(array: List[Int]): Buffer
    target js sync "return new DataView(new Uint8Array(array_).buffer)"

fromBufferList(array: List[Buffer]): Buffer
    target js sync """
        let length = 0
        for(let b of array_) length += b.byteLength
        const arrayBuffer = new ArrayBuffer(length);
        const result = new Uint8Array(arrayBuffer)
        let offset = 0
        for(let b of array_) {
            result.set(new Uint8Array(b.buffer, b.byteOffset, b.byteLength), offset)
            offset += b.byteLength
        }
        return new DataView(arrayBuffer)
    """

fromHex(hex: String): Buffer
    target js sync """
        const hexValues = hex_.match(/.{1,2}/g) || []
        const numbers = hexValues.map(value => parseInt(value, 16))
        return new DataView(new Uint8Array(numbers).buffer)
    """

fromBase64(base64: String): Buffer
    target js sync """
        const binaryString = atob(base64_)
        const dataView = new DataView(new ArrayBuffer(binaryString.length))
        dataView.setUint8(binaryString.split('').map(char => char.charCodeAt(0)))
        return dataView
    """

instance Buffer: Show {
    show(value: Buffer): String {
        """Buffer.fromHex("""" + value.toHex() + """")"""
    }
}

instance Buffer: Equal {
    equals(x: Buffer, y: Buffer): Bool {
        if(x.size() != y.size()) {False} else:
        if(x! === y!) {True} else:
        mutable i = 0
        mutable same = True
        while {i + 4 < x.size() && same} {
            same = x!->getInt32(i) === y!->getInt32(i)
            i += 4
        }
        if(!same) {False} else:
        i.until(x.size()).eachWhile {i =>
            same = x!->getUint8(i) === y!->getUint8(i)
            same
        }
        same
    }
}

instance Buffer: Order {
    compare(x: Buffer, y: Buffer): Ordering {
        if(x!.equals(y!)) {OrderingSame} else:
        let minLength = x.size().min(y.size())
        mutable ordering = OrderingSame
        0.until(minLength).eachWhile {i =>
            if(x!->getUint8(i) !== x!->getUint8(i)) {
                ordering = Ordering.fromInt((x!->getUint8(i) - y!->getUint8(i))?)
                False
            } else {
                True
            }
        }
        if(ordering == OrderingSame) {
            Ordering.fromInt(x.size() - y.size())
        } else {
            ordering
        }
    }
}
