type FetchSystem! {}
type FetchBody! {}
type FetchResponse! {}
type FetchRedirect {
    RedirectFollow
    RedirectError
    RedirectManual
}

extend self: FetchSystem {

    fetch(
        url: String
        method: String = "GET"
        headers: List[Pair[String, String]] = emptyList
        body: Option[FetchBody] = None
        redirect: FetchRedirect = RedirectFollow
        // The rest of the options are only respected by browsers - see the MDN fetch() documentation
        referrer: Option[String] = None
        integrity: Option[String] = None
        mode: Option[String] = None
        credentials: Option[String] = None
        cache: Option[String] = None
        throw: Bool = True
    ): FetchResponse { panic("magic") }
        target js async """
            const options = {headers: {}, signal: $c.signal}
            options.method = method_
            ff_core_List.List_each(headers_, pair => {options.headers[pair.key_] = pair.value_})
            if(body_.value_) options.body = body_.value_
            if(redirect_.RedirectError) options.redirect = "error"
            else if(redirect_.RedirectManual) options.redirect = "manual"
            if(referrer_.value_) options.referrer = referrer_.value_
            if(integrity_.value_) options.integrity = integrity_.value_
            if(mode_.value_) options.mode = mode_.value_
            if(credentials_.value_) options.credentials = credentials_.value_
            if(cache_.value_) options.cache = cache_.value_
            let result = await fetch(url_, options)
            if(throw_ && !result.ok) throw new Error("Unexpected HTTP status code: " + result.status)
            return result
        """

}

emptyList = [] // TODO: Why won't this type check when inlined?

bodyString(body: String): FetchBody { panic("magic") }
    target js sync "return body_"

bodyBuffer(body: Buffer): FetchBody { panic("magic") }
    target js sync "return body_"

extend self: FetchResponse {

    ok(): Bool { panic("magic") }
        target js async "return self_.ok"

    status(): Int  { panic("magic") }
        target js async "return self_.status"

    statusText(): String  { panic("magic") }
        target js async "return self_.statusText"

    header(name: String): Option[String] { panic("magic") }
        target js async """
            const header = self_.headers.get(name_)
            return header != null
                ? ff_core_Option.Some(header)
                : ff_core_Option.None()
        """

    readText(): String { panic("magic") }
        target js async "return await self_.text()"

}
