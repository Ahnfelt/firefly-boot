type TaskSystem! {}

extend self: TaskSystem {

    start[T](task: () => Unit): Unit { panic("magic") }
        javascriptasync """
            async function spawn() {
                try {
                    await Promise.resolve($c).then(task_)
                } catch(e) {
                    if(!$c.signal.aborted) {
                        $c.reasonWorkaround = e
                        $c.abort()
                    }
                } finally {
                    $c.promises.delete(promise)
                }
            }
            let promise = spawn()
            $c.promises.add(promise)
        """

    scope[T](body: () => T, shield: Bool = False): T { panic("magic") }
        javascriptasync """
            if(!shield_ && $c.signal.aborted) throw new Error("Cancelled", {cause: $c.reasonWorkaround})
            let controller = new AbortController()
            controller.promises = new Set()
            let abort = () => {
                controller.reasonWorkaround = $c.reasonWorkaround
                controller.abort()
            }
            let result = undefined
            let outcomes = []
            try {
                if(!shield_) $c.signal.addEventListener('abort', abort)
                result = await body_(controller)
            } catch(e) {
                if(!controller.signal.aborted) {
                    controller.reasonWorkaround = e
                    controller.abort()
                }
                throw e
            } finally {
                if(!shield_) $c.signal.removeEventListener('abort', abort)
                if(!controller.signal.aborted) {
                    controller.reasonWorkaround = new Error("Cancelled")
                    controller.abort()
                }
                outcomes = await Promise.allSettled(controller.promises)
            }
            for(let outcome of outcomes) if(outcome.status === "rejected") throw outcome.reason
            return result
        """

    channel[T](capacity: Int = 0): Channel[T] { panic("magic") }
        javascriptasync """return {capacity: capacity_, buffer: [], readers: new Set(), writers: new Set()}"""

    sleep(duration: Duration): Unit {
        Channel.
            readOr(self.channel()) {| _ => }.
            timeout(duration) {}
    }

    all[T](tasks: List[() => T]): List[T] {
        let channel = self.channel()
        self.scope {
            tasks.pairs().each {| Pair(i, task) =>
                self.start {
                    channel.write(Pair(i, task()))
                }
            }
            tasks.map {| _ =>
                channel.read()
            }.sortBy {_.first}.map {_.second}
        }
    }

    race[T](tasks: List[() => T]): T {
        let successChannel = self.channel()
        let failureChannel = self.channel()
        mutable live = tasks.size()
        self.scope {
            tasks.each {task =>
                self.start {
                    try {
                        successChannel.write(task())
                    } catchAny {e =>
                        live -= 1
                        if(live == 0) {
                            failureChannel.write(e)
                        }
                    }
                }
            }
            Channel.
                readOr(successChannel, {_}).
                readOr(failureChannel, throw).
                wait()
        }
    }

}
