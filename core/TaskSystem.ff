capability TaskSystem {}

extend self: TaskSystem {
    // Spawns a task running body. The return value as well as the argument to body is the task handle.
    // Automatically aborts and then joins subtasks when body returns or throws an unhandled exception.
    // If body throws, the parent task is also aborted with the dueToSubtask flag set to true.
    spawn(body: Task => Unit): Task
        target js async """
            await ff_core_TaskSystem.TaskSystem_throwIfAborted$(null, $task)
            const subtask = {controller: new AbortController(), subtasks: new Set()}
            $task.subtasks.add(subtask)
            subtask.promise = Promise.resolve(subtask).then(async () => {
                try {
                    await body_(subtask)
                } catch(e) {
                    await ff_core_TaskSystem.Task_abort$($task)
                    throw e
                } finally {
                    for(const t of subtask.subtasks) t.controller.abort()
                    await Promise.allSettled([...subtask.subtasks].map(t => t.promise))
                    $task.subtasks.delete(subtask)
                }
            })
        """

    // If the aborted flag is set for the current task, clears it and throws TaskAbortedException.
    // You don't normally need to call this, but you might want to before doing an expensive computation.
    throwIfAborted(): Unit
        target js async """
            $task.controller.throwIfAborted()
        """
}

capability Task {}

extend self: Task {
    // Sets the tasks aborted flag, which causes the ongoing/next async call to throw TaskAbortedException.
    abort(): Unit
        target js async """
            self_.controller.abort()
        """
}
