type TaskSystem! {}

type Task {}

extend self: TaskSystem {

    start[T](taskBody: () => Unit): Task { panic("magic") }
        javascriptasync """
            if($signal.aborted) throw $signal.reason
                async function spawn() {
                let controller = new AbortController()
                controller.signal.promises = new Set()
                let abort = () => controller.abort($signal.reason)
                $signal.addEventListener('abort', abort)
                let promise = Promise.resolve(controller.signal).then(body_)
                $signal.promises.add(promise)
                let outcomes = []
                try {
                    await promise
                } finally {
                    $signal.removeEventListener('abort', abort)
                    outcomes = await Promise.allSettled(controller.signal.promises)
                    $signal.promises.delete(promise)
                }
                for(let outcome of outcomes) if(outcome.status === "rejected") throw status.reason
            }
            spawn() // What difference does it make if a spawned task waits for its subtasks?
        """

    channel[T](capacity: Int = 0): Channel[T] { panic("magic") }
        javascriptasync """return {capacity: capacity_, readers: new Set(), writers: new Set()}"""

}
