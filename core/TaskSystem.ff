type TaskSystem! {}

type TaskScope! {}

extend self: TaskScope {

    spawn(task: () => Unit): Unit { panic("magic") }
        target js async """
            if(self_.closed) throw new Error("Spawn outside scope")
            async function spawn() {
                try {
                    await Promise.resolve(self_).then(controller => {
                        if(self_.signal.aborted) throw new Error("Cancelled", {cause: self_.reasonWorkaround})
                        task_(controller)
                    })
                } catch(e) {
                    if(!self_.signal.aborted) {
                        self_.reasonWorkaround = e
                        self_.abort()
                    }
                } finally {
                    self_.promises.delete(promise)
                }
            }
            let promise = spawn()
            self_.promises.add(promise)
        """

}

extend self: TaskSystem {

    scope[T](body: TaskScope => T, shield: Bool = False): T { panic("magic") }
        target js async """
            if(!shield_ && $c.signal.aborted) throw new Error("Cancelled", {cause: $c.reasonWorkaround})
            let controller = new AbortController()
            controller.closed = false
            controller.promises = new Set()
            let abort = () => {
                controller.reasonWorkaround = $c.reasonWorkaround
                controller.abort()
            }
            let result = undefined
            let outcomes = []
            try {
                if(!shield_) $c.signal.addEventListener('abort', abort)
                result = await body_(controller, controller)
            } catch(e) {
                if(!controller.signal.aborted) {
                    controller.reasonWorkaround = e
                    controller.abort()
                }
                throw e
            } finally {
                if(!shield_) $c.signal.removeEventListener('abort', abort)
                if(!controller.signal.aborted) {
                    controller.reasonWorkaround = new Error("Cancelled")
                    controller.abort()
                }
                outcomes = await Promise.allSettled(controller.promises)
                controller.closed = true
            }
            for(let outcome of outcomes) if(outcome.status === "rejected") throw outcome.reason
            return result
        """

    channel[T](capacity: Int = 0): Channel[T] { panic("magic") }
        target js async """return {capacity: capacity_, buffer: [], readers: new Set(), writers: new Set()}"""

    sleep(duration: Duration): Unit {
        Channel.
            readOr(self.channel()) {| _ => }.
            timeout(duration) {}
    }

    all[T](tasks: List[() => T]): List[T] {
        let channel = self.channel()
        self.scope { scope =>
            tasks.pairs().each {| Pair(i, task) =>
                scope.spawn {
                    channel.write(Pair(i, task()))
                }
            }
            tasks.map {| _ =>
                channel.read()
            }.sortBy {_.first}.map {_.second}
        }
    }

    race[T](tasks: List[() => T]): T {
        let successChannel = self.channel()
        let failureChannel = self.channel()
        mutable live = tasks.size()
        self.scope { scope =>
            tasks.each { task =>
                scope.spawn {
                    try {
                        successChannel.write(task())
                    } catchAny {e =>
                        live -= 1
                        if(live == 0) {
                            failureChannel.write(e)
                        }
                    }
                }
            }
            Channel.
                readOr(successChannel, {_}).
                readOr(failureChannel, throw).
                wait()
        }
    }

}
