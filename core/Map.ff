import RbMap

type Map[K, V](redBlack: RbMap[K, Option[V]]) {
    MapOf()
} scala "#sealed abstract class Map[K, +V] { val redBlack_ : ff.core.RbMap_.RbMap[K, ff.core.Option_.Option[V]] }"

empty[K, V](): Map[K, V] { MapOf(RbLeaf) }

append[K, V](self: Map[K, V], that: Map[K, V]): Map[K, V] {
    mutable result = self.redBlack
    that.redBlack.each {
        | k, Some(_)@v => result = result.add(k, v)
        | k, None =>
    }
    MapOf(result)
}

extend self[K, V]: Map[K, V] {

    add(key : K, value : V): Map[K, V] {
        MapOf(self.redBlack.add(key, Some(value)))
    }

    append(that: Map[K, V]): Map[K, V] {
        append(self, that)
    } scala "#implicit class Map_plusPlus_implicit[K, V](self_ : Map[K, V]) { def ++(that_ : Map[K, V]) : Map[K, V] = append_(self_, that_) }"


    get(key : K): Option[V] {
        self.redBlack.get(key).flatten()
    }

    remove(key : K): Map[K, V] {
        MapOf(self.redBlack.add(key, None))
    }

    pairs(): List[Pair[K, V]] {
        self.redBlack.pairs().flatMap{
            | Pair(k, Some(v)) => [Pair(k, v)]
            | Pair(k, None) => []
        }
    }

    getSize(): Int {
        self.redBlack.size()
    }

    map[K1, V1](body: Pair[K, V] => Pair[K1, V1]): Map[K1, V1] {
        let initial: Map[K1, V1] = MapOf[K1, V1](RbLeaf)
        (self.pairs().foldLeft(initial)) { tree, pair =>
            body(pair).{
                | Pair(k, v) => tree.add(k, v)
            }
        }
    }

    contains(key: K): Bool {
        !self.get(key).getEmpty()
    }

    expect(key: K): V {
        self.get(key).expect()
    }

    updateOrInsert(key: K, update: V => V, default: () => V): Map[K, V] {
        self.get(key).{
            | None => self.add(key, default())
            | Some(v) => self.add(key, update(v))
        }
    }

}

extend self[K, V]: Map[K, List[V]] {

    addToList(key : K, value : V): Map[K, List[V]] {
        self.updateOrInsert(key, {[value, ... _]}, {[value]})
    }

}