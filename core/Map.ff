import RbMap

newtype Map[K, V](redBlack: RbMap[K, Option[V]])

empty[K, V](): Map[K, V] { Map(RbLeaf) }

extend self[K, V]: Map[K, V] {

    add(key : K, value : V): Map[K, V] {
        Map(self.redBlack.add(key, Some(value)))
    }

    addAll(that: Map[K, V]) : Map[K, V] {
        mutable result = self.redBlack
        that.redBlack.each {
            | k, Some(_)@v => result = result.add(k, v)
            | k, None =>
        }
        Map(result)
    }

    get(key : K): Option[V] {
        self.redBlack.get(key).flatten()
    }

    remove(key : K): Map[K, V] {
        Map(self.redBlack.add(key, None))
    }

    pairs(): List[Pair[K, V]] {
        self.redBlack.pairs().flatMap{
            | Pair(k, Some(v)) => [Pair(k, v)]
            | Pair(k, None) => []
        }
    }

    size(): Int {
        self.redBlack.size()
    }

    map[K1, V1](body: Pair[K, V] => Pair[K1, V1]): Map[K1, V1] {
        let initial: Map[K1, V1] = Map[K1, V1](RbLeaf)
        (self.pairs().foldLeft(initial)) { tree, pair =>
            body(pair).{
                | Pair(k, v) => tree.add(k, v)
            }
        }
    }

    contains(key: K): Bool {
        !self.get(key).isEmpty()
    }

    expect(key: K): V {
        self.get(key).expect()
    }

    updateOrInsert(key: K, update: V => V, default: () => V): Map[K, V] {
        self.get(key).{
            | None => self.add(key, default())
            | Some(v) => self.add(key, update(v))
        }
    }

}

extend self[K, V]: Map[K, List[V]] {

    addToList(key : K, value : V): Map[K, List[V]] {
        self.updateOrInsert(key, {[value, ... _]}, {[value]})
    }

}
