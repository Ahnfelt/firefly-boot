import RbMap

newtype Map[K, V](redBlack: RB[K, V])

empty[K, V](): Map[K, V] { Map(E) }

extend self[K: Order, V]: Map[K, V] {

    add(key: K, value: V): Map[K, V] {
        Map(RbMap.insert(key, value, self.redBlack))
    }

    addAll(that: Map[K, V]) : Map[K, V] {
        mutable result = self.redBlack
        that.redBlack.each { k, v =>
            result = RbMap.insert(k, v, result)
        }
        Map(result)
    }

    get(key: K): Option[V] {
        self.redBlack.get(key)
    }

    remove(key: K): Map[K, V] {
        Map(RbMap.delete(key, self.redBlack))
    }

    removeAll(that: Map[K, V]) : Map[K, V] {
        mutable result = self.redBlack
        that.redBlack.each {| k, _ =>
            result = RbMap.delete(k, result)
        }
        Map(result)
    }

    pairs(): List[Pair[K, V]] {
        self.redBlack.pairs()
    }

    keys(): Set[K] {
        self.pairs().map {_.first}.toSet()
    }

    values(): List[V] {
        self.pairs().map {_.second}
    }

    size(): Int {
        self.redBlack.size()
    }

    map[K1: Order, V1](body: Pair[K, V] => Pair[K1, V1]): Map[K1, V1] {
        let initial: Map[K1, V1] = Map[K1, V1](E)
        self.pairs().foldLeft(initial) { tree, pair =>
            body(pair).{
                | Pair(k, v) => tree.add(k, v)
            }
        }
    }

    contains(key: K): Bool {
        !self.get(key).isEmpty()
    }

    expect(key: K): V {
        self.get(key).expect()
    }

    updateOrInsert(key: K, update: V => V, default: () => V): Map[K, V] {
        self.get(key).{
            | None => self.add(key, default())
            | Some(v) => self.add(key, update(v))
        }
    }

    each(body: (K, V) => Unit): Unit {
        self.redBlack.each(body)
    }

}

extend self[K: Order, V]: Map[K, List[V]] {

    addToList(key: K, value: V): Map[K, List[V]] {
        self.updateOrInsert(key, {[value, ..._]}, {[value]})
    }

}
