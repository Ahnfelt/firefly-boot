if[T](condition: Bool, body: () => T): Option[T] {}

while(condition: () => Bool, body: () => Unit): Unit {}

do(body: () => Unit): Unit {}

panic[T](message: String): T {}

try[T](body: () => T): Try[T] {}

type Try[T] {}

log: Log = 1

type Log {}

extend self: Log {
    debug[T](value: T): Unit {}
}

type Bool {
    False
    True
}

type Option[T] {
    None
    Some(value: T)
}

type Pair[A, B](first: A, second: B)

type Array[T]() // (items: T...)

type ArrayBuilder[T]() // (items: T...)

type List[T] {}

type ListBuilder[T]() // (items: T...)

listBuilderOf[T](): ListBuilder[T] {} // (items: T...)

type Map[K, V]() // (items: Pair[K, V]...)

type MapBuilder[K, V]() // (items: Pair[K, V]...)

type Set[T]() // (items: T...)

type SetBuilder[T]() // (items: T...)

type Int {}
type String {}
type Char {}
type Bool {}
type System {}
type FileSystem {}
type Unit()

extend self: Int {
    to(inclusive: Int): List[Int] { panic("Built-in") }
    until(exclusive: Int): List[Int] { panic("Built-in") }
}

extend self: String {
    getSize(): Int { panic("Built-in") }
    expect(index: Int): Char { panic("Built-in") }
    replaceFirst(needle: String, replacement: String): String { panic("Built-in") }
    slice(from: Int, until: Int): String { panic("Built-in") }
}

extend self[T]: Option[T] {
    else(body: () => T): T { panic("Built-in") }
    elseIf(condition: () => Bool, body: () => T): Option[T] { panic("Built-in") }
}

extend self[T]: List[T] {
    toArray(): Array[T] { panic("Built-in") }
    toSet(): Set[T] { panic("Built-in") }
    expect(index: Int): T { panic("Built-in") }
    modify(index: Int, body: T => T): List[T] { panic("Built-in") }
    pairs(): List[Pair[Int, T]] { panic("Built-in") }
    slice(from: Int, until: Int): List[T] { panic("Built-in") }
    getSize(): Int { panic("Built-in") }
    each(body: T => Unit): Unit { panic("Built-in") }
    all(body: T => Bool): Bool { panic("Built-in") }
    any(body: T => Bool): Bool { panic("Built-in") }
    filter(body: T => Bool): List[T] { panic("Built-in") }
    map[R](body: T => R): List[R] { panic("Built-in") }
    flatMap[R](body: T => List[R]): List[R] { panic("Built-in") }
}

extend self[T]: List[List[T]] {
    flatten(): List[T] { panic("Built-in") }
}

extend self[T]: SetBuilder[T] {
    add(value: T): Unit { panic("Built-in") }
    each(body: T => Unit): Unit { panic("Built-in") }
    all(body: T => Bool): Bool { panic("Built-in") }
    any(body: T => Bool): Bool { panic("Built-in") }
    getSize(): Int { panic("Built-in") }
}

extend self: System {
    arguments(): List[String] { panic("Built-in") }
    files(): FileSystem { panic("Built-in") }
}

extend self: FileSystem {

    readText(file: String): String { panic("Built-in") }

    writeText(file: String, text: String): Unit { panic("Built-in") }

    list(path: String): List[String] { panic("Built-in") }

    exists(path: String): Bool { panic("Built-in") }

    isDirectory(path: String): Bool { panic("Built-in") }

    createDirectory(path: String): Unit { panic("Built-in") }

    createDirectories(path: String): Unit { panic("Built-in") }

    delete(path: String): Unit { panic("Built-in") }

    rename(fromPath: String, toPath: String): Unit { panic("Built-in") }

    getAbsolutePath(path: String): String { panic("Built-in") }

    directoryName(path: String): String { panic("Built-in") }

    baseName(path: String): String { panic("Built-in") }

    prefixName(path: String): String { panic("Built-in") }

    suffixName(path: String): String { panic("Built-in") }

}
