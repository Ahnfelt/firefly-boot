type Option[T] {
    None
        scala "scala.None"
    Some(value: T)
        scala "scala.Some"
}
    scala "#type Option[+T] = scala.Option[T]"

extend self[T]: Option[T] {

    else(body: () => T): T {
        self.{
            | None => body()
            | Some(value) => value
        }
    }
        scala "#def Option_else[T, S >: T, T2 <: S](self_ : Option[T], body_ : Function0[T2]) : S = { pipe_dot(self_)({ case (ff.core.Option_.None()) => body_(); case (ff.core.Option_.Some(value_)) => value_})}"

    elseIf(condition: () => Bool, body: () => T): Option[T] {
        self.{
            | None =>
                condition().{
                    | True => Some(body())
                    | False => None
                }
            | Some(_) => self
        }
    }
        scala "#def Option_elseIf[T, S >: T, T2 <: S](self_ : Option[T], condition_ : Function0[ff.core.Bool_.Bool], body_ : Function0[T2]) : ff.core.Option_.Option[S] = { pipe_dot(self_)({ case (ff.core.Option_.None()) => pipe_dot(condition_())({ case (ff.core.Bool_.True()) => ff.core.Option_.Some(body_()); case (ff.core.Bool_.False()) => ff.core.Option_.None()}); case (ff.core.Option_.Some(_)) => self_ })}"

    orElse(body: () => Option[T]): Option[T] {
        self.{
            | None => body()
            | Some(_) => self
        }
    }
        scala "#def Option_orElse[T, S >: T, T2 <: S](self_ : Option[T], body_ : Function0[ff.core.Option_.Option[T2]]) : ff.core.Option_.Option[S] = { pipe_dot(self_)({ case (ff.core.Option_.None()) => body_(); case (ff.core.Option_.Some(_)) => self_ })}"

    isEmpty(): Bool {
        self.{
            | None => True
            | Some(_) => False
        }
    }

    toList(): List[T] {
        self.{
            | None => []
            | Some(v) => [v]
        }
    }

    filter(body: T => Bool): Option[T] {
        self.{
            | Some(v) {body(v)} => Some(v)
            | _ => None
        }
    }

    map[R](body: T => R): Option[R] {
        self.{
            | None => None
            | Some(v) => Some(body(v))
        }
    }

    flatMap[R](body: T => Option[R]): Option[R] {
        self.{
            | None => None
            | Some(v) => body(v)
        }
    }

    each(body: T => Unit): Unit {
        self.{
            | None =>
            | Some(v) => body(v)
        }
    }

    all(body: T => Bool): Bool {
        self.{
            | None => True
            | Some(v) => body(v)
        }
    }

    any(body: T => Bool): Bool {
        self.{
            | None => False
            | Some(v) => body(v)
        }
    }

    expect(): T {
        self.{
            | None => panic("None.expect()")
            | Some(v) => v
        }
    }

    // TODO: Eq constraint
    contains(value: T): Bool {
        self.{
            | None => False
            | Some(v) => v == value
        }
    }

}

extend self[T]: Option[Option[T]] {

    flatten() : Option[T] {
        self.{
            | None => None
            | Some(v) => v
        }
    }

}
