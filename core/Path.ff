capability Path {}
capability PathEntry {}

extend self: Path {

    exists(checkReadable: Bool = False, checkWritable: Bool = False, checkExecutable: Bool = False): Bool {
        let fs = Js.import("fs")
        let fsPromises = Js.import("fs/promises")
        let flagsR: Int = (fs->constants->"R_OK" * checkReadable!)?
        let flagsW: Int = (fs->constants->"W_OK" * checkWritable!)?
        let flagsX: Int = (fs->constants->"X_OK" * checkExecutable!)?
        let flags = flagsR.bitOr(flagsW.bitOr(flagsX))
        try {
            Js.await(
                fsPromises->access(self!, if(flags == 0) {fs->constants->"F_OK"} else {flags!})
            )
            True
        } catchAny {_ => 
            False
        }
    }

    isReadable(): Bool {
        self.exists(checkReadable = True)
    }
        
    isWritable(): Bool {
        self.exists(checkWritable = True)
    }

    isExecutable(): Bool {
        self.exists(checkExecutable = True)
    }

    isDirectory(): Bool {
        let fsPromises = Js.import("fs/promises")        
        try {
            Js.await(fsPromises->lstat(self!))->isDirectory()?
        } catchAny {_ => 
            False
        }
    }

    isFile(): Bool {
        let fsPromises = Js.import("fs/promises")        
        try {
            Js.await(fsPromises->lstat(self!))->isFile()?
        } catchAny {_ => 
            False
        }        
    }

    isSymbolicLink(): Bool {
        let fsPromises = Js.import("fs/promises")        
        try {
            Js.await(fsPromises->lstat(self!))->isSymbolicLink()?
        } catchAny {_ => 
            False
        }        
    }

    isInsideOf(path: Path): Bool {
        let nodePath = Js.import("path")
        if(path! === "/") {True} else:
        let childPath = nodePath->resolve(self!)
        let parentPath = nodePath->resolve(path!)
        childPath->startsWith(parentPath + nodePath->sep)? || childPath === parentPath
    }
    
    size(): Int {
        let fs = Js.import("fs")
        Js.await(fs->promises->stat(self!))?
    }
        
    modified(): Instant {
        let fs = Js.import("fs")
        (Js.await(fs->promises->stat(self!))->mtimeMs * 0.001!)?
    }

    entries(): Stream[PathEntry]
        target node async """
            import * as fsPromises from 'fs/promises'
            let dir = null
            return ff_core_Stream.Stream(
                async () => {
                    if(dir === null) dir = await fsPromises.opendir(self_, {bufferSize: 128})
                    const entry = await dir.read()
                    if(entry === null) return ff_core_Option.None()
                    entry.ffPath = self_
                    return ff_core_Option.Some(entry)
                },
                async () => {
                    if(dir !== null) await dir.close()
                }
            )
        """

    absolute(): String {
        let path = Js.import("path")        
        path->resolve(self!)?
    }

    relativeTo(path: Path): String {
        let nodePath = Js.import("path")        
        nodePath->relative(path!, self!)?
    }
    
    endsWith(parts: List[String]): Bool {
        function go(pathOption: Option[Path], reversed: List[String]): Bool {
            | _, [] => True
            | Some(path), [p, ...ps] => path.base() == p && go(path.parent(), ps)
            | None, _ => False
        }
        go(Some(self), parts.reverse())
    }

    contains(parts: List[String]): Bool {
        self.endsWith(parts) || self.parent().any {_.contains(parts)}
    }

    base(): String {
        let path = Js.import("path")
        path->basename(self!)?        
    }

    extension(): String {
        let path = Js.import("path")
        path->extname(self!)?        
    }

    url(): String {
        let url = Js.import("url")
        "" + url->pathToFileURL(self!)?        
    }

    delimiter(): String {
        let path = Js.import("path")
        path->delimiter(self!)?        
    }

    separator(): String {
        let path = Js.import("path")
        path->separator(self!)?        
    }

    parent(): Option[Path] {
        let path = Js.import("path")
        let result = path->dirname(self!)
        if(result !== "" && result !== self!) {result?}
    }

    slash(relativePath: String): Path {
        let path = Js.import("path")
        path->join(self!, relativePath)?
    }

    path(absoluteOrRelativePath: String): Path {
        let path = Js.import("path")
        path->resolve(self!, absoluteOrRelativePath)?
    }

    copyTo(path: Path, retries: Int = 0, retryDelay: Int = 100) {
        if(self.isDirectory()) {
            if(path.exists()) {path.delete(retries, retryDelay)}
            path.createDirectory()
            self.entries().each {file =>
                file.path().copyTo(path.slash(file.path().relativeTo(self)), retries, retryDelay)
            }
        } elseIf {self.isSymbolicLink()} {
            path.createSymlinkTo(self.path(self.readSymbolicLink()), junction = True)
        } else {
            path.writeStream(self.readStream())
        }
    }

    createDirectory(createParentDirectories: Bool = False) {
        let fsPromises = Js.import("fs/promises")
        Js.await(fsPromises->mkdir(self!, Js->(recursive = createParentDirectories)))
    }

    createSymlinkTo(path: Path, junction: Bool = False) {
        let fsPromises = Js.import("fs/promises")
        Js.await(fsPromises->symlink(path!, self!, if(junction) {"junction"!} else {Js.null()}))
    }

    delete(retries: Int = 0, retryDelay: Int = 100) {
        let fsPromises = Js.import("fs/promises")
        Js.await(fsPromises->rm(self!, Js->(recursive = True, retries = retries, retryDelay = retryDelay)))
    }
    
    truncate(length: Int = 0) {
        let fsPromises = Js.import("fs/promises")
        Js.await(fsPromises->truncate(self!, length))
    }

    renameTo(path: Path) {
        let fsPromises = Js.import("fs/promises")
        Js.await(fsPromises->rename(self!, path!))
    }

    readSymbolicLink(): String {
        let fsPromises = Js.import("fs/promises")
        Js.await(fsPromises->readlink(self!))?
    }

    readText(): String {
        let fsPromises = Js.import("fs/promises")
        Js.withSignal {signal =>
            Js.await(fsPromises->readFile(self!, Js->(encoding = "UTF-8", signal = signal)))?
        }
    }

    writeText(text: String) {
        let fsPromises = Js.import("fs/promises")
        Js.withSignal {signal =>
            Js.await(fsPromises->writeFile(self!, text, Js->(encoding = "UTF-8", signal = signal)))?
        }
    }

    appendText(text: String) {
        let fsPromises = Js.import("fs/promises")
        Js.withSignal {signal =>
            Js.await(fsPromises->appendFile(self!, text, Js->(encoding = "UTF-8", signal = signal)))?
        }
    }

    readBuffer(): Buffer {
        self.readStream().toBuffer()
    }
    
    writeBuffer(buffer: Buffer) {
        self.writeStream([buffer].toStream())
    }
    
    appendBuffer(buffer: Buffer) {
        self.appendStream([buffer].toStream())
    }

    readStream(): Stream[Buffer]
        target node async """
            import * as fs from 'fs'
            return ff_core_Path.internalReadStream_$(() => fs.createReadStream(self_))
        """

    writeStream(stream: Stream[Buffer], createOnly: Bool = False)
        target node async """
            import * as fs from 'fs'
            let writeable = fs.createWriteStream(self_, {flags: createOnly_ ? 'wx' : 'w'})
            try {
                await ff_core_Stream.Stream_each$(stream_, async buffer => {
                    if(!writeable.write(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength))) {
                        await new Promise((resolve, reject) => {
                            $task.controller.signal.addEventListener('abort', reject)
                            writeable.once('drain', () => {
                                $task.controller.signal.removeEventListener('abort', reject)
                                resolve()
                            })
                        })
                    }
                }, $task)
            } finally {
                await new Promise((resolve, reject) => {
                    writeable.close(err => {if(err) reject(err); else resolve();});
                });
            }
        """

    appendStream(stream: Stream[Buffer])
        target node async """
            import * as fs from 'fs'
            let writeable = fs.createWriteStream(self_, {flags: 'a'})
            try {
                await ff_core_Stream.Stream_each$(stream_, async buffer => {
                    if(!writeable.write(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength))) {
                        await new Promise((resolve, reject) => {
                            $task.controller.signal.addEventListener('abort', reject)
                            writeable.once('drain', () => {
                                $task.controller.signal.removeEventListener('abort', reject)
                                resolve()
                            })
                        })
                    }
                }, $task)
            } finally {
                await new Promise((resolve, reject) => {
                    writeable.close(err => {if(err) reject(err); else resolve();});
                });
            }
        """

    readHandle(alsoWrite: Bool = False): FileHandle {
        let fsPromises = Js.import("fs/promises")
        Js.await(fsPromises->open(self!, if(alsoWrite) {"r+"} else {"r"}))?
    }

    writeHandle(alsoRead: Bool = False, mustCreate: Bool = False): FileHandle {
        let fsPromises = Js.import("fs/promises")
        let flags = if(mustCreate) {"wx"} else {"w"} + if(alsoRead) {"+"} else {""}
        Js.await(fsPromises->open(self!, flags))?
    }
   
    appendHandle(alsoRead: Bool = False, mustCreate: Bool = False): FileHandle {
        let fsPromises = Js.import("fs/promises")
        let flags = if(mustCreate) {"ax"} else {"a"} + if(alsoRead) {"+"} else {""}
        Js.await(fsPromises->open(self!, flags))?
    }

}

extend self: PathEntry {
    
    path(): Path {
        let path = Js.import("path")
        path->join(self!->ffPath, self!->name)?
    }

    isDirectory(): Bool {
        self!->isDirectory()?
    }

    isFile(): Bool {
        self!->isFile()?
    }

    isSymbolicLink(): Bool {
        self!->isSymbolicLink()?
    }

}

internalReadStream(createReadStream: () => JsValue): Stream[Buffer] {
    mutable readable = None
    Stream {
        Js.throwIfCancelled()
        mutable doResolve = {}
        mutable doReject = {_ => }
        mutable seenError = Js.null()
        let jsStream = readable.else {
            let newReadable = createReadStream()
            newReadable->on("readable", Js->{
                doResolve()
            })
            newReadable->on("error", Js->{error =>
                seenError = error
                doReject(error)
            })
            newReadable->on("close", Js->{
                doResolve()
            })
            readable = Some(createReadStream())
            newReadable
        }
        function go(): Option[Buffer] {
            let jsBuffer = jsStream->read()
            if(!jsBuffer.isNullOrUndefined()) {
                let buffer: Buffer = Js->DataView->(jsBuffer->buffer, jsBuffer->byteOffset, jsBuffer->length)?
                Some(buffer)
            } else:
            if(!seenError.isNullOrUndefined()) {
                throwAny(seenError?)
            } else:
            if(jsStream->destroyed?) {None} else:
            Js.withSignal {signal =>
                let promise = Js->Promise->(Js->{resolve, reject =>
                    let jsDoReject = Js->{doReject(_)}
                    doResolve = {
                        signal->removeEventListener("abort", jsDoReject)
                        doResolve = {}
                        doReject = {_ => }
                        resolve.callValue0()
                    }
                    doReject = {error => 
                        signal->removeEventListener("abort", jsDoReject)
                        doResolve = {}
                        doReject = {_ => }
                        reject.callValue1(error)
                    }
                    signal->addEventListener("abort", jsDoReject)
                })
                Js.await(promise)
            }
            go()
        }
        go()
    } {
        readable.each {_->destroy()}
    }
}

internalReadStreamOld(createReadStream: () => JsValue): Stream[Buffer]
    target node async """
        let task = null
        let readable = null
        let doResolve = null
        let doReject = null
        let seenError = null
        const abort = () => {
            if(task != null) {
                task.controller.signal.removeEventListener('abort', abort)
                readable.destroy()
            }
        }
        function open($task) {
            ff_core_Task.Task_throwIfAborted($task)
            task = $task
            readable = createReadStream_()
            readable.on('readable', () => {
                if(doResolve != null) doResolve()
            })
            readable.on('error', error => {
                task.controller.signal.removeEventListener('abort', abort)
                seenError = error
                if(doReject != null) doReject(error)
            })
            readable.on('close', () => {
                task.controller.signal.removeEventListener('abort', abort)
                if(doResolve != null) doResolve()
            })
            $task.controller.signal.addEventListener('abort', abort)
        }
        return ff_core_Stream.Stream(async function go($task) {
            if(task == null) open($task)
            let buffer = readable.read()
            if(buffer != null) return ff_core_Option.Some(new DataView(buffer.buffer, buffer.byteOffset, buffer.length))
            if(seenError != null) throw seenError
            if(readable.destroyed) return ff_core_Option.None()
            let promise = new Promise((resolve, reject) => {
                doResolve = () => {doResolve = null; doReject = null; resolve()}
                doReject = error => {doResolve = null; doReject = null; reject(error)}
            }).then(() => go($task))
            return await promise
        }, abort)
    """
