type FileSystem! {}

extend self: FileSystem {

    jsFileSystemHack(): Nothing { panic("magic") }
        javascript "#function jsFileSystemHack() {} import * as fs from 'fs';"
        javascriptasync "#function jsFileSystemHack$() {} import * as fsPromises from 'fs/promises'; import * as path from 'path'; import * as zlib from 'zlib'"

    readText(file: String): String { panic("magic") }
        javascript "return fs.readFileSync(file_, {encoding: 'UTF-8'})"
        javascriptasync "return await fsPromises.readFile(file_, {encoding: 'UTF-8', signal: $c.signal})"

    writeText(file: String, text: String): Unit { panic("magic") }
        javascript "fs.writeFileSync(file_, text_, {encoding: 'UTF-8'})"
        javascriptasync "await fsPromises.writeFile(file_, text_, {encoding: 'UTF-8', signal: $c.signal})"

    list(path: String): List[String] { panic("magic") }
        javascript "return ff_core_Array.Array_toList(fs.readdirSync(path_).map(f => path_ + '/' + f))"
        javascriptasync "return ff_core_Array.Array_toList((await fsPromises.readdir(path_)).map(f => path_ + '/' + f))"

    exists(path: String): Bool { panic("magic") }
        javascript "return fs.existsSync(path_)"
        javascriptasync "return await fsPromises.access(path_).then(() => true).catch(() => false)"

    isDirectory(path: String): Bool { panic("magic") }
        javascript "return fs.lstatSync(path_).isDirectory()"
        javascriptasync "return (await fsPromises.lstat(path_)).isDirectory()"

    createDirectory(path: String): Unit { panic("magic") }
        javascript "fs.mkdirSync(path_)"
        javascriptasync "await fsPromises.mkdir(path_)"

    createDirectories(path: String): Unit { panic("magic") }
        javascript "fs.mkdirSync(path_, {recursive: true})"
        javascriptasync "await fsPromises.mkdir(path_, {recursive: true})"

    delete(path: String): Unit { panic("magic") }
        javascript "try { fs.rmdirSync(path_) } catch(_) { fs.rmSync(path_) }"
        javascriptasync "try { await fsPromises.rmdir(path_) } catch(_) { await fsPromises.rm(path_) }"

    rename(fromPath: String, toPath: String): Unit { panic("magic") }
        javascript "fs.renameSync(fromPath_, toPath_)"
        javascriptasync "await fsPromises.rename(fromPath_, toPath_)"

    getAbsolutePath(path: String): String { panic("magic") }
        javascript "return path.resolve(path_)"

    readStream(file: String): Stream[Buffer] { panic("magic") }
        javascriptasync """
            return $c => {
                if($c.signal.aborted) throw new Error("Cancelled", {cause: $c.reasonWorkaround})
                const readable = fs.createReadStream(file_)
                let doResolve = null
                let doReject = null
                let seenError = null
                readable.on('readable', () => {
                    if(doResolve != null) doResolve()
                })
                readable.on('error', error => {
                    seenError = error
                    if(doReject != null) doReject(error)
                })
                readable.on('close', () => {
                    if(doResolve != null) doResolve()
                })
                const abort = () => {
                    $c.signal.removeEventListener('abort', abort)
                    readable.close()
                }
                $c.signal.addEventListener('abort', abort)
                return ff_core_Iterator.Iterator(async function go($c) {
                    let buffer = readable.read()
                    if(buffer != null) return ff_core_Option.Some(buffer)
                    if(seenError != null) throw seenError
                    if(readable.destroyed) return ff_core_Option.None()
                    let promise = new Promise((resolve, reject) => {
                        doResolve = () => {doResolve = null; doReject = null; resolve()}
                        doReject = error => {doResolve = null; doReject = null; reject(error)}
                    }).then(() => go($c))
                    return await promise
                }, abort)
            }
        """

    writeStream(file: String, stream: Stream[Buffer]): Unit { panic("magic") }
        javascriptasync """
            let writeable = fs.createWriteStream(file_)
            try {
                await ff_core_Stream.Stream_each$(stream_, async buffer => {
                    if(!writeable.write(buffer)) {
                        await new Promise((resolve, reject) => {
                            $c.signal.addEventListener('abort', reject)
                            writeable.once('drain', () => {
                                $c.signal.removeEventListener('abort', reject)
                                resolve()
                            })
                        })
                    }
                }, $c)
            } finally {
                writeable.close()
            }
        """

    decompressGzipStream(stream: Stream[Buffer]): Stream[Buffer] { panic("magic") }
        javascriptasync """
            () => {
                const iterator = stream_($c)
                let decompress = zlib.createGunzip()
                let doResolve = null
                let doReject = null
                let seenError = null
                decompress.on('readable', () => {
                    if(doResolve != null) doResolve()
                })
                decompress.on('error', error => {
                    seenError = error
                    if(doReject != null) doReject(error)
                })
                decompress.on('close', () => {
                    if(doResolve != null) doResolve()
                })
                const abort = () => {
                    $c.signal.removeEventListener('abort', abort)
                    decompress.destroy()
                }
                $c.signal.addEventListener('abort', abort)
                return ff_core_Iterator.Iterator(async function go($c) {
                    let buffer = readable.read()
                    if(buffer != null) return ff_core_Option.Some(buffer)
                    buffer = iterator.next_($c).value_
                    let wait = buffer != null && !writeable.write(buffer)
                    if(seenError != null) throw seenError
                    if(decompress.destroyed) return ff_core_Option.None()
                    let promise = new Promise((resolve, reject) => {
                        function reset() { decompress.off('drain', doResolve); doResolve = null; doReject = null }
                        doResolve = () => {reset(); resolve()}
                        doReject = error => {reset(); reject(error)}
                    }).then(() => go($c))
                    decompress.on('drain', doResolve)
                    return await promise
                }, abort)
            }
        """

}

directoryName(path: String): String {
    path.reverse().dropWhile { _ != '/' }.dropFirst(1).reverse()
}

baseName(path: String): String {
    path.reverse().takeWhile { _ != '/' }.reverse()
}

prefixName(path: String): String {
    path.reverse().takeWhile { _ != '/' }.reverse().takeWhile { _ != '.' }
}

suffixName(path: String): String {
    path.reverse().takeWhile { _ != '/' }.takeWhile { _ != '.' }.reverse()
}
