capability FileSystem {}

extend self: FileSystem {

    copy(fromPath: String, toPath: String): Unit {
        if(self.isDirectory(fromPath)) {
            if(self.exists(toPath)) {self.deleteDirectory(toPath) }
            self.createDirectory(toPath)
            self.list(fromPath).each {file =>
                self.copy(file, toPath + "/" + file.reverse().takeWhile {_ != '/'}.reverse())
            }
        } else {
            self.writeStream(toPath, self.readStream(fromPath))
        }
    }

    readText(file: String): String
        target node async """
            import * as fsPromises from 'fs/promises'
            return await fsPromises.readFile(file_, {encoding: 'UTF-8', signal: $c.signal})
        """

    writeText(file: String, text: String): Unit
        target node async """
            import * as fsPromises from 'fs/promises'
            await fsPromises.writeFile(file_, text_, {encoding: 'UTF-8', signal: $c.signal})
        """

    appendText(file: String, text: String): Unit
        target node async """
            import * as fsPromises from 'fs/promises'
            await fsPromises.appendFile(file_, text_, {encoding: 'UTF-8', signal: $c.signal})
        """

    list(path: String): List[String]
        target node async """
            import * as fsPromises from 'fs/promises'
            return ff_core_Array.Array_toList((await fsPromises.readdir(path_)).map(f => path_ + '/' + f))
        """

    exists(path: String): Bool
        target node async """
            import * as fsPromises from 'fs/promises'
            return await fsPromises.access(path_).then(() => true).catch(() => false)
        """

    isDirectory(path: String): Bool
        target node async """
            import * as fsPromises from 'fs/promises'
            try {
                return (await fsPromises.lstat(path_)).isDirectory();
            } catch(e) {
                return false;
            }
        """

    createDirectory(path: String): Unit
        target node async """
            import * as fsPromises from 'fs/promises'
            await fsPromises.mkdir(path_)
        """

    createDirectories(path: String): Unit
        target node async """
            import * as fsPromises from 'fs/promises'
            await fsPromises.mkdir(path_, {recursive: true})
        """

    delete(path: String): Unit
        target node async """
            import * as fsPromises from 'fs/promises'
            try { await fsPromises.rmdir(path_) } catch(_) { await fsPromises.rm(path_) }
        """

    deleteDirectory(path: String): Unit {
        self.list(path).each {file =>
            if(self.isDirectory(file)) {
                self.deleteDirectory(file)
            } else {
                self.delete(file)
            }
        }
        self.delete(path)
    }

    rename(fromPath: String, toPath: String): Unit
        target node async """
            import * as fsPromises from 'fs/promises'
            await fsPromises.rename(fromPath_, toPath_)
        """

    readStream(file: String): Stream[Buffer]
        target node async """
            import * as fs from 'fs'
            return ff_core_FileSystem.internalReadStream_$(() => fs.createReadStream(file_))
        """

    writeStream(file: String, stream: Stream[Buffer], createOnly: Bool = False): Unit
        target node async """
            import * as fs from 'fs'
            let writeable = fs.createWriteStream(file_, {flags: createOnly_ ? 'wx' : 'w'})
            try {
                await ff_core_Stream.Stream_each$(stream_, async buffer => {
                    if(!writeable.write(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength))) {
                        await new Promise((resolve, reject) => {
                            $c.signal.addEventListener('abort', reject)
                            writeable.once('drain', () => {
                                $c.signal.removeEventListener('abort', reject)
                                resolve()
                            })
                        })
                    }
                }, $c)
            } finally {
                writeable.close()
            }
        """

    appendStream(file: String, stream: Stream[Buffer]): Unit
        target node async """
            import * as fs from 'fs'
            let writeable = fs.createWriteStream(file_, {flags: 'a'})
            try {
                await ff_core_Stream.Stream_each$(stream_, async buffer => {
                    if(!writeable.write(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength))) {
                        await new Promise((resolve, reject) => {
                            $c.signal.addEventListener('abort', reject)
                            writeable.once('drain', () => {
                                $c.signal.removeEventListener('abort', reject)
                                resolve()
                            })
                        })
                    }
                }, $c)
            } finally {
                writeable.close()
            }
        """

    decompressGzipStream(stream: Stream[Buffer]): Stream[Buffer]
        target node async """
            import * as zlib from 'zlib'
            let c = null
            let decompress = null
            let doResolve = null
            let doReject = null
            let seenError = null
            const abort = () => {
                if(c != null) {
                    c.signal.removeEventListener('abort', abort)
                    decompress.destroy()
                }
            }
            function open($c) {
                c = $c
                decompress = zlib.createGunzip()
                decompress.on('readable', () => {
                    if(doResolve != null) doResolve()
                })
                decompress.on('error', error => {
                    seenError = error
                    if(doReject != null) doReject(error)
                })
                decompress.on('close', () => {
                    if(doResolve != null) doResolve()
                })
                $c.signal.addEventListener('abort', abort)
            }
            return ff_core_Stream.Stream(async function go($c) {
                if(c == null) open($c)
                if(seenError != null) throw seenError
                if(!decompress.readable) return ff_core_Option.None()
                let buffer = decompress.read()
                if(buffer != null) return ff_core_Option.Some(new DataView(buffer.buffer, buffer.byteOffset, buffer.length))
                buffer = (await stream_.next_($c)).value_
                if(buffer == null) decompress.end()
                let wait = buffer == null || !decompress.write(new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength))
                if(seenError != null) throw seenError
                if(!wait) return go($c)
                let promise = new Promise((resolve, reject) => {
                    function reset() { decompress.off('drain', doResolve); doResolve = null; doReject = null }
                    doResolve = () => {reset(); resolve()}
                    doReject = error => {reset(); reject(error)}
                }).then(() => go($c))
                decompress.on('drain', doResolve)
                return await promise
            }, abort)
        """

    open(file: String, flags: String): FileHandle
        target node async """
            import * as fsPromises from 'fs/promises'
            return await fsPromises.open(file, flags)
        """

    absolutePath(path: String): String
        target node async """
            import * as path from 'path'
            return path.resolve(path_)
        """

    workingDirectory(): String
        target node async """
            return process.cwd()
        """

}

directoryName(path: String): String {
    let directory = path.reverse().dropWhile {_ != '/'}.dropFirst(1).reverse()
    if(directory == "") {"."} else {directory}
}

baseName(path: String): String {
    path.reverse().takeWhile {_ != '/'}.reverse()
}

prefixName(path: String): String {
    path.reverse().takeWhile {_ != '/'}.reverse().takeWhile {_ != '.'}
}

suffixName(path: String): String {
    path.reverse().takeWhile {_ != '/'}.takeWhile {_ != '.'}.reverse()
}

internalReadStream(createReadStream: () => JsValue): Stream[Buffer]
    target node async """
        let c = null
        let readable = null
        let doResolve = null
        let doReject = null
        let seenError = null
        const abort = () => {
            if(c != null) {
                c.signal.removeEventListener('abort', abort)
                readable.destroy()
            }
        }
        function open($c) {
            if($c.signal.aborted) throw new Error("Cancelled", {cause: $c.reasonWorkaround})
            c = $c
            readable = createReadStream_()
            readable.on('readable', () => {
                if(doResolve != null) doResolve()
            })
            readable.on('error', error => {
                seenError = error
                if(doReject != null) doReject(error)
            })
            readable.on('close', () => {
                if(doResolve != null) doResolve()
            })
            $c.signal.addEventListener('abort', abort)
        }
        return ff_core_Stream.Stream(async function go($c) {
            if(c == null) open($c)
            let buffer = readable.read()
            if(buffer != null) return ff_core_Option.Some(new DataView(buffer.buffer, buffer.byteOffset, buffer.length))
            if(seenError != null) throw seenError
            if(readable.destroyed) return ff_core_Option.None()
            let promise = new Promise((resolve, reject) => {
                doResolve = () => {doResolve = null; doReject = null; resolve()}
                doReject = error => {doResolve = null; doReject = null; reject(error)}
            }).then(() => go($c))
            return await promise
        }, abort)
    """

urlToPath(fileUrl: String): String
    target node sync """
        import * as url from 'url';
        return url.fileURLToPath(new URL(fileUrl_));
    """

pathToUrl(path: String): String
    target node sync """
        import * as url from 'url';
        return '' + url.pathToFileURL(path_);
    """

relative(fromPath: String, toPath: String): String
    target node sync """
        import * as path from 'path';
        return path.relative(fromPath_, toPath_);
    """
