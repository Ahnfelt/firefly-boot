capability NodeSystem {}

class ProcessResult(exitCode: Int, standardOut: Buffer, standardError: Buffer)
data ProcessException(problem: String)

extend self: NodeSystem {

    arguments(): List[String] {
        self!->"array_"?
    }

    assets(): AssetSystem {
        let assetPkgSnapshotPath = self.path("/snapshot/output/assets")
        if(assetPkgSnapshotPath.isDirectory()) {
            // Opendir gives ENOENT: no such file or directory, opendir '/snapshot/output/assets'
            function streams(path: Path): Stream[Pair[String, () => Stream[Buffer]]] {
                internalListDirectoryWithoutOpendir(self, path).toStream().flatMap {file =>
                    if(file.isDirectory()) {
                        streams(file)
                    } else {
                        [Pair("/" + file.relativeTo(assetPkgSnapshotPath), {file.readStream()})].toStream()
                    }
                }
            }
            AssetSystem(streams(assetPkgSnapshotPath).toMap())
        } else {
            self!->"assets_"?
        }
    }

    path(relativePath: String): Path {
        let nodePath = Js.import("path")
        Path(nodePath->resolve(relativePath)?)
    }

    pathFromUrl(url: String): Path {
        let nodeUrl = Js.import("url")
        Path(nodeUrl->fileURLToPath(Js->URL->(url))?)
    }

    httpClient(): HttpClient {
        Js.globalThis()?
    }

    mainTask(): Task {
        self!->"task_"?
    }

    crypto(): Crypto {
        Js.globalThis()->crypto?
    }

    js(): JsSystem {
        Js.jsSystem()
    }

    exit[T](exitCode: Int = 0): T {
        Js->process->exit(exitCode)?
    }

    readStream(): Stream[Buffer] {
        Path.internalReadStream {Js->process->stdin}
    }

    writeBuffer(buffer: Buffer): Unit {
        Js->process->stdout->write(Js->Uint8Array->(buffer!->buffer, buffer!->byteOffset, buffer!->byteLength))
    }

    writeStream(stream: Stream[Buffer]): Unit {
        stream.each {self.writeBuffer(_)}
    }

    writeText(text: String): Unit {
        self.writeBuffer(text.toBuffer())
    }

    writeLine(text: String): Unit {
        self.writeText(text + "\n")
    }

    writeErrorBuffer(buffer: Buffer): Unit {
        Js->process->stderr->write(Js->Uint8Array->(buffer!->buffer, buffer!->byteOffset, buffer!->byteLength))
    }

    writeErrorStream(stream: Stream[Buffer]): Unit {
        stream.each {self.writeErrorBuffer(_)}
    }

    writeErrorText(text: String): Unit {
        self.writeErrorBuffer(text.toBuffer())
    }

    writeErrorLine(text: String): Unit {
        self.writeErrorText(text + "\n")
    }
    
    environment(): Map[String, String] {
        mutable result = Map.new()
        Js->process->env.each {key =>
            result = result.add(key?, Js->process->env.get(key)?)
        }
        result
    }
    
    execute(
        command: String
        arguments: List[String]
        standardIn: Buffer = Buffer.new(0)
        directory: Option[Path] = None
        environment: Option[Map[String, String]] = None
        maxBuffer: Int = 16777216
        killSignal: Int = 9
        shell: Bool = False
    ): ProcessResult
        target node async """
            import * as childProcess from 'node:child_process';
            const environment = environment_.value_ !== void 0 ? {} : process.env;
            if(environment_.value_ !== void 0) {
                ff_core_Map.Map_each(
                    environment_.value_, 
                    (k, v) => environment[k] = v, 
                    ff_core_Ordering.ff_core_Ordering_Order$ff_core_String_String
                );
            }
            const newProcess = childProcess.spawn(command_, arguments_, {
                cwd: directory_.value_ ? directory_.value_.absolutePath_ : void 0,
                windowsHide: true,
                signal: $task.controller_.signal,
                killSignal: killSignal_,
                env: environment,
                shell: shell_
            });
            
            let size = 0;
            const out = [];
            const err = [];
            
            newProcess.stdout.on('data', (data) => {
                if(size > maxBuffer_) return;
                size += data.byteLength;
                if(size > maxBuffer_) newProcess.kill(killSignal_);
                else out.push(data);
            });

            newProcess.stderr.on('data', (data) => {
                if(size > maxBuffer_) return;
                size += data.byteLength;
                if(size > maxBuffer_) newProcess.kill(killSignal_);
                else err.push(data);
            });

            return await new Promise((resolve, reject) => {
                if(standardIn_.byteLength !== 0) {
                    newProcess.stdin.write(standardIn_);
                }
                newProcess.stdin.end();
                newProcess.on('error', error => {
                    if(size > maxBuffer_) {
                        reject(internalProcessError_("maxBuffer exceeded"));
                    } else {
                        reject(internalProcessError_(error.message));
                    }
                });
                newProcess.on('close', code => {
                    const o = Buffer.concat(out);
                    const e = Buffer.concat(err);
                    resolve(ProcessResult(
                        code,
                        new DataView(o.buffer, o.byteOffset, o.byteLength),
                        new DataView(e.buffer, e.byteOffset, e.byteLength),
                    ));
                }); 
            });
        """

}

internalListDirectoryWithoutOpendir(system: NodeSystem, path: Path): List[Path] {
    let fsPromises = Js.import("fs/promises")
    let nodePath = Js.import("path")
    let files = Js.await(fsPromises->readdir(path.absolutePath))
    files.grabArray().map {file => Path(nodePath->join(path.absolutePath, file)?)}
}

internalProcessError(problem: String): Error {
    try {
        throw(ProcessException(problem))
    } catchAny {error =>
        error
    }
}
