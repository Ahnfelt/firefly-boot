capability Lock(
    mutable owner: JsValue
    mutable level: Int
    mutable stack: Array[Pair[JsValue, Unit => Unit]]
    mutable queue: Array[Pair[JsValue, Unit => Unit]]
)

capability LockCondition(
    lock: Lock
    mutable stack: Array[Unit => Unit]
    mutable queue: Array[Unit => Unit]
)

extend self: Lock {

    condition(): LockCondition {
        LockCondition(self, Array.new(), Array.new())
    }
    
    acquire(): Unit {
        if(self.level == 0 || self.owner === Js.currentTask()!) {
            self.owner = Js.currentTask()!
            self.level += 1
        } else {
            Js.awaitCancellablePromise {resolve, reject, onSettle =>
                self.queue.push(Pair(Js.currentTask()!, resolve))
            }
        }
    }
    
    release(): Unit {
        if(self.owner !== Js.currentTask()!) {
            throw(GrabException)
        } elseIf {self.level > 1} {
            self.level -= 1
        } else {
            self.owner = Js.undefined()
            self.level = 0
            if(self.stack.isEmpty()) {
                let empty = self.stack
                self.queue.reverse()
                self.stack = self.queue
                self.queue = empty
            }
            if(!self.stack.isEmpty()) {
                let pending = self.stack.pop().grab()
                self.owner = pending.first
                self.level = 1
                pending.second(Unit)
            }
        }
    }
    
    do[T](body: () => T): T {
        self.acquire()
        try {
            body()
        } finally {
            self.release()
        }
    }

}

extend self: LockCondition {

    sleep(): Unit {
        if(self.lock.owner !== Js.currentTask()!) {
            throw(GrabException)
        }
        Js.throwIfCancelled()
        let level = self.lock.level
        self.lock.level = 1
        self.lock.release()
        try {
            Js.awaitCancellablePromise {resolve, reject, addCleanup =>
                self.queue.push(resolve)
            }
        } finally {
            mutable error = Js.undefined()
            mutable acquired = False
            while {!acquired} {
                try {
                    self.lock.acquire()
                    self.lock.level = level
                    acquired = True
                } catchAny {e =>
                    error = e!
                }
            }
            if(error.isUndefined()) {Js.throw(error)}
        }
    }

    sleepUntil[T](body: () => Option[T]): T {
        body().{
            | Some(value) =>
                value
            | None =>
                self.sleep()
                tailcall self.sleepUntil(body)
        }
    }

    wakeOne(): Unit {
        if(self.stack.isEmpty()) {
            let empty = self.stack
            self.queue.reverse()
            self.stack = self.queue
            self.queue = empty
        }
        if(!self.stack.isEmpty()) {
            let resolve = self.stack.pop().grab()
            resolve(Unit)
        }
    }

    wakeAll(): Unit {
        while {!self.stack.isEmpty()} {
            let resolve = self.stack.pop().grab()
            resolve(Unit)
        }
        let empty = self.stack
        self.queue.reverse()
        self.stack = self.queue
        self.queue = empty
        while {!self.stack.isEmpty()} {
            let resolve = self.stack.pop().grab()
            resolve(Unit)
        }
    }

}
