capability TaskScope {}

extend self: TaskScope {

    withSubscope[T](body: TaskScope => T, shielded: Bool = False, rethrow: Bool = True): T {
        let subscope = self.subscope(shielded)
        try {
            body(subscope)
        } finally {
            subscope.close(rethrow)
        } grab()
    }

    subscope[T](shielded: Bool = False): TaskScope
        target js async """
            if(!shielded_ && $c.signal.aborted) throw new Error("Cancelled", {cause: $c.ffReason})
            let scope = new AbortController()
            scope.ffClosed = false
            scope.ffParent = $c
            scope.ffPromises = new Set()
            scope.ffShielded = shielded_
            scope.ffAbort = () => {
                scope.ffReason = scope.ffParent.ffReason
                scope.abort()
            }
            if(!shielded_) scope.ffParent.signal.addEventListener('abort', scope.ffAbort)
            return scope
        """

    close[T](rethrow: Bool = True): Unit
        target js async """
            if(!self_.ffShielded) self_.ffParent.signal.removeEventListener('abort', self_.ffAbort)
            if(!self_.signal.aborted) {
                self_.ffReason = new Error("Cancelled")
                self_.abort()
            }
            let outcomes = await Promise.allSettled(self_.ffPromises)
            self_.ffClosed = true
            if(rethrow_) for(let outcome of outcomes) if(outcome.status === "rejected") throw outcome.reason
        """

    spawn(task: () => Unit): Unit
        target js async """
            if(self_.ffClosed) throw new Error("Spawn outside scope")
            async function spawn() {
                try {
                    let controller = await Promise.resolve(self_)
                    if(self_.signal.aborted) throw new Error("Cancelled", {cause: self_.ffReason})
                    await task_(controller)
                } catch(e) {
                    if(!self_.signal.aborted) {
                        self_.ffReason = e
                        self_.abort()
                    }
                } finally {
                    self_.ffPromises.delete(promise)
                }
            }
            let promise = spawn()
            self_.ffPromises.add(promise)
        """

    channel[T](capacity: Int = 0): Channel[T]
        target js async """
            return {scope: self_, capacity: capacity_, buffer: [], readers: new Set(), writers: new Set()}
        """

    sleep(duration: Duration): Unit {
        Channel.
            readOr(self.channel()) {_ => }.
            timeout(duration) {}
    }

    all[T](tasks: List[() => T]): List[T] {
        let channel = self.channel()
        self.withSubscope {scope =>
            tasks.pairs().each {| Pair(i, task) =>
                scope.spawn {
                    channel.write(Pair(i, task()))
                }
            }
            tasks.map {_ =>
                channel.read()
            }.sortBy {_.first}.map {_.second}
        }
    }

    race[T](tasks: List[() => T]): T {
        let successChannel = self.channel()
        let failureChannel = self.channel()
        mutable live = tasks.size()
        self.withSubscope {scope =>
            tasks.each {task =>
                scope.spawn {
                    try {
                        successChannel.write(task())
                    } catchAny {e =>
                        live -= 1
                        if(live == 0) {
                            failureChannel.write(e)
                        }
                    } grab()
                }
            }
            Channel.
                readOr(successChannel, {_}).
                readOr(failureChannel, {_.rethrow()}).
                wait()
        }
    }

}
