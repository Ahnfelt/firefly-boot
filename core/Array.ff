class Array[T] {}

new[T](): Array[T] {
    let js = UnsafeJs.jsSystem()
    js->(array = [])?
}
 
fill[T](size: Int, value: T): List[T] {
    let js = UnsafeJs.jsSystem()
    js->(array = List.fill(size, value)!)?
}

fillBy[T](size: Int, body: Int => T): List[T] {
    let js = UnsafeJs.jsSystem()
    js->(array = List.fillBy(size, body)!)?
}

range(size: Int): List[Int] {
    let js = UnsafeJs.jsSystem()
    js->(array = List.range(size)!)?
}

extend self[T]: Array[T] {
    

    isEmpty(): Bool {
        self.size() == 0
    }

    size(): Int {
        self!->array->length?
    }

    get(index: Int): Option[T] {
        if(index >= 0 && index < self.size()) {
            Some(self!->array.get(index)?)
        } else {
            None
        }
    }

    grab(index: Int): T {
        if(index < 0 || index >= self.size()) {
            throw(GrabException)
        }
        self!->array.get(index)?
    }

    first(): Option[T] {self.get(0)}

    last(): Option[T] {self.get(self.size() - 1)}

    grabFirst(): T {self.grab(0)}

    grabLast(): T {self.grab(self.size() - 1)}

    push(value: T): Unit {
        self!->array->push(value!)?
    }

    pushArray(value: Array[T]): Unit
        target js sync "self_.array.push(...value_.array)"

    pushList(value: List[T]): Unit
        target js sync "self_.array.push(...value_)"
        
    pushList2(list: List[T]): Unit {
        let originalLength = self.size()
        self!->array->length += list.size()
        0.until(list.size()).each {i =>
            self!->array.set(originalLength + i, list!.get(i))
        }
    }        

    pop(): Option[T] {
        if(self.size() > 0) {
            self!->array->pop()?
        }
    }

    set(index: Int, value: T): Unit {
        if(index < 0 || index >= self.size()) {
            throw(GrabException) // TODO Throw index out of bounds
        }
        self!->array.set(index, value!)
    }

    modify(index: Int, body: T => T): Unit
        target js sync """
            if(index_ < 0 || index_ >= self_.array.length) {
                ff_core_Try.internalThrowGrabException_()
            }
            self_.array[index_] = body_(self_.array[index_])
        """
        target js async """
            if(index_ < 0 || index_ >= self_.array.length) {
                ff_core_Try.internalThrowGrabException_()
            }
            self_.array[index_] = await body_(self_.array[index_], $task)
        """

    fill(value: T, start: Int = 0, end: Int = 9007199254740991): Unit
        target js sync """
            self_.array.fill(value_, start_, end_);
        """

    copy(target: Int, start: Int, end: Int): Unit
        target js sync """
            self_.array.copyWithin(target_, start_, end_);
        """

    delete(start: Int, deleteCount: Int): Unit
        target js sync """
            self_.array.splice(start_, deleteCount_);
        """

    insert(start: Int, value: T, deleteCount: Int = 0): Unit
        target js sync """
            self_.array.splice(start_, deleteCount_, value_);
        """

    insertArray(start: Int, array: Array[T], deleteCount: Int = 0): Unit {
        self.insertList(start, array!->array?, deleteCount)
    }

    insertList(start: Int, list: List[T], deleteCount: Int = 0): Unit {
        if(start < 0 || start > self.size()) {
            throw(GrabException) // TODO Throw index out of bounds
        }

        let deleteEnd = start + deleteCount

        if(deleteEnd < 0 || deleteEnd > self.size()) {
            throw(GrabException) // TODO Throw index out of bounds
        }

        let insertCount = list.size()
        let arrayCount = self.size()
        let delta = insertCount - deleteCount
        
        // Prepare for the new elements
        if(delta > 0) {
            self!->array->length += delta
            
            deleteEnd.until(arrayCount).reverse().each {i => 
                self!->array.set(i + delta, self!->array.get(i))
            }
        } else {
            deleteEnd.until(arrayCount).each {i => 
                self!->array.set(i + delta, self!->array.get(i))
            }

            self!->array->length += delta
        }

        // Insert the new elements
        0.until(insertCount).each {i => 
            self!->array.set(start + i, list!.get(i))
        }        
    }

    each(body: T => Unit): Unit
        target js sync """
            return self_.array.forEach(body_);
        """
        target js async """
            for(let i = 0; i < self_.array.length; i++) {
                await body_(self_.array[i], $task)
            }
        """

    eachWhile(body: T => Bool): Unit
        target js sync "for(const value of self_.array) if(!body_(value)) break"
        target js async "for(const value of self_.array) if(!await body_(value, $task)) break"

    all(body: T => Bool): Bool {
        mutable result = True
        self.eachWhile {x =>
            result = body(x)
            result
        }
        result
    }

    any(body: T => Bool): Bool {
        mutable result = False
        self.eachWhile {x =>
            result = body(x)
            (!result)
        }
        result
    }
    
    find(body: T => Bool): Option[T] {
        mutable result = None
        self.eachWhile {x =>
            if(body(x)) {
                result = Some(x)
                False
            } else {
                True
            }
        }
        result
    }

    indexWhere(body: T => Bool): Option[Int] {
        mutable i = -1
        mutable result = False
        self.eachWhile {x =>
            i += 1
            result = body(x)
            (!result)
        }
        if(result) {i}
    }

    drain(): List[T]
        target js sync "const result = self_.array; self_.array = []; return result"

    toList(start: Int = 0, end: Int = 9007199254740991): List[T]
        target js sync """return self_.array.slice(start_, end_)"""

    toStream(start: Int = 0, end: Int = 9007199254740991): Stream[T] {
        self.toList(start, end).toStream()
    }

    reverse(): Unit
        target js sync "self_.array.reverse()"

    sortBy[S: Order](body: T => S): Unit {
        self.sortWith {Ordering.compare(body(_), body(_))}
    }

    sortWith(ordering: (T, T) => Ordering): Unit {
        sortRange(self, ordering, 0, self.size())
    }
        target js sync "self_.array.sort((x, y) => ff_core_Ordering.Ordering_toInt(ordering_(x, y)))"

}

extend self[T: Order]: Array[T] {

    sort(): Unit {
        self.sortWith(Ordering.compare)
    }

}

extend self: Array[String] {

    join(separator: String = ""): String
        target js sync "return self_.array.join(separator_)"

}

instance Array[T: Show]: Show {
    show(value: Array[T]): String {
        let array = Array.new()
        array.push("[")
        value.each {x =>
            if(array.size() > 1) {array.push(", ")}
            array.push(Show.show(x))
        }
        array.push("].toArray()")
        array.join()
    }
}

sortRange[T](array: Array[T], compare: (T, T) => Ordering, start: Int, end: Int): Unit {
    if(end - start < 2) {} else:

    mutable middle = start + (end - start).div(2)
    sortRange(array, compare, start, middle)
    sortRange(array, compare, middle, end)

    mutable i = start
    mutable j = middle
    while {i < middle && j < end} {
        if(compare(array.grab(i), array.grab(j)) != OrderingAfter) {
            i += 1
        } else {
            let value = array.grab(j)
            mutable k = j
            while {k > i} {
                array.set(k, array.grab(k - 1))
                k -= 1
            }
            array.set(i, value)
            i += 1
            middle += 1
            j += 1
        }
    }
}

internalGrab[T](self: Array[T], index: Int): T
    target js sync """
        return index_ < 0 || index_ >= self_.array.length ? ff_core_Try.internalThrowGrabException_() : self_.array[index_];
    """
