type Array[T] {}

range(size: Int): Array[Int] { panic("magic") }
    javascript """
        return Array.from({length: size_}, (_, i) => i);
    """

build[A, B](initial: A, body: A => Option[Pair[A, B]]): Array[B] {
    let builder = ArrayBuilder.empty()
    function go(state: A): Unit {
        body(state).{
            | None =>
            | Some(Pair(s, x)) =>
                builder.add(x)
                tailcall go(s)
        }
    }
    go(initial)
    builder.drain()
}

fill[T](size: Int, value: T): Array[T] { panic("magic") }
    javascript """
        return new Array(size_).fill(value_);
    """

empty[T](): Array[T] { panic("magic") }
    javascript """
        return [];
    """

extend self[T]: Array[T] {

    addAll(that: Array[T]): Array[T] { panic("magic") }
        javascript "return self_.concat(that_)"

    isEmpty(): Bool { panic("magic") }
        javascript "return self_.length === 0"

    size(): Int { panic("magic") }
        javascript "return self_.length"

    expect(index: Int): T { panic("magic") }
        javascript """
            if(index_ < 0 || index_ >= self_.length) {
                throw new Error('Index ' + index_ + ' is out of bounds in an array of size ' + self_.length)
            }
            return self_[index_]
        """

    expectFirst(): T { self.expect(0) }

    expectLast(): T { self.expect(self.size() - 1) }

    dropFirst(count: Int = 1): Array[T] { panic("magic") }
        javascript "return self_.slice(count_)"

    dropLast(count: Int = 1): Array[T] { panic("magic") }
        javascript "return self_.slice(0, self_.length - count_)"

    update(index: Int, body: T => T): Array[T] { panic("magic") }
        javascript """
            let result = self_.slice();
            result[index_] = body_(result[index_]);
            return result;
        """
        javascriptasync """
            let result = self_.slice();
            result[index_] = await body_(result[index_], $signal);
            return result;
        """

    toList(): List[T] { panic("magic") }
        javascript """
            let result = ff_core_List.Empty();
            for(let i = self_.length - 1; i >= 0; i--) {
                result = ff_core_List.Link(self_[i], result);
            }
            return result;
        """

}

extend self: Array[String] {

    join(separator: String = ""): String { panic("magic") }
        javascript "return self_.join(separator_)"

}
