type Array[T] {}

empty[T](): Array[T]
    target js sync "return {array: []}"

extend self[T]: Array[T] {

    isEmpty(): Bool
        target js sync "return self_.array.length === 0"

    size(): Int
        target js sync "return self_.array.length"

    expect(index: Int): T
        target js sync """
            if(index_ < 0 || index_ >= self_.array.length) {
                throw new Error('Index ' + index_ + ' is out of bounds in an vector of size ' + self_.array.length)
            }
            return self_.array[index_]
        """

    expectFirst(): T { self.expect(0) }

    expectLast(): T { self.expect(self.size() - 1) }

    first(): Option[T]
        target js sync """
            return self_.array.length > 0
                ? ff_core_Option.Some(self_.array[0])
                : ff_core_Option.None()
        """

    last(): Option[T]
        target js sync """
            return self_.array.length > 0
                ? ff_core_Option.Some(self_.array[self_.array.length - 1])
                : ff_core_Option.None()
        """

    push(value: T): Unit
        target js sync "self_.array.push(value_)"

    pushAll(value: Array[T]): Unit
        target js sync "self_.array.push(...value_.array)"

    pushVector(value: Vector[T]): Unit
        target js sync "self_.array.push(...value_)"

    pop(): Option[T]
        target js sync """
            return self_.array.length > 0
                ? ff_core_Option.Some(self_.array.pop())
                : ff_core_Option.None()
        """

    set(index: Int, value: T): Unit
        target js sync "self_.array[index_] = body_(self_.array[index_])"

    modify(index: Int, body: T => T): Unit
        target js sync "self_.array[index_] = body_(self_.array[index_])"
        target js async "self_.array[index_] = await body_(self_.array[index_], $c)"

    each(body: T => Unit): Unit
        target js sync """
            return self_.array.forEach(body_);
        """
        target js async """
            for(let i = 0; i < self_.array.length; i++) {
                await body_(self_.array[i], $c)
            }
        """

    drain(): Vector[T]
        target js sync "const result = self_.array; self_.array = []; return result"

    toVector(): Vector[T]
        target js sync "return self_.array.slice()"

    toList(): List[T]
        target js sync """
            let result = ff_core_List.Empty();
            for(let i = self_.array.length - 1; i >= 0; i--) {
                result = ff_core_List.Link(self_.array[i], result);
            }
            return result;
        """

    sortBy(ordering: (T, T) => Ordering): Unit
        target js sync "self_.array.sort((x, y) => ff_core_Ordering.Ordering_toInt(ordering_(x, y)))"
        // TODO: Async version

}
