type Iterator![T](
    next: () => Option[T]
    close: () => Unit
)

make[T](next: () => Option[T], close: () => Unit = {}): Iterator[T] {
    Iterator(next, close)
}

extend self[T]: Iterator[T] {

    concat(that: Iterator[T]): Iterator[T] {
        mutable firstDone = False
        Iterator {
            if(firstDone) {
                that.next()
            } else {
                self.next().orElse {
                    firstDone = True
                    that.next()
                }
            }
        } {
            try {
                self.close()
            } finally {
                that.close()
            } expect()
        }
    }

    map[S](body: T => S): Iterator[S] {
        Iterator {
            self.next().map(body)
        } {
            self.close()
        }
    }

    flatMap[S](body: T => Iterator[S]): Iterator[S] {
        mutable inner = Iterator {None} {}
        Iterator {
            mutable result = None
            while {result.isEmpty()} {
                inner.next().{
                    | Some(_)@i => result = Some(i)
                    | None =>
                        self.next().{
                            | None => result = Some(None)
                            | Some(o) => inner = body(o)
                        }
                }
            }
            result.expect()
        } {
            try {
                inner.close()
            } finally {
                self.close()
            } expect()
        }
    }

    collect[S, C: ToIterator[S]](body: T => C): Iterator[S] {
        self.flatMap {Iterator.toIterator(body(_))}
    }

    filter(body: T => Bool): Iterator[T] {
        Iterator {
            mutable result = None
            while {result.isEmpty()} {
                self.next().{
                    | Some(x) {body(x)} => result = Some(Some(x))
                    | Some(_) =>
                    | None => result = Some(None)
                }
            }
            result.expect()
        } {
            self.close()
        }
    }

    zip[S](that: Iterator[S]): Iterator[Pair[T, S]] {
        Iterator {
            Pair(self.next(), that.next()).{
                | Pair(Some(x), Some(y)) => Some(Pair(x, y))
                | _ => None
            }
        } {
            try {
                self.close()
            } finally {
                that.close()
            } expect()
        }
    }

    takeFirst(count: Int = 1): Iterator[T] {
        mutable remaining = count
        Iterator {
            self.next().filter {_ =>
                remaining -= 1
                remaining >= 0
            }
        } {
            self.close()
        }
    }

    dropFirst(count: Int = 1): Iterator[T] {
        mutable remaining = count
        Iterator {
            while {remaining >= 1} {
                self.next().{
                    | None => remaining = 0
                    | Some(_) => remaining -= 1
                }
            }
            self.next()
        } {
            self.close()
        }
    }

    takeWhile(body: T => Bool): Iterator[T] {
        mutable done = False
        Iterator {
            if(done) {None} else:
            self.next().{
                | None =>
                    done = True
                    None
                | Some(x)@o =>
                    done = !body(x)
                    if(done) {None} else {o}
            }
        } {
            self.close()
        }
    }

    dropWhile(body: T => Bool): Iterator[T] {
        mutable done = False
        Iterator {
            if(!done) {
                mutable result = None
                while {!done} {
                    self.next().{
                        | None => done = True
                        | Some(x) {body(x)} =>
                        | Some(x)@o =>
                            result = o
                            done = True
                    }
                }
                result
            } else {
                self.next()
            }
        } {
            self.close()
        }
    }

    pairs(): Iterator[Pair[Int, T]] {
        mutable i = 0
        self.map {x =>
            let r = Pair(i, x)
            i += 1
            r
        }
    }

    chunked(size: Int): Iterator[List[T]] {
        mutable remaining = size
        Iterator {
            if(remaining <= 0) {None} else:
            self.next().{
                | None =>
                    remaining = -1
                    None
                | Some(x) =>
                    mutable list = [x]
                    remaining -= 1
                    while {remaining > 0} {
                        remaining -= 1
                        self.next().{
                            | None => remaining = -1
                            | Some(x) => list = [x, ...list]
                        }
                    }
                    if(remaining != -1) {remaining = size}
                    Some(list.reverse())
            }
        } {
            self.close()
        }
    }

    // Consuming methods

    use[R](body: Iterator[T] => R): R {
        try {
            body(self)
        } finally {
            self.close()
        } expect()
    }

    each(body: T => Unit): Unit {
        try {
            mutable done = False
            while {!done} {
                self.next().{
                    | None => done = True
                    | Some(x) => body(x)
                }
            }
        } finally {
            self.close()
        } expect()
    }

    eachWhile(body: T => Bool): Unit {
        try {
            mutable done = False
            while {!done} {
                self.next().{
                    | None => done = True
                    | Some(x) => done = !body(x)
                }
            }
        } finally {
            self.close()
        } expect()
    }

    all(body: T => Bool): Bool {
        mutable result = True
        self.eachWhile {x =>
            result = result && body(x)
            result
        }
        result
    }

    any(body: T => Bool): Bool {
        mutable result = False
        self.eachWhile {x =>
            result = result || body(x)
            (!result)
        }
        result
    }

    first(): Option[T] {
        try {
            self.next()
        } finally {
            self.close()
        } expect()
    }

    last(): Option[T] {
        try {
            mutable done = False
            mutable result = None
            while {!done} {
                self.next().{
                    | None => done = True
                    | Some(x)@o => result = o
                }
            }
            result
        } finally {
            self.close()
        } expect()
    }

    expectFirst(): T {
        self.first().else { panic("expectFirst() on empty iterator") }
    }

    expectLast(): T {
        self.last().else { panic("expectLast() on empty iterator") }
    }

    collectFirst[R](body: T => Option[R]): Option[R] {
        try {
            mutable done = False
            mutable result = None
            while {!done} {
                self.next().{
                    | None => done = True
                    | Some(x) =>
                        body(x).{
                            | None =>
                            | o =>
                                done = True
                                result = o
                        }
                }
            }
            result
        } finally {
            self.close()
        } expect()
    }

    find(body: T => Bool): Option[T] {
        self.filter(body).first()
    }

    foldLeft[R](initial: R, body: (R, T) => R): R {
        mutable result = initial
        self.each {result = body(result, _)}
        result
    }

    toArray(): Array[T] {
        let builder = ArrayBuilder.empty()
        self.each(builder.add)
        builder.toArray()
    }

    toList(): List[T] {
        self.toArray().toList()
    }

    toCollection[C: FromIterator[T]](): C {
        Iterator.fromIterator(self)
    }

}

extend self[T]: Iterator[Iterator[T]] {
    flatten(): Iterator[T] {
        self.flatMap {_}
    }
}

extend self[T: Order]: Iterator[T] {
    toSet(): Set[T] {
        self.toArray().toSet()
    }
}

extend self[K: Order, V]: Iterator[Pair[K, V]] {
    toMap(): Map[K, V] {
        self.toArray().toMap()
    }
}

extend self: Iterator[Buffer] {

    toBuffer(): Buffer {
        let builder = ArrayBuilder.empty()
        self.each(builder.add)
        Buffer.fromBufferArray(builder.toArray())
    }

    toString(encoding: String = "utf8"): String {
        self.toBuffer().toString(encoding)
    }

}



trait C: FromIterator[T] {
    fromIterator(iterator: Iterator[T]): C
}

trait C: ToIterator[T] {
    toIterator(collection: C): Iterator[T]
}

instance Array[T]: FromIterator[T] {
    fromIterator(iterator: Iterator[T]): Array[T] {
        iterator.toArray()
    }
}

instance Array[T]: ToIterator[T] {
    toIterator(collection: Array[T]): Iterator[T] {
        collection.toIterator()
    }
}

instance List[T]: FromIterator[T] {
    fromIterator(iterator: Iterator[T]): List[T] {
        iterator.toList()
    }
}

instance List[T]: ToIterator[T] {
    toIterator(collection: List[T]): Iterator[T] {
        collection.toIterator()
    }
}

instance Set[T: Order]: FromIterator[T] {
    fromIterator(iterator: Iterator[T]): Set[T] {
        iterator.toSet()
    }
}

instance Set[T: Order]: ToIterator[T] {
    toIterator(collection: Set[T]): Iterator[T] {
        collection.toIterator()
    }
}

instance Map[K: Order, V]: FromIterator[Pair[K, V]] {
    fromIterator(iterator: Iterator[Pair[K, V]]): Map[K, V] {
        iterator.toMap()
    }
}

instance Map[K: Order, V]: ToIterator[Pair[K, V]] {
    toIterator(collection: Map[K, V]): Iterator[Pair[K, V]] {
        collection.toIterator()
    }
}

instance Option[T]: ToIterator[T] {
    toIterator(collection: Option[T]): Iterator[T] {
        collection.toIterator()
    }
}

instance Pair[T, T]: ToIterator[T] {
    toIterator(collection: Pair[T, T]): Iterator[T] {
        [collection.first, collection.second].toIterator()
    }
}
