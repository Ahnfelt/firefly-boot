type List[T] {
    Empty
    Link(head: T, tail: List[T])
}

extend self[T]: List[T] {

    append(list: List[T]) : List[T] { // TODO: Delete
        [self, list].flatten()
    }

    addAll(list: List[T]) : List[T] {
        [self, list].flatten()
    }

    toArray(): Array[T] { panic("magic") }
        javascript """
            let current = self_;
            let result = [];
            while(current.Link) {
                result.push(current.head_);
                current = current.tail_;
            }
            return result;
        """

    toSet(): Set[T] {
        (self.foldLeft(Set.empty[T]())) { set, value => set.add(value) }
    }

    expect(index: Int): T {
        function go(list: List[T], i: Int): T {
            list.{
                | Empty => panic("expect(" + index + ") on list of size " + self.size())
                | Link(head, _) {i == 0} => head
                | Link(_, tail) => tailcall go(tail, i - 1)
            }
        }
        go(self, index)
    }

    first(): Option[T] {
        self.{
            | Empty => None
            | Link(head, _) => Some(head)
        }
    }

    last(): Option[T] {
        self.{
            | Empty => None
            | Link(head, Empty) => Some(head)
            | Link(_, tail) => tailcall tail.last()
        }
    }

    expectFirst(): T {
        self.first().else { panic("expectFirst() on empty list") }
    }

    expectLast(): T {
        self.last().else { panic("expectLast() on empty list") }
    }

    dropFirst(count: Int = 1): List[T] {
        self.{
            | _ {count <= 0} => self
            | [] => self
            | [_, ...tail] => tailcall tail.dropFirst(count - 1)
        }
    }

    dropLast(count: Int = 1): List[T] {
        self.reverse().dropFirst(count).reverse()
    }

    takeFirst(count: Int = 1): List[T] {
        function go(list: List[T], count: Int, result: List[T]): List[T] {
            list.{
                | _ {count <= 0} => result.reverse()
                | [] => result.reverse()
                | [head, ...tail] => tailcall go(tail, count - 1, [head, ...result])
            }
        }
        go(self, count, [])
    }

    takeLast(count: Int = 1): List[T] {
        self.reverse().takeFirst(count).reverse()
    }

    pairs(): List[Pair[Int, T]] {
        mutable i = 0
        self.map {x =>
            let r = Pair(i, x)
            i += 1
            r
        }
    }

    slice(from: Int, until: Int): List[T] {
        self.dropFirst(from).takeFirst(until - from)
    }

    isEmpty(): Bool {
        self.{
            | [] => True
            | _ => False
        }
    }

    size(): Int {
        function go(list: List[T], result: Int): Int {
            list.{
                | [] => result
                | [_, ...tail] => tailcall go(tail, result + 1)
            }
        }
        go(self, 0)
    }

    each(body: T => Unit): Unit {
        self.{
            | [] =>
            | [head, ...tail] =>
                body(head)
                tailcall tail.each(body)
        }
    }

    all(body: T => Bool): Bool {
        self.{
            | [] => True
            | [head, ..._] {!body(head)} => False
            | [_, ...tail] => tailcall tail.all(body)
        }
    }

    any(body: T => Bool): Bool {
        self.{
            | [] => False
            | [head, ..._] {body(head)} => True
            | [_, ...tail] => tailcall tail.any(body)
        }
    }

    find(body: T => Bool): Option[T] {
        self.{
            | [] => None
            | [head, ..._] {body(head)} => Some(head)
            | [_, ...tail] => tailcall tail.find(body)
        }
    }

    filter(body: T => Bool): List[T] {
        function go(list: List[T], result: List[T]): List[T] {
            list.{
                | [] =>
                    result.reverse()
                | [head, ...tail] { body(head) } =>
                    tailcall go(tail, [head, ...result])
                | [_, ...tail] =>
                    tailcall go(tail, result)
            }
        }
        go(self, [])
    }

    map[R](body: T => R): List[R] {
        function go(list: List[T], result: List[R]): List[R] {
            list.{
                | [] =>
                    result.reverse()
                | [head, ...tail] =>
                    tailcall go(tail, [body(head), ...result])
            }
        }
        go(self, [])
    }

    flatMap[R](body: T => List[R]): List[R] {
        function go(list: List[T], result: List[List[R]]): List[R] {
            list.{
                | [] =>
                    result.reverse().flatten()
                | [head, ...tail] =>
                    tailcall go(tail, [body(head), ...result])
            }
        }
        go(self, [])
    }

    collect[R](body: T => Option[R]): List[R] {
        function go(list: List[T], result: List[R]): List[R] {
            list.{
                | [] =>
                    result.reverse()
                | [head, ...tail] =>
                    body(head).{
                        | None => tailcall go(tail, result)
                        | Some(value) => tailcall go(tail, [value, ...result])
                    }
            }
        }
        go(self, [])
    }

    collectFirst[R](body: T => Option[R]): Option[R] {
        self.{
            | [] =>
                None
            | [head, ...tail] =>
                body(head).{
                    | None => tailcall tail.collectFirst(body)
                    | Some(value) => Some(value)
                }
        }
    }

    foldLeft[R](initial: R): ((R, T) => R) => R {
        {body =>
            function go(state: R, list: List[T]): R {
                list.{
                    | [] =>
                        state
                    | [head, ...tail] =>
                        tailcall go(body(state, head), tail)
                }
            }
            go(initial, self)
        }
    }

    updated(index: Int, value: T): List[T] {
        function go(list: List[T], i: Int, result: List[T]): List[T] {
            list.{
                | [] =>
                    result.reverse()
                | [head, ...tail] {i == 0} =>
                    tailcall go(tail, i - 1, [value, ...result])
                | [head, ...tail] =>
                    tailcall go(tail, i - 1, [head, ...result])
            }
        }
        go(self, index, [])
    }

    modify(index: Int, body: T => T): List[T] {
        function go(list: List[T], i: Int, result: List[T]): List[T] {
            list.{
                | [] =>
                    result.reverse()
                | [head, ...tail] {i == 0} =>
                    tailcall go(tail, i - 1, [body(head), ...result])
                | [head, ...tail] =>
                    tailcall go(tail, i - 1, [head, ...result])
            }
        }
        go(self, index, [])
    }

    zip[S](that: List[S]): List[Pair[T, S]] {
        function go(list1: List[T], list2: List[S], result: List[Pair[T, S]]): List[Pair[T, S]] {
            Pair(list1, list2).{
                | Pair([x, ...xs], [y, ...ys]) =>
                    tailcall go(xs, ys, [Pair(x, y), ...result])
                | _ =>
                    reverseList(result)
            }
        }
        go(self, that, [])
    }

    sortBy(body: T => String): List[T] { // TODO generalize to non-strings
        if(self.size() <= 1) {self} else:

        function divide(list: List[T], xs: List[T], ys: List[T]): Pair[List[T], List[T]] {
            list.{
                | [] => Pair(xs, ys)
                | [x] => Pair([x, ...xs], ys)
                | [x, y, ...tail] => tailcall divide(tail, [x, ...xs], [y, ...ys])
            }
        }
        function merge(xs: List[T], ys: List[T], result: List[T]): List[T] {
            Pair(xs, ys).{
                | Pair([x, ...xs2], [y, ..._]) {body(x) < body(y)} => tailcall merge(xs2, ys, [x, ...result])
                | Pair([x, ..._], [y, ...ys2]) => tailcall merge(xs, ys2, [y, ...result])
                | Pair([x, ...xs2], []) => tailcall merge(xs2, [], [x, ...result])
                | Pair([], [y, ...ys2]) => tailcall merge([], ys2, [y, ...result])
                | Pair([], []) => result.reverse()
            }
        }
        let pair = divide(self, [], [])
        merge(pair.first.sortBy(body), pair.second.sortBy(body), [])
    }

    reverse(): List[T] {
        reverseList(self)
    }
}

extend self[T]: List[List[T]] {

    flatten(): List[T] {
        function finish(list: List[T], result: List[T]): List[T] {
            | as, [] => as
            | as, [x, ...xs] => tailcall finish([x, ...as], xs)
        }
        function go(lists: List[List[T]], result: List[T]): List[T] {
            lists.{
                | [] => []
                | [as] => finish(as, result)
                | [[], ...aas] => tailcall go(aas, result)
                | [[a, ...as], ...aas] => tailcall go(Link(as, aas), [a, ...result])
            }
        }
        go(self, [])
    }

}

extend self[K, V]: List[Pair[K, V]] {

    toMap(): Map[K, V] {
        (self.foldLeft(Map.empty[K, V]())) { map, pair => map.add(pair.first, pair.second) }
    }

    group(): Map[K, List[V]] {
        groupList(self)
    }

    unzip(): Pair[List[K], List[V]] {
        function go(pairs: List[Pair[K, V]], ks: List[K], vs: List[V]): Pair[List[K], List[V]] {
            pairs.{
                | [] =>
                    Pair(ks.reverse(), vs.reverse())
                | [Pair(k, v), ...tail] =>
                    tailcall go(tail, [k, ...ks], [v, ...vs])
            }
        }
        go(self, [], [])
    }

}

extend self: List[String] {

    join(separator: String = ""): String { self.toArray().join(separator) }

}

reverseList[T](list: List[T]): List[T] { // Hack to work around Scala/IDEA inference bug

    function go(list: List[T], result: List[T]): List[T] {
        list.{
            | [] =>
                result
            | [head, ...tail] =>
                tailcall go(tail, [head, ...result])
        }
    }
    go(list, [])

}

groupList[K, V](list : List[Pair[K, V]]): Map[K, List[V]] { // Hack to work around Scala/IDEA inference bug
    let initial: List[Pair[K, List[V]]] = []
    (list.foldLeft(initial.toMap())) { map, pair => map.addToList(pair.first, panic("pair.second")) }
}
