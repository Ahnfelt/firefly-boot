type Stream![T](
    next: () => Option[T]
    close: () => Unit
)

make[T](next: () => Option[T], close: () => Unit = {}): Stream[T] {
    Stream(next, close)
}

extend self[T]: Stream[T] {

    concat(that: Stream[T]): Stream[T] {
        mutable firstDone = False
        Stream {
            if(firstDone) {
                that.next()
            } else {
                self.next().orElse {
                    firstDone = True
                    that.next()
                }
            }
        } {
            Try.finally {
                self.close()
            } {
                that.close()
            }
        }
    }

    map[S](body: T => S): Stream[S] {
        Stream {
            self.next().map(body)
        } {
            self.close()
        }
    }

    flatMap[S](body: T => Stream[S]): Stream[S] {
        mutable inner = Stream {None} {}
        Stream {
            mutable result = None
            while {result.isEmpty()} {
                inner.next().{
                    | Some(_)@i => result = Some(i)
                    | None =>
                        self.next().{
                            | None => result = Some(None)
                            | Some(o) => inner = body(o)
                        }
                }
            }
            result.grab()
        } {
            Try.finally {
                inner.close()
            } {
                self.close()
            }
        }
    }

    collect[S](body: T => Option[S]): Stream[S] {
        self.flatMap {body(_).toStream()}
    }

    filter(body: T => Bool): Stream[T] {
        Stream {
            mutable result = None
            while {result.isEmpty()} {
                self.next().{
                    | Some(x) {body(x)} => result = Some(Some(x))
                    | Some(_) =>
                    | None => result = Some(None)
                }
            }
            result.grab()
        } {
            self.close()
        }
    }

    zip[S](that: Stream[S]): Stream[Pair[T, S]] {
        Stream {
            Pair(self.next(), that.next()).{
                | Pair(Some(x), Some(y)) => Some(Pair(x, y))
                | _ => None
            }
        } {
            Try.finally {
                self.close()
            } {
                that.close()
            }
        }
    }

    takeFirst(count: Int = 1): Stream[T] {
        mutable remaining = count
        Stream {
            self.next().filter {_ =>
                remaining -= 1
                remaining >= 0
            }
        } {
            self.close()
        }
    }

    dropFirst(count: Int = 1): Stream[T] {
        mutable remaining = count
        Stream {
            while {remaining >= 1} {
                self.next().{
                    | None => remaining = 0
                    | Some(_) => remaining -= 1
                }
            }
            self.next()
        } {
            self.close()
        }
    }

    takeWhile(body: T => Bool): Stream[T] {
        mutable done = False
        Stream {
            if(done) {None} else:
            self.next().{
                | None =>
                    done = True
                    None
                | Some(x)@o =>
                    done = !body(x)
                    if(done) {None} else {o}
            }
        } {
            self.close()
        }
    }

    dropWhile(body: T => Bool): Stream[T] {
        mutable done = False
        Stream {
            if(!done) {
                mutable result = None
                while {!done} {
                    self.next().{
                        | None => done = True
                        | Some(x) {body(x)} =>
                        | Some(x)@o =>
                            result = o
                            done = True
                    }
                }
                result
            } else {
                self.next()
            }
        } {
            self.close()
        }
    }

    pairs(): Stream[Pair[Int, T]] {
        mutable i = 0
        self.map {x =>
            let r = Pair(i, x)
            i += 1
            r
        }
    }

    chunked(size: Int): Stream[List[T]] {
        mutable remaining = size
        Stream {
            if(remaining <= 0) {None} else:
            self.next().{
                | None =>
                    remaining = -1
                    None
                | Some(x) =>
                    mutable list = [x]
                    remaining -= 1
                    while {remaining > 0} {
                        remaining -= 1
                        self.next().{
                            | None => remaining = -1
                            | Some(x) => list = [x, ...list]
                        }
                    }
                    if(remaining != -1) {remaining = size}
                    Some(list.reverse())
            }
        } {
            self.close()
        }
    }

    // Consuming methods

    use[R](body: Stream[T] => R): R {
        Try.finally {
            body(self)
        } {
            self.close()
        }
    }

    each(body: T => Unit): Unit {
        Try.finally {
            mutable done = False
            while {!done} {
                self.next().{
                    | None => done = True
                    | Some(x) => body(x)
                }
            }
        } {
            self.close()
        }
    }

    eachWhile(body: T => Bool): Unit {
        Try.finally {
            mutable done = False
            while {!done} {
                self.next().{
                    | None => done = True
                    | Some(x) => done = !body(x)
                }
            }
        } {
            self.close()
        }
    }

    all(body: T => Bool): Bool {
        mutable result = True
        self.eachWhile {x =>
            result = result && body(x)
            result
        }
        result
    }

    any(body: T => Bool): Bool {
        mutable result = False
        self.eachWhile {x =>
            result = result || body(x)
            (!result)
        }
        result
    }

    first(): Option[T] {
        Try.finally {
            self.next()
        } {
            self.close()
        }
    }

    last(): Option[T] {
        Try.finally {
            mutable done = False
            mutable result = None
            while {!done} {
                self.next().{
                    | None => done = True
                    | Some(x)@o => result = o
                }
            }
            result
        } {
            self.close()
        }
    }

    grabFirst(): T {
        self.first().else { panic("grabFirst() on empty iterator") }
    }

    grabLast(): T {
        self.last().else { panic("grabLast() on empty iterator") }
    }

    collectFirst[R](body: T => Option[R]): Option[R] {
        Try.finally {
            mutable done = False
            mutable result = None
            while {!done} {
                self.next().{
                    | None => done = True
                    | Some(x) =>
                        body(x).{
                            | None =>
                            | o =>
                                done = True
                                result = o
                        }
                }
            }
            result
        } {
            self.close()
        }
    }

    find(body: T => Bool): Option[T] {
        self.filter(body).first()
    }

    foldLeft[R](initial: R, body: (R, T) => R): R {
        mutable result = initial
        self.each {result = body(result, _)}
        result
    }

    toStack(): Stack[T] {
        let stack = Stack.make()
        self.each(stack.push)
        stack
    }

    toArray(): Array[T] {
        self.toStack().drain()
    }

    toList(): List[T] {
        self.toStack().toList()
    }

}

extend self[T]: Stream[Stream[T]] {
    flatten(): Stream[T] {
        self.flatMap {_}
    }
}

extend self[T: Order]: Stream[T] {
    toSet(): Set[T] {
        self.toArray().toSet()
    }
}

extend self[K: Order, V]: Stream[Pair[K, V]] {
    toMap(): Map[K, V] {
        self.toArray().toMap()
    }
}

extend self: Stream[Buffer] {

    toBuffer(): Buffer {
        let builder = Stack.make()
        self.each(builder.push)
        Buffer.fromBufferArray(builder.drain())
    }

    toString(encoding: String = "utf8"): String {
        self.toBuffer().toString(encoding)
    }

}
