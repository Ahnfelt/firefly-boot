data Json {}

read(json: String): Option[Json]
    target js sync """
        try {
            return ff_core_Option.Some(JSON.parse(json_));
        } catch(e) {
            return ff_core_Option.None();
        }
    """

string(json: String): Json
    target js sync """
        return json_;
    """

int(json: Int): Json
    target js sync """
        return json_;
    """

float(json: Float): Json
    target js sync """
        return json_;
    """

bool(json: Bool): Json
    target js sync """
        return json_;
    """

null(): Json
    target js sync """
        return null;
    """

array(json: Array[Json]): Json
    target js sync """
        return json_;
    """

list(json: List[Json]): Json {
    array(json.toArray())
}

object(): Json
    target js sync """
        return {};
    """

fields(body: ((String, Json) => Unit) => Unit): Json
    target js sync """
        const result = {};
        body_((k, v) => {result[k] = v});
        return result;
    """
    target js async """
        const result = {};
        await body_((k, v) => {result[k] = v}, $task);
        return result;
    """

extend self: Json {
    
    write(space: Option[String] = None): String
        target js sync """
            return JSON.stringify(self_, null, space_.value_);
        """

    with[T: JsonLike](field: String, value: T): Json {
        internalWith(field, toJson(value))
    }
        
    merge(that: Json): Json
        target js sync """
            if(typeof self_ !== 'object' || self_ === null || Array.isArray(self_)) {
                throw new Error('Not an object: ' + JSON.stringify(self_));
            }
            if(typeof that_ !== 'object' || that_ === null || Array.isArray(that_)) {
                throw new Error('Not an object: ' + JSON.stringify(that_));
            }
            return {...self_, ...that_};
        """

    grabString(): String
        target js sync """
            if(typeof self_ !== 'string') throw new Error('Not a string: ' + JSON.stringify(self_));
            return self_;
        """

    grabInt(): Int
        target js sync """
            if(!Number.isSafeInteger(self_)) throw new Error('Not an int: ' + JSON.stringify(self_));
            return Math.trunc(self_);
        """

    grabFloat(): Float
        target js sync """
            if(typeof self_ !== 'number') throw new Error('Not a float: ' + JSON.stringify(self_));
            return self_;
        """

    grabBool(): Bool
        target js sync """
            if(self_ === true) return true;
            if(self_ === false) return false;
            throw new Error('Not a bool: ' + JSON.stringify(self_));
        """

    grabArray(): Array[Json]
        target js sync """
            if(!Array.isArray(self_)) throw new Error('Not an array: ' + JSON.stringify(self_));
            return self_;
        """
        
    grabMap(): Map[String, Json] {
        mutable map = Map.empty()
        self.each {key, value => 
            map = map.add(key, value)
        }
        map
    }

    getString(): Option[String] {
        if(self.isString()) {self.grabString()}
    }

    getInt(): Option[Int] {
        if(self.isInt()) {self.grabInt()}
    }

    getFloat(): Option[Float] {
        if(self.isFloat()) {self.grabFloat()}
    }

    getBool(): Option[Bool] {
        if(self.isBool()) {self.grabBool()}
    }

    getArray(): Option[Array[Json]] {
        if(self.isArray()) {self.grabArray()}
    }

    getMap(): Option[Map[String, Json]] {
        if(self.isObject()) {self.grabMap()}
    }

    isString(): Bool
        target js sync """
            return typeof self_ === 'string';
        """

    isInt(): Bool
        target js sync """
            return Number.isSafeInteger(self_);
        """

    isFloat(): Bool
        target js sync """
            return typeof self_ === 'number';
        """

    isBool(): Bool
        target js sync """
            return typeof self_ === 'boolean';
        """

    isArray(): Bool
        target js sync """
            return Array.isArray(self_);
        """

    isObject(): Bool
        target js sync """
            return typeof self_ === 'object' && self_ !== null && !Array.isArray(self_);
        """

    isNull(): Bool
        target js sync """
            return typeof self_ === null;
        """

    field(key: String): Json
        target js sync """
            return typeof self_ === 'object' && self_ !== null && !Array.isArray(self_) && Object.hasOwn(self_, key_)
                ? self_[key_] : null;
        """

    index(key: Int): Json
        target js sync """
            return typeof self_ === 'array' ? self_[key] ?? null : null;
        """

    hasField(key: String): Bool
        target js sync """
            return typeof self_ === 'object' && self_ !== null && !Array.isArray(self_) && Object.hasOwn(self_, key_);
        """

    getField(key: String): Option[Json]
        target js sync """
            return typeof self_ === 'object' && self_ !== null && !Array.isArray(self_) && Object.hasOwn(self_, key_)
                ? ff_core_Option.Some(self_[key_]) : ff_core_Option.None();
        """

    getIndex(key: Int): Option[Json]
        target js sync """
            return typeof self_ === 'array' ? ff_core_Option.Some(self_[key_] ?? null) : ff_core_Option.None();
        """
        
    getFields(): Option[Array[String]]
        target js sync """
            return typeof self_ === 'object' && self_ !== null && !Array.isArray(self_)
                ? ff_core_Option.Some(Object.keys(self_)) : ff_core_Option.None();
        """

    grabField(key: String): Json {
        self.getField(key).else {
            throw(GrabException())
        }
    }

    grabIndex(key: Int): Json {
        self.getIndex(key).else {
            throw(GrabException())
        }
    }
    
    grabFields(): Array[String] {
        self.getFields().else {
            throw(GrabException())
        }
    }

    map[T](body: (String, Json) => T): Array[T] {
        let stack = Stack.make()
        self.each {field, value => stack.push(body(field, value))}
        stack.drain()
    }

    flatMap[T](body: (String, Json) => Array[T]): Array[T] {
        let stack = Stack.make()
        self.each {field, value => stack.pushArray(body(field, value))}
        stack.drain()
    }
    
    each(body: (String, Json) => Unit) {
        if(!self.isObject()) {throw(GrabException())}
        internalEach(self, body)
    }

    eachWhile(body: (String, Json) => Bool) {
        if(!self.isObject()) {throw(GrabException())}
        internalEachWhile(self, body)
    }

}

internalWith(field: String, json: Json): Json
    target js sync """
        if(typeof self_ !== 'object' || self_ === null || Array.isArray(self_)) {
            throw new Error('Not an object: ' + JSON.stringify(self_));
        }
        return {...self_, [field_]: value_};
    """

internalEach(self: Json, body: (String, Json) => Unit): Unit
    target js sync "for(const [key, value] of Object.entries(self_)) body_(key, value)"
    target js async "for(const [key, value] of Object.entries(self_)) await body_(key, value, $task)"

internalEachWhile(self: Json, body: (String, Json) => Bool): Unit
    target js sync "for(const [key, value] of Object.entries(self_)) if(!body_(key, value)) break"
    target js async "for(const [key, value] of Object.entries(self_)) if(!await body_(key, value, $task)) break"

trait T: JsonLike {
    toJson(value: T): Json
    fromJson(json: Json): Option[T]
}

instance Json: JsonLike {
    toJson(value: Json): Json {value}
    fromJson(json: Json): Option[Json] {Some(json)}
}

instance String: JsonLike {
    toJson(value: String): Json {string(value)}
    fromJson(json: Json): Option[String] {_.getString()}
}

instance Int: JsonLike {
    toJson(value: Int): Json {int(value)}
    fromJson(json: Json): Option[Int] {_.getInt()}
}

instance Float: JsonLike {
    toJson(value: Float): Json {float(value)}
    fromJson(json: Json): Option[Float] {_.getFloat()}
}

instance Bool: JsonLike {
    toJson(value: Bool): Json {bool(value)}
    fromJson(json: Json): Option[Bool] {_.getBool()}
}

instance Array[T: JsonLike]: JsonLike {
    toJson(value: Array[T]): Json {array(value.map(toJson))}
    fromJson(json: Json): Option[Array[T]] {
        json.getArray().flatMap {array => 
            mutable convertible = True
            let stack = Stack.make()
            array.eachWhile {item =>
                fromJson(item).{
                    | None => convertible = False
                    | Some(value) => stack.push(value)
                }
                convertible
            }
            if(convertible) {stack.drain()}
        }
    }
}

instance List[T: JsonLike]: JsonLike {
    toJson(value: List[T]): Json {list(value.map(toJson))}
    fromJson(json: Json): Option[List[T]] {fromJson[Array[T]](json).map {_.toList()}}
}
