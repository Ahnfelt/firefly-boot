import Token

tokenize(file: String, code: String): Array[Token] {

    let tokens = Stack.empty[Token]()
    mutable line = 1
    mutable lineOffset = 0

    mutable startLine = line
    mutable startLineOffset = lineOffset

    let operatorCharactersString = "!@#$%&/=?+|^~*<>.:-,;"
    mutable operatorCharacters = Set.empty[Char]()
    List.range(operatorCharactersString.size()).map { j =>
        operatorCharacters = operatorCharacters.add(operatorCharactersString.expect(j))
    }

    function emitToken(kind: TokenKind, startOffset: Int, stopOffset: Int): Unit {
        if(!tokens.isEmpty()) {
            let last = tokens.expectLast()
            if(last.stopLine == startLine && last.kind == LLower && kind.afterKeyword()) {
                tokens.modify(tokens.size() - 1) {_.Token(kind = LKeyword)}
            }
            if(last.stopLine != startLine && last.kind.beforeSeparator() && kind.afterSeparator()) {
                tokens.push(Token(
                    file, code, LSeparator,
                    startLine, startLineOffset, startOffset,
                    startLine, startLineOffset, startOffset
                ))
            }
        }
        tokens.push(Token(
            file, code, kind, startLine, startLineOffset, startOffset, line, lineOffset, stopOffset
        ))
    }

    mutable i = 0
    while { i < code.size() } {

        while { i < code.size() && (code.expect(i) == ' ' || code.expect(i) == '\t' || code.expect(i) == '\r') } { i += 1 }

        let start = i
        startLine = line
        startLineOffset = lineOffset

        if(code.expect(i) == '\n') {

            i += 1
            line += 1
            lineOffset = i

        } elseIf { code.expect(i) == '/' && code.expect(i + 1) == '/' } {

            i += 2
            while { i < code.size() && code.expect(i) != '\n' } { i += 1 }

        } elseIf { code.expect(i) == '/' && code.expect(i + 1) == '*' } {

            i += 2
            while { i < code.size() && (code.expect(i) != '*' || code.expect(i + 1) != '/') } {
                if(i >= code.size()) {
                    panic(
                        "Expected end of comment started on line " + startLine + ", got end of file."
                    )
                }
                if(code.expect(i) == '\n') {
                    line += 1
                    lineOffset = i + 1
                }
                i += 1
            }
            i += 2

        } elseIf { code.expect(i) == '"' || code.expect(i) == '\'' } {

            let endSign = code.expect(i)

            mutable multiLine = i + 2 < code.size() &&
                code.expect(i) == '"' && code.expect(i + 1) == '"' && code.expect(i + 2) == '"'

            i += if(multiLine) {3} else {1}
            while {i < code.size() && (multiLine || code.expect(i) != endSign)} {
                if(code.expect(i) == '\n') {
                    if(multiLine) {
                        line += 1
                        lineOffset = i + 1
                    } else {
                        panic(
                            "Unexpected end of line in string started on line " + startLine + "."
                        )
                    }
                }
                if(i >= code.size()) {
                    panic(
                        "Expected end of string started on line " + startLine + ", got end of file."
                    )
                }
                if(code.expect(i) == '\\' && code.expect(i + 1) != '\n') {i += 1}
                if(multiLine &&
                    i + 2 < code.size() && (i + 3 >= code.size() || code.expect(i + 3) != '"') &&
                    code.expect(i) == '"' && code.expect(i + 1) == '"' && code.expect(i + 2) == '"'
                ) {
                    multiLine = False
                    i += 2
                } else {
                    i += 1
                }
            }
            i += 1
            emitToken(if(endSign == '"') {LString} else {LChar}, start, i)

        } elseIf { code.expect(i).isAsciiLetter() } {

            let kind = if(code.expect(i) >= 'a') {LLower} else {LUpper}
            i += 1
            while {i < code.size() && code.expect(i).isAsciiLetterOrDigit()} { i += 1 }
            if(kind == LUpper && code.expect(i) == '.') {
                i += 1
                emitToken(LNamespace, start, i)
            } else {
                emitToken(kind, start, i)
            }

        } elseIf { code.expect(i).isAsciiDigit() } {

            mutable dot = False
            mutable exponent = False
            while { i < code.size() && code.expect(i).isAsciiDigit() } {
                i += 1
                if((code.expect(i) == 'e' || code.expect(i) == 'E') && !exponent) {
                    i += 1
                    dot = True
                    exponent = True
                    if(code.expect(i) == '+' || code.expect(i) == '-') {i += 1}
                }
                if(
                    i + 1 < code.size() && code.expect(i) == '.' &&
                    code.expect(i + 1).isAsciiDigit() &&
                    !dot && !exponent
                ) {
                    i += 1
                    dot = True
                }
            }
            emitToken(if(dot || exponent) {LFloat} else {LInt}, start, i)

        } elseIf { code.expect(i) == '_' } {

            i += 1
            emitToken(LWildcard, start, i)

        } elseIf { operatorCharacters.contains(code.expect(i)) } {

            i += 1
            while { i < code.size() && operatorCharacters.contains(code.expect(i)) } {i += 1}
            let o =
                if(i - start == 1 && code.expect(i - 1) == '.') {
                    LDot
                } elseIf {i - start == 1 && code.expect(i - 1) == ','} {
                    LComma
                } elseIf {i - start == 1 && code.expect(i - 1) == ';'} {
                    LSemicolon
                } elseIf {i - start == 1 && code.expect(i - 1) == '|'} {
                    LPipe
                } elseIf {i - start == 1 && code.expect(i - 1) == ':'} {
                    LColon
                } elseIf {i - start == 3 && code.expect(i - 3) == '.' && code.expect(i - 2) == '.' && code.expect(i - 1) == '.'} {
                    LDotDotDot
                } elseIf {i - start == 2 && code.expect(i - 2) == '=' && code.expect(i - 1) == '>'} {
                    LArrowThick
                } elseIf {i - start == 1 && code.expect(i - 1) == '='} {
                    LAssign
                } elseIf {i - start == 2 && code.expect(i - 2) == '+' && code.expect(i - 1) == '='} {
                    LAssignPlus
                } elseIf {i - start == 2 && code.expect(i - 2) == '-' && code.expect(i - 1) == '='} {
                    LAssignMinus
                } elseIf {i - start == 3 && code.expect(i - 3) == ':' && code.expect(i - 2) == ':' && code.expect(i - 1) == '='} {
                    LAssignLink
                } else {
                    LOperator
                }
            emitToken(o, start, i)

        } elseIf {
            code.expect(i) == '(' || code.expect(i) == '[' || code.expect(i) == '{'
        } {
            i += 1
            emitToken(LBracketLeft, start, i)

        } elseIf {
            code.expect(i) == ')' || code.expect(i) == ']' || code.expect(i) == '}'
        } {

            i += 1
            emitToken(LBracketRight, start, i)

        } elseIf {
            i < code.size()
        } {

            let column = (i - startLineOffset) + 1
            panic("Unexpected character: " + Show.show(code.expect(i)) + " in " + file + " at line " + line + ", column " + column)

        }

    }

    List.range(5).each {_ => emitToken(LEnd, i, i) }

    tokens.drain()

}
