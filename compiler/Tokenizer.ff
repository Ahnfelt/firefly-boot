import Token
import Syntax

tokenize(file: String, code: String, completionAt: Option[Location]): Array[Token] {

    let completionLine = completionAt.filter {_.file == file}.map {_.line}.else {-1}
    let completionColumn = completionAt.filter {_.file == file}.map {_.column}.else {-1}

    let tokens = Stack.make[Token]()
    mutable line = 1
    mutable lineOffset = 0

    mutable startLine = line
    mutable startLineOffset = lineOffset

    let operatorCharactersString = "!@#$%&/=?+|^~*<>.:-,;"
    mutable operatorCharacters = Set.empty[Char]()
    List.range(operatorCharactersString.size()).map {j =>
        operatorCharacters = operatorCharacters.add(operatorCharactersString.grab(j))
    }

    function emitToken(kind: TokenKind, startOffset: Int, stopOffset: Int): Unit {
        if(!tokens.isEmpty()) {
            let last = tokens.grabLast()
            if(last.stopLine == startLine && last.kind == LLower && kind.afterKeyword()) {
                tokens.modify(tokens.size() - 1) {_.Token(kind = LKeyword)}
            }
            if(last.stopLine != startLine && last.kind.beforeSeparator() && kind.afterSeparator()) {
                tokens.push(Token(
                    file, code, LSeparator
                    startLine, startLineOffset, startOffset
                    startLine, startLineOffset, startOffset
                ))
            }
        }
        tokens.push(Token(
            file, code, kind, startLine, startLineOffset, startOffset, line, lineOffset, stopOffset
        ))
    }

    mutable i = 0

    function throwError(message: String) {
        let column = (i - startLineOffset) + 1
        throw(CompileError(
            Location(file, line, column + 1)
            message
        ))
    }

    while {i < code.size()} {

        while {i < code.size() && (code.grab(i) == ' ' || code.grab(i) == '\t' || code.grab(i) == '\r')} {i += 1}
        
        if(i < code.size()):

        let start = i
        startLine = line
        startLineOffset = lineOffset

        if(code.grab(i) == '\n') {

            i += 1
            line += 1
            lineOffset = i

        } elseIf {code.grab(i) == '/' && code.grab(i + 1) == '/'} {

            i += 2
            while {i < code.size() && code.grab(i) != '\n'} {i += 1}

        } elseIf {code.grab(i) == '/' && code.grab(i + 1) == '*'} {

            i += 2
            while {i < code.size() && (code.grab(i) != '*' || code.grab(i + 1) != '/')} {
                if(i >= code.size()) {
                    throwError(
                        "Expected end of comment started on line " + startLine + ", got end of file."
                    )
                }
                if(code.grab(i) == '\n') {
                    line += 1
                    lineOffset = i + 1
                }
                i += 1
            }
            i += 2

        } elseIf {code.grab(i) == '"' || code.grab(i) == '\''} {

            let endSign = code.grab(i)

            mutable multiLine = i + 2 < code.size() &&
                code.grab(i) == '"' && code.grab(i + 1) == '"' && code.grab(i + 2) == '"'

            i += if(multiLine) {3} else {1}
            while {i < code.size() && (multiLine || code.grab(i) != endSign)} {
                if(code.grab(i) == '\n') {
                    if(multiLine) {
                        line += 1
                        lineOffset = i + 1
                    } else {
                        throwError(
                            "Unexpected end of line in string."
                        )
                    }
                }
                if(i >= code.size()) {
                    throwError(
                        "Expected end of string started on line " + startLine + ", got end of file."
                    )
                }
                if(code.grab(i) == '\\' && code.grab(i + 1) != '\n') {i += 1}
                if(multiLine &&
                    i + 2 < code.size() && (i + 3 >= code.size() || code.grab(i + 3) != '"') &&
                    code.grab(i) == '"' && code.grab(i + 1) == '"' && code.grab(i + 2) == '"'
                ) {
                    multiLine = False
                    i += 2
                } else {
                    i += 1
                }
            }
            i += 1
            emitToken(if(endSign == '"') {LString} else {LChar}, start, i)

        } elseIf {code.grab(i).isAsciiLetter()} {

            let kind = if(code.grab(i) >= 'a') {LLower} else {LUpper}
            i += 1
            while {i < code.size() && code.grab(i).isAsciiLetterOrDigit()} { i += 1 }
            if(kind == LUpper && code.grab(i) == '.') {
                i += 1
                emitToken(LNamespace, start, i)
            } else {
                emitToken(kind, start, i)
            }

        } elseIf {code.grab(i).isAsciiDigit()} {

            mutable dot = False
            mutable exponent = False
            while {i < code.size() && code.grab(i).isAsciiDigit()} {
                i += 1
                if((code.grab(i) == 'e' || code.grab(i) == 'E') && !exponent) {
                    i += 1
                    dot = True
                    exponent = True
                    if(code.grab(i) == '+' || code.grab(i) == '-') {i += 1}
                }
                if(
                    i + 1 < code.size() && code.grab(i) == '.' &&
                    code.grab(i + 1).isAsciiDigit() &&
                    !dot && !exponent
                ) {
                    i += 1
                    dot = True
                }
            }
            emitToken(if(dot || exponent) {LFloat} else {LInt}, start, i)

        } elseIf {code.grab(i) == '_'} {

            i += 1
            emitToken(LWildcard, start, i)

        } elseIf {operatorCharacters.contains(code.grab(i))} {

            i += 1
            while {i < code.size() && operatorCharacters.contains(code.grab(i))} {i += 1}
            let o =
                if(i - start == 1 && code.grab(i - 1) == '.') {
                    LDot
                } elseIf {i - start == 1 && code.grab(i - 1) == ','} {
                    LComma
                } elseIf {i - start == 1 && code.grab(i - 1) == ';'} {
                    LSemicolon
                } elseIf {i - start == 1 && code.grab(i - 1) == '|'} {
                    LPipe
                } elseIf {i - start == 1 && code.grab(i - 1) == ':'} {
                    LColon
                } elseIf {i - start == 3 && code.grab(i - 3) == '.' && code.grab(i - 2) == '.' && code.grab(i - 1) == '.'} {
                    LDotDotDot
                } elseIf {i - start == 2 && code.grab(i - 2) == '=' && code.grab(i - 1) == '>'} {
                    LArrowThick
                } elseIf {i - start == 1 && code.grab(i - 1) == '='} {
                    LAssign
                } elseIf {i - start == 2 && code.grab(i - 2) == '+' && code.grab(i - 1) == '='} {
                    LAssignPlus
                } elseIf {i - start == 2 && code.grab(i - 2) == '-' && code.grab(i - 1) == '='} {
                    LAssignMinus
                } elseIf {i - start == 3 && code.grab(i - 3) == ':' && code.grab(i - 2) == ':' && code.grab(i - 1) == '='} {
                    LAssignLink
                } else {
                    LOperator
                }

            if(
                line == completionLine && 1 + i - lineOffset == completionColumn - 1 &&
                o == LDot && i < code.size() && !code.grab(i).isAsciiLetter() && code.grab(i) != '{'
            ) {
                emitToken(LLower, i, i)
            }
            
            emitToken(o, start, i)

        } elseIf {
            code.grab(i) == '(' || code.grab(i) == '[' || code.grab(i) == '{'
        } {

            i += 1
            emitToken(LBracketLeft, start, i)

        } elseIf {
            code.grab(i) == ')' || code.grab(i) == ']' || code.grab(i) == '}'
        } {

            i += 1
            emitToken(LBracketRight, start, i)

        } elseIf {
            i < code.size()
        } {

            throwError("Unexpected character: " + Show.show(code.grab(i)))

        }

    }

    List.range(5).each {_ => emitToken(LEnd, i, i) }

    tokens.drain()

}
