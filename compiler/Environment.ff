import Syntax

type Environment(
    symbols: Map[String, Scheme]
    effect: Type
)

type Scheme(
    isVariable: Bool
    isMutable: Bool
    isNewtype: Bool
    isTraitMethod: Bool
    signature: Signature
)

type Instantiated(
    typeArguments: List[Pair[String, Type]]
    scheme: Scheme
)

make(module: Module, otherModules: List[Module]): Environment {
    Environment(
        symbols = processModule(module, True).symbols.addAll(
            otherModules.map { processModule(_, False).symbols }.foldLeft(Map.empty()) { _.addAll(_) }
        )
        effect = TConstructor(Location(module.file, 0, 0), "ff:core/Nothing.Nothing", [])
    )
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

processModule(module: Module, isCurrentModule: Bool): Environment {

    function full(module: Module, name: String): String {
        module.packagePair.groupName() + "/" +
        module.file.dropLast(3) + "." + name
    }

    let functions =
        module.functions.map { d => Pair(
            full(module, d.signature.name),
            Scheme(False, False, False, False, d.signature)
        )}

    let lets =
        module.lets.map { d =>
            let noEffect = TConstructor(d.at, "ff:core/Nothing.Nothing", [])
            Pair(
                full(module, d.name),
                Scheme(True, False, False, False, Signature(d.at, d.name, [], [], [], d.variableType, noEffect))
            )
        }

    let traitMethods =
        module.traits.flatMap { definition =>
            let generics = definition.generics.map { name => TConstructor(definition.at, name, []) }
            let constraint = Constraint(definition.at, full(module, definition.name), generics)
            definition.methods.map { methodSignature =>
                let signature = methodSignature.Signature(
                    generics = [...definition.generics, ...methodSignature.generics]
                    constraints = [constraint, ...definition.constraints, ...methodSignature.constraints]
                )
                Pair(
                    full(module, signature.name),
                    Scheme(False, False, False, True, signature)
                )
            }
        }

    let extends =
        module.extends.flatMap { d =>
            d.type.{
                | TVariable t =>
                    fail(t.at, "Unexpected type variable: $" + t.index)
                | TConstructor t =>
                    let prefix = t.name + "_"
                    let selfParameter = Parameter(d.at, False, d.name, d.type, None)
                    d.methods.map { method =>
                        let effect = method.signature.generics.filter {_ == "Q$"}
                        let normalGenerics = method.signature.generics.filter {_ != "Q$"}
                        Pair(
                            prefix + method.signature.name,
                            Scheme(False, False, False, False, method.signature.Signature(
                                generics = [...effect, ...d.generics, ...normalGenerics]
                                constraints = [...d.constraints, ...method.signature.constraints]
                                parameters = [selfParameter, ...method.signature.parameters]
                            ))
                        )
                    }
            }
        }

    let fields =
        module.types.flatMap { d =>
            let prefix = d.name + "_"
            let t = TConstructor(d.at, d.name, d.generics.map { g => TConstructor(d.at, g, []) })
            let selfParameter = Parameter(d.at, False, d.name, t, None)
            d.commonFields.map { f =>
                let noEffect = TConstructor(d.at, "ff:core/Nothing.Nothing", [])
                Pair(
                    full(module, prefix + f.name),
                    Scheme(True, f.mutable, d.newtype, False, Signature(
                        at = f.at
                        name = f.name
                        generics = d.generics
                        constraints = d.constraints
                        parameters = [selfParameter]
                        returnType = f.valueType
                        effect = noEffect
                    ))
                )
            }
        }

    let variants =
        module.types.flatMap { d =>
            let returnType = TConstructor(d.at, full(module, d.name), d.generics.map { typeParameter =>
                TConstructor(d.at, typeParameter, [])
            })
            d.variants.map { variant =>
                let noEffect = TConstructor(d.at, "ff:core/Nothing.Nothing", [])
                Pair(
                    full(module, variant.name),
                    Scheme(False, False, d.newtype, False, Signature(
                        variant.at,
                        variant.name,
                        generics = d.generics,
                        constraints = d.constraints,
                        parameters = [...d.commonFields, ...variant.fields],
                        returnType = returnType
                        effect = noEffect
                    ))
                )
            }
        }

    let effect = TConstructor(Location(module.file, 0, 0), "ff:core/Nothing.Nothing", [])
    Environment([...functions, ...lets, ...fields, ...extends, ...variants, ...traitMethods].toMap(), effect)
}
