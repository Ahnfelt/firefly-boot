import Syntax

type Environment(
    symbols: Map[String, Scheme]
)

type Scheme(
    isVariable: Bool
    isMutable: Bool
    isNewtype: Bool
    isTraitMethod: Bool
    signature: Signature
)

type Instantiated(
    typeArguments: List[Pair[String, Type]]
    scheme: Scheme
)

make(module: Module, otherModules: List[Module]): Environment {
    Environment(
        processModule(module, True).symbols ++
        otherModules.map { processModule(_, False).symbols }.foldLeft(Map.empty()) { _ ++ _ }
    )
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

processModule(module: Module, isCurrentModule: Bool): Environment {

    function full(module: Module, name: String): String {
        module.packagePair.first + ":" + module.packagePair.second + "/" +
        module.file.dropLast(3) + "." + name
    }

    let functions =
        module.functions.map { d => Pair(
            full(module, d.signature.name),
            Scheme(False, False, False, False, d.signature)
        )}

    let lets =
        module.lets.map { d => Pair(
            full(module, d.name),
            Scheme(True, False, False, False, Signature(d.at, d.name, [], [], [], d.variableType))
        )}

    let traitMethods =
        module.traits.flatMap { definition =>
            let generics = definition.generics.map { name => TConstructor(definition.at, name, []) }
            let constraint = Constraint(definition.at, full(module, definition.name), generics)
            definition.methods.map { methodSignature =>
                let signature = methodSignature.Signature(
                    generics = definition.generics ++ methodSignature.generics
                    constraints = [constraint, ...definition.constraints, ...methodSignature.constraints]
                )
                Pair(
                    full(module, signature.name),
                    Scheme(False, False, False, True, signature)
                )
            }
        }

    let extends =
        module.extends.flatMap { d =>
            d.type.{
                | TVariable t =>
                    fail(t.at, "Unexpected type variable: $" + t.index)
                | TConstructor t =>
                    let prefix = t.name + "_"
                    let selfParameter = Parameter(d.at, False, d.name, d.type, None)
                    d.methods.map { method =>
                        Pair(
                            prefix + method.signature.name,
                            Scheme(False, False, False, False, method.signature.Signature(
                                generics = d.generics ++ method.signature.generics
                                constraints = d.constraints ++ method.signature.constraints
                                parameters = [selfParameter, ...method.signature.parameters]
                            ))
                        )
                    }
            }
        }

    let fields =
        module.types.flatMap { d =>
            let prefix = d.name + "_"
            let t = TConstructor(d.at, d.name, d.generics.map { g => TConstructor(d.at, g, []) })
            let selfParameter = Parameter(d.at, False, d.name, t, None)
            d.commonFields.map { f =>
                Pair(
                    full(module, prefix + f.name),
                    Scheme(True, f.mutable, d.newtype, False, Signature(
                        at = f.at
                        name = f.name
                        generics = d.generics
                        constraints = d.constraints
                        parameters = [selfParameter]
                        returnType = f.valueType
                    ))
                )
            }
        }

    let variants =
        module.types.flatMap { d =>
            let returnType = TConstructor(d.at, full(module, d.name), d.generics.map { typeParameter =>
                TConstructor(d.at, typeParameter, [])
            })
            d.variants.map { variant =>
                Pair(
                    full(module, variant.name),
                    Scheme(False, False, d.newtype, False, Signature(
                        variant.at,
                        variant.name,
                        generics = d.generics,
                        constraints = d.constraints,
                        parameters = d.commonFields ++ variant.fields,
                        returnType = returnType
                    ))
                )
            }
        }

    Environment((functions ++ lets ++ fields ++ extends ++ variants ++ traitMethods).toMap())
}
