import Token
import Wildcards
import Syntax
import LspHook

class Parser(
    packagePair: PackagePair
    file: String
    tokens: List[Token]
    end: Token
    targetIsNode: Bool
    lspHook: LspHook
    mutable lspEmittedArgumentHook: Bool
    mutable offset: Int
    mutable nextUnificationVariableIndex: Int
)

data Poly(generics: List[String], constraints: List[Constraint])

data ParsedTargets(
    js: Option[Lambda]
    jsSync: Option[String]
    jsAsync: Option[String]
    browser: Option[Lambda]
    browserSync: Option[String]
    browserAsync: Option[String]
    node: Option[Lambda]
    nodeSync: Option[String]
    nodeAsync: Option[String]
)

new(
    packagePair: PackagePair 
    file: String
    tokens: List[Token]
    targetIsNode: Bool
    lspHook: LspHook
): Parser {
    Parser(
        packagePair = packagePair
        file = file
        tokens = tokens
        end = tokens.grabLast()
        targetIsNode = targetIsNode
        lspHook = lspHook
        lspEmittedArgumentHook = False
        offset = 0
        nextUnificationVariableIndex = 1 // To avoid collision with the unification and resolver
    )
}

extend self: Parser {

    fail[T](at: Location, message: String): T {
        panic(message + " " + at.show())
    }

    behind(): Token {
        if(self.offset == 0) {self.current()} else {
            if(self.offset - 1 < self.tokens.size()) {self.tokens.grab(self.offset - 1)} else {self.end}
        }
    }

    current(): Token {
        if(self.offset < self.tokens.size()) {self.tokens.grab(self.offset)} else {self.end}
    }

    ahead(): Token {
        if(self.offset + 1 < self.tokens.size()) {self.tokens.grab(self.offset + 1)} else {self.end}
    }

    aheadAhead(): Token {
        if(self.offset + 2 < self.tokens.size()) {self.tokens.grab(self.offset + 2)} else {self.end}
    }

    skip(kind: TokenKind): Token {
        let c = self.current()
        if(c.kind != kind) {
            if(self.lspHook.isEnabled() && kind == LUpper && c.kind == LLower) {} else:
            throw(CompileError(c.at(), "Expected " + Show.show(kind) + ", got " + c.raw()))
        }
        self.offset += 1
        c
    }

    rawSkip(kind: TokenKind, value: String): Token {
        let c = self.current()
        if(c.kind != kind) {
            if(self.lspHook.isEnabled() && (value == ")" || value == "]" || value == "}")) {} else:
            throw(CompileError(c.at(), "Expected " + Show.show(kind) + " " + value + ", got " + c.raw()))
        }
        if(!c.rawIs(value)) {
            if(self.lspHook.isEnabled() && (value == ")" || value == "]" || value == "}")) {self.offset -= 1} else:
            throw(CompileError(c.at(), "Expected " + value + " got " + c.raw()))
        }
        self.offset += 1
        c
    }

    freshUnificationVariable(at: Location): Type {
        let result = TVariable(at, self.nextUnificationVariableIndex)
        self.nextUnificationVariableIndex += 3
        result
    }

    currentIsSeparator(kind: TokenKind): Bool {
        self.current().is(kind) || self.current().is(LSeparator)
    }

    skipSeparator(kind: TokenKind): Token {
        if(self.current().is(LSeparator)) {
            self.skip(LSeparator)
        } else {
            self.skip(kind)
        }
    }

    parseModuleWithoutPackageInfo(): Module {
        let moduleWithPackageInfo = self.parseModuleWithPackageInfo()
        moduleWithPackageInfo.packageInfo.each {info =>
            throw(CompileError(info.package.at, "Package and dependencies already declared in package.ff"))
        }
        moduleWithPackageInfo.module
    }

    parseModuleWithPackageInfo(): ModuleWithPackageInfo {
        let packageInfo = if(self.current().is(LKeyword) && self.current().rawIs3("package", "dependency", "include")) {
            self.parsePackageInfo()
        }
        let module = self.parseModule()
        ModuleWithPackageInfo(packageInfo, module)
    }

    parsePackageInfo(): PackageInfo {
        let location = self.current().at()
        let package = if(self.current().is(LKeyword) && self.current().rawIs("package")) {
            let p = self.parsePackageDefinition()
            if(!self.current().is(LEnd)) {self.skipSeparator(LSemicolon)}
            p
        } else {
            DPackage(
                location
                self.packagePair
                Version(location, 0, 0, 0)
                TargetNames(node = self.targetIsNode, browser = !self.targetIsNode)
            )
        }
        if(self.current().is(LKeyword) && self.current().rawIs("package")) {
            throw(CompileError(self.current().at(), "Duplicate package definition"))
        }
        /* TODO: if(self.package != None && self.current().is(LKeyword) && self.current().rawIs("dependency")) {
            self.fail(self.current().at(), "Dependencies must be defined in the same file as the package declaration")
        }*/
        let dependencies = Array.new[DDependency]()
        while {self.current().is(LKeyword) && self.current().rawIs("dependency")} {
            dependencies.push(self.parseDependencyDefinition(package.targets))
            if(!self.current().is(LEnd)) {self.skipSeparator(LSemicolon)}
        }
        let includes = Array.new[DInclude]()
        while {self.current().is(LKeyword) && self.current().rawIs("include")} {
            includes.push(self.parseIncludeDefinition())
            if(!self.current().is(LEnd)) {self.skipSeparator(LSemicolon)}
        }
        // TODO: When this method is called directly for package.ff, check that the whole file has been consumed
        PackageInfo(package, dependencies.toList(), includes.toList())
    }

    parseModule(): Module {
        let imports = Array.new[DImport]()
        let types = Array.new[DType]()
        let traits = Array.new[DTrait]()
        let instances = Array.new[DInstance]()
        let extends = Array.new[DExtend]()
        let lets = Array.new[DLet]()
        let functions = Array.new[DFunction]()
        while {!self.current().is(LEnd)} {
            if(self.current().is(LLower) && (self.ahead().is(LAssign) || self.ahead().is(LColon))) {
                lets.push(self.parseLetDefinition())
            } elseIf {self.current().is(LLower)} {
                functions.push(self.parseFunctionDefinition(member = False))
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("extend")} {
                extends.push(self.parseExtendDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("trait")} {
                traits.push(self.parseTraitDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("instance")} {
                instances.push(self.parseInstanceDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs4("data", "class", "capability", "newtype")} {
                types.push(self.parseTypeDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("import")} {
                imports.push(self.parseImportDefinition(self.packagePair))
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("include")} {
                throw(CompileError(self.current().at()
                    "Includes must be at the top of the file or below 'package'"
                ))
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("dependency")} {
                throw(CompileError(self.current().at()
                    "Dependencies must be at the top of the file or below 'package'"
                ))
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("package")} {
                throw(CompileError(self.current().at()
                    "Package definition must be at the top of the file"
                ))
            } else {
                self.skip(LEnd)
            }
            if(!self.current().is(LEnd)) {self.skipSeparator(LSemicolon)}
        }

        Module(
            file = self.file
            packagePair = self.packagePair
            imports = imports.toList()
            lets = lets.toList()
            functions = functions.toList()
            extends = extends.toList()
            types = types.toList()
            traits = traits.toList()
            instances = instances.toList()
        )
    }

    parseLetDefinition(): DLet {
        if(self.lspHook.trackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
        let nameToken = self.skip(LLower)
        let variableType = if(self.current().is(LColon)) {
            self.skip(LColon)
            self.parseType()
        } else {self.freshUnificationVariable(nameToken.at())}
        self.skip(LAssign)
        let value = self.parseTerm()
        let retult = DLet(nameToken.at(), nameToken.raw(), variableType, value)
        if(self.lspHook.trackSymbols) {
            self.lspHook.emit(ParseSymbolEnd(
                name = nameToken.raw()
                kind = SLet(mutable = False)
                selectionStart = nameToken.at()
                selectionEnd = nameToken.end()
                start = nameToken.at()
                end = self.behind().end()
            ))
        }
        retult
    }

    parseFunctionDefinition(member: Bool): DFunction {
        if(self.lspHook.trackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
        let signature = self.parseSignature(member)
        let body = if(self.current().rawIs("{")) {self.parseLambda(signature.parameters.size())}
        let targets = self.parseTargets(signature.parameters.size())
        let bestTarget = findBestTarget(self.targetIsNode, body, targets)
        let result = DFunction(
            signature.at
            signature
            bestTarget
        )
        if(self.lspHook.trackSymbols) {
            self.lspHook.emit(ParseSymbolEnd(
                name = signature.name
                kind = SFunction(member)
                selectionStart = signature.at
                selectionEnd = signature.at.Location(column = signature.at.column + signature.name.size())
                start = signature.at
                end = self.behind().end()
            ))
        }
        result
    }

    parseTargets(parameterCount: Int): ParsedTargets {
        function processCode(code: String): String {
            let dropCount = if(code.startsWith("\"\"\"")) {3} else {1}
            code.dropFirst(dropCount).dropLast(dropCount)
                .replace("\\\"", "\"")
                .replace("\\r", "\r")
                .replace("\\n", "\n")
                .replace("\\t", "\t")
                .replace("\\\\", "\\")
        }
        mutable targets = ParsedTargets(None, None, None, None, None, None, None, None, None)
        while {self.currentIsSeparator(LSemicolon) && self.ahead().is(LKeyword) && self.ahead().rawIs("target")} {
            self.skip(LSeparator)
            let at = self.skip(LKeyword).at()
            let target = if(self.current().is(LLower)) {self.skip(LLower).raw()} else {self.skip(LKeyword).raw()}
            if(self.current().rawIs("{")) {
                let lambda = self.parseLambda(parameterCount)
                target.{
                    | "js" =>
                        if(targets.jsSync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(js = Some(lambda))
                    | "browser" =>
                        if(targets.browserSync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(browser = Some(lambda))
                    | "node" =>
                        if(targets.nodeAsync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(node = Some(lambda))
                    | _ =>
                        throw(CompileError(at, "Unknown target"))
                }
            } else {
                let mode = self.skip(LKeyword).raw()
                let code = processCode(self.skip(LString).raw())
                Pair(target, mode).{
                    | Pair("js", "sync") =>
                        if(targets.jsSync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(jsSync = Some(code))
                    | Pair("js", "async") =>
                        if(targets.jsAsync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(jsAsync = Some(code))
                    | Pair("browser", "sync") =>
                        if(targets.browserSync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(browserSync = Some(code))
                    | Pair("browser", "async") =>
                        if(targets.browserAsync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(browserAsync = Some(code))
                    | Pair("node", "sync") =>
                        if(targets.nodeSync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(nodeSync = Some(code))
                    | Pair("node", "async") =>
                        if(targets.nodeAsync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(nodeAsync = Some(code))
                    | Pair(_, _) =>
                        throw(CompileError(at, "Unknown target or mode"))
                }
            }
        }
        targets
    }

    parseSignature(member: Bool): Signature {
        let nameToken = self.skip(LLower)
        let poly = if(self.current().rawIs("[")) {self.parseTypeParameters()} else {Poly([], [])}
        let parameters = if(self.lspHook.isEnabled() && !self.current().rawIs("(")) {[]} else {self.parseFunctionParameters()}
        let returnType = if(self.current().is(LColon)) {
            self.skip(LColon)
            self.parseType()
        } else {
            TConstructor(self.current().at(), "ff:core/Unit.Unit", [])
        }
        let temporaryEffect = TConstructor(nameToken.at(), "TemporaryEffect$", [])
        Signature(nameToken.at(), nameToken.raw(), member, poly.generics, poly.constraints, parameters, returnType, temporaryEffect)
    }

    parseExtendDefinition(): DExtend {
        if(self.lspHook.trackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
        let extendToken = self.rawSkip(LKeyword, "extend")
        let nameToken = self.skip(LLower)
        let poly = if(self.current().rawIs("[")) {self.parseTypeParameters()} else {Poly([], [])}
        self.skip(LColon)
        let type = self.parseType()
        self.rawSkip(LBracketLeft, "{")
        let methods = Array.new[DFunction]()
        while {!self.current().is(LBracketRight)} {
            methods.push(self.parseFunctionDefinition(member = True))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LSemicolon)}
        }
        self.rawSkip(LBracketRight, "}")
        if(self.lspHook.trackSymbols) {
            mutable name = type.show([])
            poly.generics.zip(poly.constraints).each {| Pair(generic, constraint) => 
                name = name.replace("[" + generic + "]",  "[" + generic + ": " + constraint.name + "]")
                name = name.replace("[" + generic + ",",  "[" + generic + ": " + constraint.name + ",")
                name = name.replace(", " + generic + ",", ", " + generic + ": " + constraint.name + ",")
                name = name.replace(", " + generic + "]", ", " + generic + ": " + constraint.name + "]")
            }
            self.lspHook.emit(ParseSymbolEnd(
                name = name
                kind = SExtend
                selectionStart = nameToken.at()
                selectionEnd = nameToken.end()
                start = extendToken.at()
                end = self.behind().end()
            ))
        }        
        DExtend(
            nameToken.at()
            nameToken.raw()
            poly.generics
            poly.constraints
            type
            methods.toList()
        )
    }

    parseTraitDefinition(): DTrait {
        if(self.lspHook.trackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
        let traitToken = self.rawSkip(LKeyword, "trait")
        let typeParameterToken = self.skip(LUpper)
        self.skip(LColon)
        let nameToken = self.skip(LUpper)
        let poly = if(!self.current().rawIs("[")) {Poly([], [])} else {self.parseTypeParameters()}
        let constraints = Array.new[Constraint]()
        while {self.current().is(LColon)} {
            self.fail(self.current().at(), "Trait constraints is not yet implemented")
            self.skip(LColon)
            let constraint = self.parseConstraint()
            constraints.push(constraint.Constraint(generics =
                [TConstructor(typeParameterToken.at(), typeParameterToken.raw(), []), ...constraint.generics]
            ))
        }
        let generatorParameters = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionParameters()}
        let methodGenerators = Array.new[Pair[String, Lambda]]()
        let methodDefaults = Array.new[Pair[String, Lambda]]()
        let methodSignatures = if(!self.current().rawIs("{")) {[]} else {
            let signatures = Array.new[Signature]()
            self.rawSkip(LBracketLeft, "{")
            while {!self.current().is(LBracketRight)} {
                if(self.lspHook.trackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
                let signatureNameToken = self.current()
                let signature = self.parseSignature(member = True)
                if(self.lspHook.trackSymbols) {
                    self.lspHook.emit(ParseSymbolEnd(
                        name = signatureNameToken.raw() 
                        kind = STraitFunction
                        selectionStart = signatureNameToken.at()
                        selectionEnd = signatureNameToken.end()
                        start = signatureNameToken.at()
                        end = self.behind().end()
                    ))
                }        
                signatures.push(signature)
                if(self.current().rawIs("{")) {
                    let generator = self.ahead().is(LKeyword) && self.ahead().rawIs("generate")
                    let body = self.parseLambda(signature.parameters.size(), ignoreGenerateKeyword = True)
                    if(generator) {
                        methodGenerators.push(Pair(signature.name, body))
                    } else {
                        methodDefaults.push(Pair(signature.name, body))
                    }
                }
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LSemicolon)}
            }
            self.rawSkip(LBracketRight, "}")
            signatures.toList()
        }
        if(self.lspHook.trackSymbols) {
            self.lspHook.emit(ParseSymbolEnd(
                name = nameToken.raw() 
                kind = STrait 
                selectionStart = nameToken.at()
                selectionEnd = nameToken.end()
                start = traitToken.at()
                end = self.behind().end()
            ))
        }        
        DTrait(
            nameToken.at()
            nameToken.raw()
            [typeParameterToken.raw(), ...poly.generics]
            [...constraints.toList(), ...poly.constraints]
            generatorParameters
            methodSignatures
            methodDefaults.toList()
            methodGenerators.toList()
        )
    }

    parseInstanceDefinition(): DInstance {
        if(self.lspHook.trackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
        let instanceToken = self.rawSkip(LKeyword, "instance")
        let token = self.skip(LUpper)
        let poly = if(!self.current().rawIs("[")) {Poly([], [])} else {self.parseTypeParameters()}
        let typeArguments = Array.new[Type]()
        typeArguments.push(TConstructor(token.at(), token.raw(), poly.generics.map {TConstructor(token.at(), _, [])}))
        self.skip(LColon)
        let nameToken = self.skip(LUpper)
        if(self.current().rawIs("[")) {
            self.rawSkip(LBracketLeft, "[")
            while {!self.current().is(LBracketRight)} {
                typeArguments.push(self.parseType())
                if(!self.current().is(LBracketRight)) {self.skip(LComma)}
            }
            self.rawSkip(LBracketRight, "]")
        }
        let generatorArguments = self.parseFunctionArguments(nameToken.at(), False).first
        let methods = if(!self.current().rawIs("{")) {[]} else {
            let definitions = Array.new[DFunction]()
            self.rawSkip(LBracketLeft, "{")
            while {!self.current().is(LBracketRight)} {
                definitions.push(self.parseFunctionDefinition(member = False))
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LSemicolon)}
            }
            self.rawSkip(LBracketRight, "}")
            definitions.toList()
        }
        if(self.lspHook.trackSymbols) {
            let name = token.raw() + ": " + nameToken.raw()
            self.lspHook.emit(ParseSymbolEnd(
                name = name
                kind = SInstance  
                selectionStart = nameToken.at()
                selectionEnd = nameToken.end()
                start = instanceToken.at()
                end = self.behind().end()
            ))
        }            
        DInstance(
            at = nameToken.at()
            generics = poly.generics
            constraints = poly.constraints
            traitName = nameToken.raw()
            typeArguments = typeArguments.toList()
            generatorArguments = generatorArguments
            methods = methods
            derived = False
        )
    }

    parseTypeDefinition(): DType {
        if(self.lspHook.trackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
        let newtype = self.current().rawIs("newtype")
        let effectParameter = if(self.current().rawIs("capability")) {["Q$"]} else {[]}
        let allowMutable = self.current().rawIs2("class", "capability")
        let kindToken = if(self.current().rawIs("newtype")) {
            self.rawSkip(LKeyword, "newtype")
        } elseIf {self.current().rawIs("data")} {
            self.rawSkip(LKeyword, "data")
        } elseIf {self.current().rawIs("class")} {
            self.rawSkip(LKeyword, "class")
        } else {
            self.rawSkip(LKeyword, "capability")
        }
        let nameToken = self.skip(LUpper)
        let poly = if(!self.current().rawIs("[")) {Poly([], [])} else {self.parseTypeParameters()}
        if(!self.current().rawIs("(") && !self.current().rawIs("{")) {self.rawSkip(LBracketLeft, "{")}
        let commonFields = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionParameters(allowMutable = True)}
        let variants = if(newtype || !self.current().rawIs("{")) {
            [Variant(nameToken.at(), nameToken.raw(), [])]
        } else {
            self.rawSkip(LBracketLeft, "{")
            let variantsBuilder = Array.new[Variant]()
            while {!self.current().is(LBracketRight)} {
                if(self.lspHook.trackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
                let variantNameToken = self.skip(LUpper)
                let variantFields = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionParameters(allowMutable = True)}
                if(!allowMutable && variantFields.any {_.mutable}) {
                    throw(CompileError(variantFields.find {_.mutable}.grab().at
                        "Only classes can have mutable fields"
                    ))
                }
                variantsBuilder.push(
                    Variant(variantNameToken.at(), variantNameToken.raw(), variantFields)
                )
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LSemicolon)}
                if(self.lspHook.trackSymbols) {
                    self.lspHook.emit(ParseSymbolEnd(
                        name = variantNameToken.raw()
                        kind = SVariant
                        selectionStart = variantNameToken.at()
                        selectionEnd = variantNameToken.end()
                        start = variantNameToken.at()
                        end = self.behind().end()
                    ))
                }                     
            }
            self.rawSkip(LBracketRight, "}")
            variantsBuilder.toList()
        }
        if(newtype && commonFields.size() != 1) {
            Log.show(commonFields)
            throw(CompileError(nameToken.at(), "Newtypes must have exactly one field"))
        }
        if(!allowMutable && commonFields.any {_.mutable}) {
            throw(CompileError(
                commonFields.find {_.mutable}.grab().at
                "Only classes and capabilities can have mutable fields"
            ))
        }
        let generics = [...effectParameter, ...poly.generics]
        let result = DType(nameToken.at(), newtype, !allowMutable, nameToken.raw(), generics, poly.constraints, commonFields, variants)
        if(self.lspHook.trackSymbols) {
            self.lspHook.emit(ParseSymbolEnd(
                name = nameToken.raw()
                kind = SType
                selectionStart = nameToken.at()
                selectionEnd = nameToken.end()
                start = kindToken.at()
                end = self.behind().end()
            ))
        }        
        result
    }

    parseImportDefinition(currentPackagePair: PackagePair): DImport {
        let importToken = self.rawSkip(LKeyword, "import")
        let path = Array.new[String]()
        while {self.current().is(LLower)} {
            path.push(self.parseDashedName())
            self.skip(LDot)
        }
        let fileToken = self.skip(LUpper)
        let alias = if(self.current().rawIs("as")) {
            self.rawSkip(LKeyword, "as")
            self.skip(LUpper).raw()
        } else {fileToken.raw()}
        let packagePair = if(self.current().rawIs("from")) {
            self.rawSkip(LKeyword, "from")
            let userName = self.parseDashedName()
            self.skip(LColon)
            let packageName = self.parseDashedName()
            PackagePair(userName, packageName)
        } else {
            currentPackagePair
        }
        DImport(fileToken.at(), alias, packagePair, path.toList(), fileToken.raw())
    }

    parsePackageDefinition(): DPackage {
        let at = self.skip(LKeyword).at()
        let user = self.skip(LLower).raw()
        self.skip(LColon)
        let name = self.skip(LLower).raw()
        self.skip(LColon)
        let version = self.parseVersion()
        let targets = self.parseTargetNames(TargetNames(True, True))
        DPackage(
            at = at
            packagePair = PackagePair(user, name)
            version = version
            targets = targets
        )
    }

    parseDependencyDefinition(defaultTargetNames: TargetNames): DDependency {
        let at = self.skip(LKeyword).at()
        let user = self.skip(LLower).raw()
        self.skip(LColon)
        let name = self.skip(LLower).raw()
        self.skip(LColon)
        let version = self.parseVersion()
        let safety = (
            if(self.current().rawIs("trusted")) {Trusted} else:
            if(self.current().rawIs("unsafe")) {Unsafe} else:
            Safe
        )
        let targets = self.parseTargetNames(defaultTargetNames)
        DDependency(
            at = at
            packagePair = PackagePair(user, name)
            version = version
            safety = safety
            targets = targets
        )
    }

    parseIncludeDefinition(): DInclude {
        let at = self.skip(LKeyword).at()
        let path = self.skip(LString).raw()
        DInclude(
            at = at
            path = path.dropFirst().dropLast() // TODO: Fix string escaping
        )
    }

    parseTargetNames(defaultTargets: TargetNames): TargetNames {
        mutable targets = TargetNames(False, False)
        while {self.current().is2(LKeyword, LLower)} {
            let token = if(self.current().is(LLower)) {self.skip(LLower)} else {self.skip(LKeyword)}
            token.raw().{
                | "node" {targets.node} => throw(CompileError(token.at(), "Duplicate target name"))
                | "node" => targets = targets.TargetNames(node = True)
                | "browser" {targets.browser} => throw(CompileError(token.at(), "Duplicate target name"))
                | "browser" => targets = targets.TargetNames(browser = True)
                | t => throw(CompileError(token.at(), "Unexpected target: " + t))
            }
        }
        if(!targets.node && !targets.browser) {
            defaultTargets
        } else {
            targets
        }
    }

    parseVersion(): Version {
        if(self.current().is(LFloat)) {
            let majorMinor = self.skip(LFloat)
            let parts = majorMinor.raw().split('.')
            let patch = if(self.current().is(LDot)) {
                 self.skip(LDot)
                 self.skip(LInt).raw().grabInt()
            } else {0}
            Version(majorMinor.at(), parts.grab(0).grabInt(), parts.grab(1).grabInt(), patch)
        } else {
            let major = self.skip(LInt)
            Version(major.at(), major.raw().grabInt(), 0, 0)
        }
    }

    parseDashedName(): String {
        let at = self.current().at()
        function readPart(): String {
            if(self.current().is(LInt)) {
                let prefix = self.skip(LInt).raw()
                if(self.current().is(LLower)) {prefix + self.skip(LLower).raw()} else {prefix}
            } else {
                self.skip(LLower).raw()
            }
        }
        mutable part = readPart()
        while {self.current().rawIs("-")} {
            self.skip(LOperator)
            part = part + "-" + readPart()
        }
        if(part.any {_.isAsciiUpper()}) {
            throw(CompileError(at, "Package names and paths must not contain upper case letters: " + part))
        }
        if(part.any {_ == '_'} || part.any {_ == '.'}) {
            throw(CompileError(at, "Package names and paths must not contain underscores or dots: " + part))
        }
        part
    }

    parseTypeParameters(): Poly {
        self.rawSkip(LBracketLeft, "[")
        let parameters = Array.new[String]()
        let constraints = Array.new[Constraint]()
        while {!self.current().is(LBracketRight) && !self.current().is(LSemicolon)} {
            if(self.ahead().is(LBracketLeft)) {
                constraints.push(self.parseConstraint())
            } else {
                let parameterNameToken = self.skip(LUpper)
                parameters.push(parameterNameToken.raw())
                while {self.current().is(LColon)} {
                    self.skip(LColon)
                    let constraint = self.parseConstraint()
                    constraints.push(constraint.Constraint(generics =
                        [TConstructor(parameterNameToken.at(), parameterNameToken.raw(), []), ...constraint.generics]
                    ))
                }
            }
            if(!self.current().is(LBracketRight)) {self.skip(LComma)}
        }
        self.rawSkip(LBracketRight, "]")
        Poly(parameters.toList(), constraints.toList())
    }

    parseTypeArguments(parenthesis: Bool = False): List[Type] {
        self.rawSkip(LBracketLeft, if(parenthesis) {"("} else {"["})
        let types = Array.new[Type]()
        while {!self.current().is(LBracketRight)} {
            types.push(self.parseType())
            if(!self.current().is(LBracketRight)) {self.skip(LComma)}
        }
        self.rawSkip(LBracketRight, if(parenthesis) {")"} else {"]"})
        types.toList()
    }

    parseFunctionParameters(allowMutable: Bool = False): List[Parameter] {
        let parameters = Array.new[Parameter]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let lspTrackSymbols = self.lspHook.trackSymbols && allowMutable
            if(lspTrackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
            let lspFirst = self.current()
            let mutable = allowMutable && self.current().is(LKeyword) && self.current().rawIs("mutable")
            if(mutable) {self.skip(LKeyword)}
            let parameterNameToken = self.skip(LLower)
            if(self.lspHook.isEnabled() && !self.current().is(LColon)) {
                let t = TConstructor(parameterNameToken.at(), "ff:core/Nothing.Nothing", [])
                parameters.push(Parameter(parameterNameToken.at(), mutable, parameterNameToken.raw(), t, None))
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
            } else:
            self.skip(LColon)
            let parameterType = self.parseType()
            let default = if(!self.current().is(LAssign)) {None} else {
                self.skip(LAssign)
                Some(self.parseTerm())
            }
            parameters.push(Parameter(parameterNameToken.at(), mutable, parameterNameToken.raw(), parameterType, default))
            if(lspTrackSymbols) {
                self.lspHook.emit(ParseSymbolEnd(
                    name = parameterNameToken.raw()
                    kind = SParameter
                    selectionStart = parameterNameToken.at()
                    selectionEnd = parameterNameToken.end()
                    start = lspFirst.at()
                    end = self.behind().end()
                ))
            }                       
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        parameters.toList()
    }

    parseFunctionArguments(callAt: Location, trailing: Bool): Pair[List[Argument], Bool] {
        let arguments = Array.new[Argument]()
        if(self.current().rawIs("(")){
            self.rawSkip(LBracketLeft, "(")
            while {!self.current().is(LBracketRight)} {
                let argumentToken = self.current()
                let nameToken = if(self.current().is(LLower) && self.ahead().is(LAssign)) {
                    let token = self.skip(LLower)
                    self.skip(LAssign)
                    Some(token)
                } else {None}
                let value = self.parseTerm()
                if(self.lspHook.isEnabled() && !self.lspEmittedArgumentHook) {
                    if(LspHook.strictlyBetween(callAt, self.current().at(), self.lspHook.at, 1)) {
                        self.lspHook.emit(ParseArgumentHook(callAt, arguments.size(), nameToken.map {_.raw()}))
                        self.lspEmittedArgumentHook = True
                    }
                }
                arguments.push(Argument(argumentToken.at(), nameToken.map {_.raw()}, value))
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
            }
            if(self.lspHook.isEnabled() && !self.lspEmittedArgumentHook) {
                if(LspHook.strictlyBetween(callAt, self.current().at(), self.lspHook.at, 1)) {
                    self.lspHook.emit(ParseArgumentHook(callAt, arguments.size(), None))
                    self.lspEmittedArgumentHook = True
                }
            }
            self.rawSkip(LBracketRight, ")")
        }
        mutable lastWasCurly = False
        if(trailing) {
            if(self.lspHook.isEnabled() &&
                (self.current().is3(LLower, LUpper, LString) || self.current().is3(LInt, LChar, LFloat))
            ) {
                lastWasCurly = True
                let term = self.parseTerm()
                let temporaryEffect = TConstructor(term.at, "TemporaryEffect$", [])
                let cases = [MatchCase(term.at, [], [], term)]
                if(self.lspHook.isEnabled() && !self.lspEmittedArgumentHook) {
                    if(LspHook.strictlyBetween(callAt, self.current().at(), self.lspHook.at, 1)) {
                        self.lspHook.emit(ParseArgumentHook(callAt, arguments.size(), None))
                        self.lspEmittedArgumentHook = True
                    }
                }
                arguments.push(Argument(term.at, None, ELambda(term.at, Lambda(term.at, temporaryEffect, cases))))
            } else {
                while {self.current().rawIs("{") || self.current().is(LColon)} {
                    lastWasCurly = self.current().rawIs("{")
                    let lambda = self.parseLambda(allowColon = True)
                    if(self.lspHook.isEnabled() && !self.lspEmittedArgumentHook) {
                        if(LspHook.strictlyBetween(callAt, self.current().at(), self.lspHook.at, 1)) {
                            self.lspHook.emit(ParseArgumentHook(callAt, arguments.size(), None))
                            self.lspEmittedArgumentHook = True
                        }
                    }
                    arguments.push(Argument(lambda.at, None, ELambda(lambda.at, lambda)))
                }
            }
        }
        Pair(arguments.toList(), lastWasCurly)
    }

    parseLambda(
        defaultParameterCount: Int = 0
        ignoreGenerateKeyword: Bool = False
        allowColon: Bool = False
    ): Lambda {
        let colon = allowColon && self.current().is(LColon)
        let token = if(colon) {self.skip(LColon)} else {self.rawSkip(LBracketLeft, "{")}
        if(ignoreGenerateKeyword && self.current().is(LKeyword) && self.current().rawIs("generate")) {self.skip(LKeyword)}
        let result = if(self.current().is(LPipe)) {
            let cases = Array.new[MatchCase]()
            while {self.current().is(LPipe)} {
                cases.push(self.parseCase())
            }
            cases.toList()
        } elseIf {self.current().is2(LLower, LWildcard) && self.ahead().is2(LComma, LArrowThick)} {
            let parameters = Array.new[MatchPattern]()
            while {!self.current().is(LArrowThick)} {
                let isVariable = self.current().is(LLower)
                let parameterToken = if(isVariable) {self.skip(LLower)} else {self.skip(LWildcard)}
                parameters.push(PVariable(parameterToken.at(), if(isVariable) {Some(parameterToken.raw())} else {None}))
                if(!self.current().is(LArrowThick)) {self.skip(LComma)}
            }
            self.skip(LArrowThick)
            let term = self.parseStatements()
            [MatchCase(token.at(), parameters.toList(), [], term)]
        } else {
            let term = self.parseStatements()
            let wildcards = Wildcards.new()
            let e = wildcards.fixWildcards(term)
            let arguments = if(wildcards.seenWildcards != 0) {
                List.range(wildcards.seenWildcards).map {i => PVariable(token.at(), Some("_w" + (i + 1)))}
            } else {
                List.range(defaultParameterCount).map {i => PVariable(token.at(), None)}
            }
            [MatchCase(token.at(), arguments, [], e)]
        }
        if(!colon) {self.rawSkip(LBracketRight, "}")}
        let temporaryEffect = TConstructor(token.at(), "TemporaryEffect$", [])
        Lambda(token.at(), temporaryEffect, result)
    }

    parseCase(): MatchCase {
        let token = self.skip(LPipe)
        let patterns = Array.new[MatchPattern]()
        while {!self.current().is3(LArrowThick, LPipe, LBracketRight) && !self.current().rawIs("{")} {
            patterns.push(self.parsePattern())
            if(!self.current().is3(LArrowThick, LPipe, LBracketRight) && !self.current().rawIs("{")) {
                self.skip(LComma)
            }
        }
        let guards = Array.new[MatchGuard]()
        while {self.current().rawIs("{")} {
            guards.push(self.parseCaseGuard())
        }
        if(!self.lspHook.isEnabled() || !self.current().is2(LPipe, LBracketRight)) {
            self.skip(LArrowThick)
        }
        let body = self.parseStatements()
        MatchCase(token.at(), patterns.toList(), guards.toList(), body)
    }

    parseCaseGuard(): MatchGuard {
        let guardToken = self.skip(LBracketLeft)
        let term = self.parseStatements()
        let p = if(!self.current().is(LPipe)) {
            PVariant(guardToken.at(), "True", [])
        } else {
            self.skip(LPipe)
            self.parsePattern()
        }
        self.skip(LBracketRight)
        MatchGuard(guardToken.at(), term, p)
    }

    parsePattern(): MatchPattern {
        let pattern = if(self.current().is(LWildcard)) {
            let token = self.skip(LWildcard)
            PVariable(token.at(), None)
        } elseIf {self.current().is(LLower)} {
            let token = self.skip(LLower)
            PVariable(token.at(), Some(token.raw()))
        } elseIf {self.current().rawIs("(")} {
            let at = self.current().at()
            let pair = self.parseRecordPattern().unzip()
            PVariant(at, "Record$" + pair.first.join("$"), pair.second)
        } elseIf {self.current().rawIs("[")} {
            self.parseListPattern()
        } elseIf {self.current().is(LString)} {
            let token = self.skip(LString)
            PString(token.at(), token.raw())
        } elseIf {self.current().is(LInt)} {
            let token = self.skip(LInt)
            PInt(token.at(), token.raw())
        } elseIf {self.current().is(LChar)} {
            let token = self.skip(LChar)
            PChar(token.at(), token.raw())
        } else {
            let token = self.skip(LUpper)
            if(self.current().rawIs("(")) {
                let patterns = Array.new[MatchPattern]()
                self.rawSkip(LBracketLeft, "(")
                while {!self.current().is(LBracketRight)} {
                    let pattern = self.parsePattern()
                    if(self.lspHook.isEnabled() && !self.lspEmittedArgumentHook) {
                        if(LspHook.strictlyBetween(token.at(), self.current().at(), self.lspHook.at, 1)) {
                            self.lspHook.emit(ParseArgumentHook(token.at(), patterns.size(), None))
                            self.lspEmittedArgumentHook = True
                        }
                    }
                    patterns.push(pattern)
                    if(!self.current().is(LBracketRight)) {self.skip(LComma)}
                }
                if(self.lspHook.isEnabled() && !self.lspEmittedArgumentHook) {
                    if(LspHook.strictlyBetween(token.at(), self.current().at(), self.lspHook.at, 1)) {
                        self.lspHook.emit(ParseArgumentHook(token.at(), patterns.size(), None))
                        self.lspEmittedArgumentHook = True
                    }
                }
                self.rawSkip(LBracketRight, ")")
                PVariant(token.at(), token.raw(), patterns.toList())
            } else {
                if(self.current().is(LLower)) {
                    let asToken = self.skip(LLower)
                    PVariantAs(token.at(), token.raw(), asToken.at(), Some(asToken.raw()))
                } elseIf {self.current().is(LWildcard)} {
                    let wildcardToken = self.skip(LWildcard)
                    PVariantAs(token.at(), token.raw(), wildcardToken.at(), None)
                } else {
                    PVariant(token.at(), token.raw(), [])
                }
            }
        }
        if(self.current().rawIs("@")) {
            let atToken = self.skip(LOperator)
            let asToken = self.skip(LLower)
            PAlias(asToken.at(), pattern, asToken.raw())
        } else {pattern}
    }

    parseType(): Type {
        let leftTypes = if(self.current().rawIs("(") && self.ahead().is(LLower) && self.aheadAhead().is(LColon)) {
            let at = self.current().at()
            let pair = self.parseRecordType().unzip()
            [TConstructor(at, "Record$" + pair.first.join("$"), pair.second)]
        } elseIf {self.current().rawIs("(")} {
            self.parseTypeArguments(parenthesis = True)
        } else {
            let namespace = if(self.current().is(LNamespace)) {self.skip(LNamespace).raw()} else {""}
            let token = self.skip(LUpper)
            let arguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
            [TConstructor(token.at(), namespace + token.raw(), arguments)]
        }
        if(!self.current().is(LArrowThick) && leftTypes.size() == 1) {leftTypes.grabFirst()} else {
            let arrowToken = self.skip(LArrowThick)
            let rightType = self.parseType()
            TConstructor(arrowToken.at(), "Function$" + leftTypes.size(), [...leftTypes, rightType])
        }
    }

    parseConstraint(): Constraint {
        let namespace = if(self.current().is(LNamespace)) {self.skip(LNamespace).raw()} else {""}
        let token = self.skip(LUpper)
        let arguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
        Constraint(token.at(), namespace + token.raw(), arguments)
    }

    parseStatements(): Term {
        if(self.current().is2(LBracketRight, LPipe)) {EVariant(self.current().at(), "Unit", [], None)} else {
            mutable result = self.parseStatement()
            while {self.currentIsSeparator(LSemicolon)} {
                let token = self.skipSeparator(LSemicolon)
                result = ESequential(token.at(), result, self.parseStatement())
            }
            result
        }
    }

    parseStatement(): Term {
        if(self.current().is(LKeyword) && (self.current().rawIs("let") || self.current().rawIs("mutable"))) {self.parseLet()} else:
        if(self.current().is(LKeyword) && self.current().rawIs("function")) {self.parseFunctions()} else:
        let term = self.parseTerm()
        if(!self.current().is(LAssign) && !self.current().is2(LAssignPlus, LAssignMinus)) {term} else:
        let token = do {
            if(self.current().is(LAssignPlus)) {self.skip(LAssignPlus)} else:
            if(self.current().is(LAssignMinus)) {self.skip(LAssignMinus)} else:
            self.skip(LAssign)
        }
        let operator = token.raw().dropLast(1)
        let value = self.parseTerm()
        term.{
            | EVariable(at, name) => EAssign(at, operator, name, value)
            | EField e => EAssignField(e.at, operator, e.record, e.field, value)
            | _ => throw(CompileError(token.at(), "Only variables and fields are assignable"))
        }
    }

    parseLet(): Term {
        if(self.lspHook.trackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
        let mutableToken = self.current()
        let mutable = mutableToken.rawIs("mutable")
        let keywordToken = if(mutable) {self.rawSkip(LKeyword, "mutable")} else {self.rawSkip(LKeyword, "let")}
        let nameToken = self.skip(LLower)
        let valueType = if(!self.current().is(LColon)) {self.freshUnificationVariable(nameToken.at())} else {
            self.skip(LColon)
            self.parseType()
        }
        if(self.lspHook.isEnabled() && !self.current().is(LAssign)) {
            let unit = EVariant(keywordToken.at(), "Unit", [], None)
            ELet(nameToken.at(), mutable, nameToken.raw(), valueType, unit, unit)
        } else:
        self.skip(LAssign)
        let value = self.parseTerm()
        if(self.lspHook.trackSymbols) {
            self.lspHook.emit(ParseSymbolEnd(
                name = nameToken.raw()
                kind = SLet(mutable)
                selectionStart = nameToken.at()
                selectionEnd = nameToken.end()
                start = mutableToken.at()
                end = self.behind().end()                
            ))
        }
        let body = if(self.currentIsSeparator(LSemicolon)) {
            self.skipSeparator(LSemicolon)
            self.parseStatements()
        } else {
            EVariant(keywordToken.at(), "Unit", [], None)
        }
        ELet(nameToken.at(), mutable, nameToken.raw(), valueType, value, body)
    }

    parseFunctions(): Term {
        let at = self.current().at()
        let functions = Array.new[DFunction]()
        while {self.current().rawIs("function")} {
            if(self.lspHook.trackSymbols) {self.lspHook.emit(ParseSymbolBegin)}
            let functionAt = self.rawSkip(LKeyword, "function").at()
            let signature = self.parseSignature(member = False)
            let body = if(self.lspHook.isEnabled() && !self.current().rawIs("{")) {
                let temporaryEffect = TConstructor(functionAt, "TemporaryEffect$", [])
                Lambda(functionAt, temporaryEffect, [])
            } else {
                self.parseLambda(defaultParameterCount = signature.parameters.size())
            }
            functions.push(DFunction(signature.at, signature, FireflyTarget(body)))
            if(self.lspHook.trackSymbols) {
                self.lspHook.emit(ParseSymbolEnd(
                    name = signature.name
                    kind = SFunction(member = False)
                    selectionStart = signature.at
                    selectionEnd = signature.at.Location(column = signature.at.column + signature.name.size())
                    start = functionAt
                    end = self.behind().end()                
                ))
            }            
            if(self.lspHook.isEnabled() && !self.currentIsSeparator(LSemicolon)) {} else {self.skipSeparator(LSemicolon)}
        }
        let body = self.parseStatements()
        EFunctions(at, functions.toList(), body)
    }

    parseTerm(): Term {
        self.parseBinary(0)
    }

    parseBinary(level: Int): Term {
        if(level >= binaryOperators.size()) {self.parseUnary()} else:
        let operators = binaryOperators.grab(level)
        mutable result = self.parseBinary(level + 1)
        if(self.current().is(LOperator)) {
            while {operators.any(self.current().rawIs)} {
                let token = self.skip(LOperator)
                let right = self.parseBinary(level + 1)
                let arguments = [Argument(result.at, None, result), Argument(right.at, None, right)]
                let effect = self.freshUnificationVariable(token.at())
                let target = token.raw().{
                    | "==" => DynamicCall(EVariable(token.at(), "ff:core/Equal.equals"), False)
                    | "!=" => DynamicCall(EVariable(token.at(), "ff:core/Equal.notEquals"), False)
                    | "<" => DynamicCall(EVariable(token.at(), "ff:core/Ordering.before"), False)
                    | "<=" => DynamicCall(EVariable(token.at(), "ff:core/Ordering.notAfter"), False)
                    | ">" => DynamicCall(EVariable(token.at(), "ff:core/Ordering.after"), False)
                    | ">=" => DynamicCall(EVariable(token.at(), "ff:core/Ordering.notBefore"), False)
                    | o => DynamicCall(EVariable(token.at(), o), False)
                }
                result = ECall(token.at(), target, effect, [], arguments, [])
            }
        }
        result
    }

    parseUnary(): Term {
        if(self.current().is2(LUnary, LOperator)) {
            let token = if(self.current().is(LUnary)) {self.skip(LUnary)} else {self.skip(LOperator)}
            let term = self.parseUnary()
            let effect = self.freshUnificationVariable(token.at())
            let target = DynamicCall(EVariable(token.at(), token.raw()), False)
            ECall(token.at(), target, effect, [], [Argument(term.at, None, term)], [])
        } else {
            self.parseFieldsAndCalls()
        }
    }

    parseFieldsAndCalls(): Term {
        let tailCall = if(self.current().is(LKeyword) && self.current().rawIs("tailcall")) {
            self.skip(LKeyword)
            True
        } else {False}
        mutable result = self.parseAtom()
        while {self.current().is5(LBracketLeft, LColon, LDot, LArrowThin, LUnary)} {
            if(self.current().is(LDot)) {
                self.skip(LDot)
                if(self.current().rawIs("{")) {
                    let term = self.parseAtom()
                    let effect = self.freshUnificationVariable(term.at)
                    result = EPipe(term.at, result, effect, term)
                } elseIf {self.current().is2(LUpper, LNamespace)} {
                    result = self.parseCopy(result)
                } else {
                    let token = self.skip(LLower)
                    result = EField(token.at(), False, result, token.raw())
                }
            } elseIf {self.current().is(LArrowThin)} {
                result = self.parseDynamicMember(result)
            } elseIf {self.current().is(LUnary)} {
                let token = self.skip(LUnary)
                let method = if(token.rawIs("!")) {"ff:core/UnsafeJs.value"} else {"ff:core/UnsafeJs.fromValue"}
                let target = DynamicCall(EVariable(token.at(), method), False)
                let effect = self.freshUnificationVariable(token.at())
                result = ECall(token.at(), target, effect, [], [
                    Argument(result.at, None, result)
                ], [])
            } else {
                let at = self.current().at()
                let typeArguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
                let arguments = self.parseFunctionArguments(result.at, True)
                let effect = self.freshUnificationVariable(at)
                let target = DynamicCall(result, tailCall)
                result = ECall(result.at, target, effect, typeArguments, arguments.first, [])
                if(arguments.second && self.current().is(LLower)) {
                    let token = self.skip(LLower)
                    result = EField(token.at(), False, result, token.raw())
                }
            }
        }
        result
    }
    
    parseDynamicMember(record: Term): Term {
        let token = self.skip(LArrowThin)
        if(self.current().rawIs("(")) {
            let arguments = self.parseFunctionArguments(token.at(), trailing = False)
            let effect = self.freshUnificationVariable(record.at)
            arguments.first.indexWhere {!_.name.isEmpty()}.{
                | None =>
                    let target = DynamicCall(EField(token.at(), False, record, "new" + arguments.first.size()), False)
                    ECall(record.at, target, effect, [], arguments.first, [])
                | Some(0) => 
                    let objectTarget = DynamicCall(EField(token.at(), False, record, "object"), False)
                    mutable result = ECall(record.at, objectTarget, effect, [], [], [])
                    arguments.first.each {argument =>
                        if(argument.name.isEmpty()) {
                            throw(CompileError(argument.at, "Expected a named argument"))
                        }
                        let target = DynamicCall(EField(token.at(), False, result, "with"), False)
                        result = ECall(record.at, target, effect, [], [
                            Argument(argument.at, None, EString(argument.at, "\"" + argument.name.grab() + "\""))
                            Argument(argument.value.at, None, argument.value)
                        ], [])
                    }
                    result
                | Some(i) => 
                    throw(CompileError(arguments.first.grab(i).at, "Unexpected named argument"))
            }
        } elseIf {self.current().rawIs("{")} {
            let lambda = self.parseLambda()
            let effect = self.freshUnificationVariable(record.at)
            let arguments = lambda.cases.grabFirst().patterns.size()
            let target = DynamicCall(EField(token.at(), False, record, "function" + arguments), False)
            ECall(record.at, target, effect, [], [
                Argument(lambda.at, None, ELambda(lambda.at, lambda))
            ], [])
        } else:
        let token = if(self.current().is(LLower)) {
            self.skip(LLower)
        } elseIf {self.current().is(LUpper)} {
            self.skip(LUpper)
        } else {
            self.skip(LString)
        }
        let member = EString(token.at(), if(token.is(LString)) {token.raw()} else {"\"" + token.raw() + "\""})
        if(self.current().rawIs("(")) {
            let arguments = self.parseFunctionArguments(record.at, False)
            arguments.first.find {!_.name.isEmpty()}.each {argument =>
                throw(CompileError(argument.at, "Unexpected named argument"))
            }
            let effect = self.freshUnificationVariable(record.at)
            let target = DynamicCall(EField(token.at(), False, record, "call" + arguments.first.size()), False)
            ECall(record.at, target, effect, [], [
                Argument(member.at, None, member)
                ...arguments.first
            ], [])
        } elseIf {self.current().is3(LAssign, LAssignPlus, LAssignMinus)} {
            let method = 
                if(self.current().is(LAssign)) {
                    self.skip(LAssign)
                    "set"
                } elseIf {self.current().is(LAssignPlus)} {
                    self.skip(LAssignPlus)
                    "increment"
                } else {
                    self.skip(LAssignMinus)
                    "decrement"
                }
            let value = self.parseTerm()
            let effect = self.freshUnificationVariable(record.at)
            let target = DynamicCall(EField(token.at(), False, record, method), False)
            ECall(record.at, target, effect, [], [
                Argument(member.at, None, member)
                Argument(value.at, None, value)
            ], [])
        } else {
            let effect = self.freshUnificationVariable(record.at)
            let target = DynamicCall(EField(token.at(), False, record, "get"), False)
            ECall(record.at, target, effect, [], [
                Argument(member.at, None, member)
            ], [])
        }
    }

    parseAtom(): Term {
        if(self.current().is(LString)) {
            let token = self.skip(LString)
            EString(token.at(), token.raw())
        } elseIf {self.current().is(LChar)} {
            let token = self.skip(LChar)
            EChar(token.at(), token.raw())
        } elseIf {self.current().is(LInt)} {
            let token = self.skip(LInt)
            EInt(token.at(), token.raw())
        } elseIf {self.current().is(LFloat)} {
            let token = self.skip(LFloat)
            EFloat(token.at(), token.raw())
        } elseIf {self.current().is(LLower)} {
            let token = self.skip(LLower)
            EVariable(token.at(), token.raw())
        } elseIf {self.current().is(LNamespace)} {
            let namespaceToken = self.skip(LNamespace)
            let extraNamespace = if(!self.current().is(LNamespace)) {None} else {Some(self.skip(LNamespace).raw())}
            let prefix = namespaceToken.raw() + extraNamespace.else {""}
            if(self.current().is(LLower)) {
                let token = self.skip(LLower)
                EVariable(token.at(), prefix + token.raw())
            } else {
                self.parseVariant(prefix)
            }
        } elseIf {self.current().is(LUpper)} {
            self.parseVariant("")
        } elseIf {self.current().rawIs("{")} {
            let lambda = self.parseLambda()
            ELambda(lambda.at, lambda)
        } elseIf {self.current().rawIs("[")} {
            self.parseList()
        } elseIf {self.current().rawIs("(") && self.ahead().is(LLower) && self.aheadAhead().is(LAssign)} {
            ERecord(self.current().at(), self.parseRecord(None))
        } elseIf {self.current().rawIs("(")} {
            self.rawSkip(LBracketLeft, "(")
            let result = self.parseTerm()
            while {self.lspHook.isEnabled() && self.currentIsSeparator(LComma)} {
                self.skipSeparator(LComma)
                if(!self.current().is(LBracketRight)) {self.parseTerm()}
            }
            self.rawSkip(LBracketRight, ")")
            result
        } elseIf {self.current().is(LWildcard)} {
            let token = self.skip(LWildcard)
            EWildcard(token.at(), 0)
        } else {
            throw(CompileError(self.current().at(), "Expected atom, got " + self.current().raw()))
        }
    }

    parseVariant(prefix: String): Term {
        let token = self.skip(LUpper)
        let name = prefix + token.raw()
        let typeArguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
        if(self.current().rawIs("?")) {self.skip(LOperator); EVariantIs(token.at(), name, typeArguments)} else:
        let arguments = Some(self.parseFunctionArguments(token.at(), True))
        EVariant(token.at(), name, typeArguments, arguments.map {_.first})
    }

    parseCopy(record: Term): Term {
        let namespace = if(!self.current().is(LNamespace)) {""} else {self.skip(LNamespace).raw()}
        let extraNamespace = if(!self.current().is(LNamespace)) {""} else {self.skip(LNamespace).raw()}
        let prefix = namespace + extraNamespace
        let token = self.skip(LUpper)
        let name = prefix + token.raw()
        let fields = if(self.lspHook.isEnabled() && !self.current().rawIs("(")) {[]} else {self.parseRecord(Some(token.at()))}
        ECopy(token.at(), name, record, fields)
    }

    parseRecord(copyAt: Option[Location]): List[Field] {
        let fields = Array.new[Field]()
        let startBracketAt = self.rawSkip(LBracketLeft, "(").at()
        let startAt = copyAt.else {startBracketAt}
        while {!self.current().is(LBracketRight)} {
            let fieldToken = self.skip(LLower)
            let field = if(!self.lspHook.isEnabled() || self.current().is(LAssign)) {
                self.skip(LAssign)
                Field(fieldToken.at(), fieldToken.raw(), self.parseTerm())
            } else {
                Field(fieldToken.at(), fieldToken.raw(), EVariable(fieldToken.at(), fieldToken.raw()))
            }
            if(self.lspHook.isEnabled() && !self.lspEmittedArgumentHook) {
                if(LspHook.strictlyBetween(startAt, self.current().at(), self.lspHook.at, 1)) {
                    self.lspHook.emit(ParseArgumentHook(startAt, fields.size(), Some(field.name).filter {_ != ""}))
                    self.lspEmittedArgumentHook = True
                }
            }
            fields.push(field)
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        if(self.lspHook.isEnabled() && !self.lspEmittedArgumentHook) {
            if(LspHook.strictlyBetween(startAt, self.current().at(), self.lspHook.at, 1)) {
                self.lspHook.emit(ParseArgumentHook(startAt, fields.size(), None))
                self.lspEmittedArgumentHook = True
            }
        }
        self.rawSkip(LBracketRight, ")")
        fields.toList()
    }

    parseRecordType(): List[Pair[String, Type]] {
        let fields = Array.new[Pair[String, Type]]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let fieldToken = self.skip(LLower)
            self.skipSeparator(LColon)
            fields.push(Pair(fieldToken.raw(), self.parseType()))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        fields.toList().sortBy {_.first}
    }

    parseRecordPattern(): List[Pair[String, MatchPattern]] {
        let fields = Array.new[Pair[String, MatchPattern]]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let fieldToken = self.skip(LLower)
            self.skip(LAssign)
            fields.push(Pair(fieldToken.raw(), self.parsePattern()))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        fields.toList().sortBy {_.first}
    }

    parseListPattern(): MatchPattern {
        function convertListPattern(at: Location, items: List[Pair[MatchPattern, Bool]]): MatchPattern {
            | _, [] => PVariant(at, "List$Empty", [])
            | _, [Pair(p, False), ...ps] =>
                PVariant(at, "List$Link", [p, convertListPattern(at, ps)])
            | _, [Pair(p, True)] => p
            | _, [Pair(p, True), ...] =>
                throw(CompileError(p.at, "Invalid pattern: ... is only allowed for the last element in a list"))
        }
        let items = Array.new[Pair[MatchPattern, Bool]]()
        let at = self.rawSkip(LBracketLeft, "[").at()
        while {!self.current().rawIs("]")} {
            let spread = self.current().is(LDotDotDot)
            if(spread) {self.skip(LDotDotDot)}
            let pattern = if(spread && self.current().rawIs("]")) {
                PVariable(self.current().at(), None)
            } else {
                self.parsePattern()
            }
            items.push(Pair(pattern, spread))
            if(!self.current().rawIs("]")) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, "]")
        convertListPattern(at, items.toList())
    }

    parseList(): Term {
        let items = Array.new[Pair[Term, Bool]]()
        let at = self.rawSkip(LBracketLeft, "[").at()
        while {!self.current().rawIs("]")} {
            let spread = self.current().is(LDotDotDot)
            if(spread) {self.skip(LDotDotDot)}
            items.push(Pair(self.parseTerm(), spread))
            if(!self.current().rawIs("]")) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, "]")
        EList(at, self.freshUnificationVariable(at), items.toList())
    }

}

binaryOperators = [
    ["||"]
    ["&&"]
    ["!=", "=="]
    ["<=", ">=", "<", ">"]
    ["+", "-"]
    ["*", "/", "%"]
    ["^"]
]

findBestTarget(targetIsNode: Bool, body: Option[Lambda], targets: ParsedTargets): Target {
    let foreignTarget = if(targetIsNode) {
        let sync = targets.nodeSync.orElse {targets.jsSync}
        let async = targets.nodeAsync.orElse {targets.jsAsync}
        ForeignTarget(sync, async)
    } else {
        let sync = targets.browserSync.orElse {targets.jsSync}
        let async = targets.browserAsync.orElse {targets.jsAsync}
        ForeignTarget(sync, async)
    }
    foreignTarget.{
        | ForeignTarget(None, None) {targetIsNode} =>
            targets.node.orElse {targets.js.orElse {body}}.map {FireflyTarget(_)}.else {foreignTarget}
        | ForeignTarget(None, None) {!targetIsNode} =>
            targets.browser.orElse {targets.js.orElse {body}}.map {FireflyTarget(_)}.else {foreignTarget}
        | _ => foreignTarget
    }
}
