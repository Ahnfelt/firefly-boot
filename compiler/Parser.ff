import Token
import Wildcards
import Syntax

type Parser(
    packagePair: Pair[String, String],
    file: String,
    tokens: Array[Token],
    end: Token,
    mutable offset: Int,
    mutable nextTypeVariableIndex: Int
)

type Poly(generics: List[String], constraints: List[Constraint])

make(packagePair: Pair[String, String], file: String, tokens: Array[Token]): Parser {
    Parser(
        packagePair,
        file,
        tokens,
        tokens.expectLast(),
        0,
        1 // Odd type variables to avoid collision with the unification
    )
}

extend self: Parser {

    fail[T](at: Location, message: String): T {
        panic(message + " " + at.show())
    }
    
    current(): Token {
        if(self.offset < self.tokens.getSize()) { self.tokens.expect(self.offset) } else { self.end }
    }
    
    ahead(): Token {
        if(self.offset + 1 < self.tokens.getSize()) { self.tokens.expect(self.offset + 1) } else { self.end }
    }
    
    aheadAhead(): Token {
        if(self.offset + 2 < self.tokens.getSize()) { self.tokens.expect(self.offset + 2) } else { self.end }
    }
    
    skip(kind: TokenKind): Token {
        let c = self.current()
        if(c.kind != kind) {
            self.fail(c.at(), "Expected " + magicShow(kind) + ", got " + c.raw())
        }
        self.offset += 1
        c
    }
    
    rawSkip(kind: TokenKind, value: String): Token {
        let c = self.current()
        if(c.kind != kind) {
            self.fail(c.at(), "Expected " + magicShow(kind) + " " + value + ", got " + c.raw())
        }
        if(!c.rawIs(value)) {
            self.fail(c.at(), "Expected " + value + " got " + c.raw())
        }
        self.offset += 1
        c
    }

    freshTypeVariable(at: Location): Type {
        let result = TVariable(at, self.nextTypeVariableIndex)
        self.nextTypeVariableIndex += 2
        result
    }
    
    currentIsSeparator(kind: TokenKind): Bool {
        self.current().is(kind) || self.current().is(LSeparator)
    }
    
    skipSeparator(kind: TokenKind): Token {
        if(self.current().is(LSeparator)) {
            self.skip(LSeparator)
        } else {
            self.skip(kind)
        }
    }
    
    parseModule(): Module {
        let dependencies = arrayBuilderOf[DDependency]
        let imports = arrayBuilderOf[DImport]
        let types = arrayBuilderOf[DType]
        let traits = arrayBuilderOf[DTrait]
        let instances = arrayBuilderOf[DInstance]
        let extends = arrayBuilderOf[DExtend]
        let lets = arrayBuilderOf[DLet]
        let functions = arrayBuilderOf[DFunction]
        while {!self.current().is(LEnd)} {
            if(self.current().is(LLower) && (self.ahead().is(LAssign) || self.ahead().is(LColon))) {
                lets.append(self.parseLetDefinition())
            } elseIf {self.current().is(LLower) && self.ahead().is(LBracketLeft)} {
                functions.append(self.parseFunctionDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("extend")} {
                extends.append(self.parseExtendDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("trait")} {
                traits.append(self.parseTraitDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("instance")} {
                instances.append(self.parseInstanceDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("type")} {
                types.append(self.parseTypeDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("import")} {
                imports.append(self.parseImportDefinition())
            } elseIf {
                self.current().is(LKeyword) &&
                (self.current().rawIs("safe") || self.current().rawIs("unsafe") || self.current().rawIs("trust"))
            } {
                dependencies.append(self.parseDependencyDefinition())
            } else {
                self.skip(LEnd)
            }
            if(!self.current().is(LEnd)) { self.skipSeparator(LSemicolon) }
        }
        Module(
            packagePair = self.packagePair,
            file = self.file,
            dependencies = dependencies.getList(),
            imports = imports.getList(),
            lets = lets.getList(),
            functions = functions.getList(),
            extends = extends.getList(),
            types = types.getList(),
            traits = traits.getList(),
            instances = instances.getList()
        )
    }
    
    parseLetDefinition(): DLet {
        let nameToken = self.skip(LLower)
        let variableType = if(self.current().is(LColon)) {
            self.skip(LColon)
            self.parseType()
        } else { self.freshTypeVariable(nameToken.at()) }
        self.skip(LAssign)
        let value = self.parseTerm()
        DLet(nameToken.at(), nameToken.raw(), variableType, value)
    }
    
    parseFunctionDefinition(): DFunction {
        let signature = self.parseSignature()
        let body = self.parseLambda(signature.parameters.getSize())
        DFunction(
            signature.at,
            signature,
            body
        )
    }
    
    parseSignature(): Signature {
        let nameToken = self.skip(LLower)
        let poly = if(self.current().rawIs("[")) {self.parseTypeParameters()} else {Poly([], [])}
        let parameters = self.parseFunctionParameters()
        let returnType = if(self.current().is(LColon)) {
            self.skip(LColon)
            self.parseType()
        } else {
            TConstructor(self.current().at(), "Unit", []) // TODO: Add qualified type names to resolver map and qualify this name
        }
        Signature(nameToken.at(), nameToken.raw(), poly.generics, poly.constraints, parameters, returnType)
    }
    
    parseExtendDefinition(): DExtend {
        self.rawSkip(LKeyword, "extend")
        let nameToken = self.skip(LLower)
        let poly = if(self.current().rawIs("[")) { self.parseTypeParameters() } else { Poly([], []) }
        self.skip(LColon)
        let type = self.parseType()
        self.rawSkip(LBracketLeft, "{")
        let methods = arrayBuilderOf[DFunction]()
        while { !self.current().is(LBracketRight) } {
            methods.append(self.parseFunctionDefinition())
            if(!self.current().is(LBracketRight)) { self.skipSeparator(LSemicolon) }
        }
        self.rawSkip(LBracketRight, "}")
        DExtend(
            nameToken.at(),
            nameToken.raw(),
            poly.generics,
            poly.constraints,
            type,
            methods.getList()
        )
    }
    
    parseTraitDefinition(): DTrait {
        self.rawSkip(LKeyword, "trait")
        let nameToken = self.skip(LUpper)
        let poly = if(!self.current().rawIs("[")) {Poly([], [])} else {self.parseTypeParameters()}
        let generatorParameters = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionParameters()}
        let methodGenerators = arrayBuilderOf[Pair[String, Lambda]]()
        let methodDefaults = arrayBuilderOf[Pair[String, Lambda]]()
        let methodSignatures = if(!self.current().rawIs("{")) {[]} else {
            let signatures = arrayBuilderOf[Signature]()
            self.rawSkip(LBracketLeft, "{")
            while {!self.current().is(LBracketRight)} {
                let signature = self.parseSignature()
                signatures.append(signature)
                if(self.current().rawIs("{")) {
                    let generator = self.ahead().is(LKeyword) && self.ahead().rawIs("generate")
                    let body = self.parseLambda(signature.parameters.getSize(), ignoreGenerateKeyword = True)
                    if(generator) {
                        methodGenerators.append(Pair(signature.name, body))
                    } else {
                        methodDefaults.append(Pair(signature.name, body))
                    }
                }
                if(!self.current().is(LBracketRight)) { self.skipSeparator(LSemicolon) }
            }
            self.rawSkip(LBracketRight, "}")
            signatures.getList()
        }
        DTrait(
            nameToken.at(),
            nameToken.raw(),
            poly.generics,
            poly.constraints,
            generatorParameters,
            methodSignatures,
            methodDefaults.getList(),
            methodGenerators.getList()
        )
    }
    
    parseInstanceDefinition(): DInstance {
        self.rawSkip(LKeyword, "instance")
        let nameToken = self.skip(LUpper)
        let typeArguments = arrayBuilderOf[Type]()
        self.rawSkip(LBracketLeft, "[")
        let token = self.skip(LUpper)
        let poly = if(!self.current().rawIs("[")) {Poly([], [])} else {self.parseTypeParameters()}
        typeArguments.append(TConstructor(token.at(), token.raw(), poly.generics.map { TConstructor(token.at(), _, []) }))
        while {self.current().is(LComma)} {
            self.skip(LComma)
            typeArguments.append(self.parseType())
        }
        self.rawSkip(LBracketRight, "]")
        let generatorArguments = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionArguments()}
        let methods = if(!self.current().rawIs("{")) {[]} else {
            let definitions = arrayBuilderOf[DFunction]()
            self.rawSkip(LBracketLeft, "{")
            while {!self.current().is(LBracketRight)} {
                definitions.append(self.parseFunctionDefinition())
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LSemicolon)}
            }
            self.rawSkip(LBracketRight, "}")
            definitions.getList()
        }
        let traitType = TConstructor(nameToken.at(), nameToken.raw(), typeArguments.getList())
        DInstance(nameToken.at(), poly.generics, poly.constraints, traitType, generatorArguments, methods)
    }
    
    parseTypeDefinition(): DType {
        self.rawSkip(LKeyword, "type")
        let nameToken = self.skip(LUpper)
        let poly = if(!self.current().rawIs("[")) {Poly([], [])} else {self.parseTypeParameters()}
        let commonFields = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionParameters(allowMutable = True)}
        let variants = if(!self.current().rawIs("{")) {[Variant(nameToken.at(), nameToken.raw(), [])]} else {
            self.rawSkip(LBracketLeft, "{")
            let variantsBuilder = arrayBuilderOf[Variant]()
            while {!self.current().is(LBracketRight)} {
                let variantNameToken = self.skip(LUpper)
                let variantFields = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionParameters(allowMutable = True)}
                variantsBuilder.append(Variant(variantNameToken.at(), variantNameToken.raw(), variantFields))
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LSemicolon)}
            }
            self.rawSkip(LBracketRight, "}")
            variantsBuilder.getList()
        }
        DType(nameToken.at(), nameToken.raw(), poly.generics, poly.constraints, commonFields, variants)
    }
    
    parseImportDefinition(): DImport {
        let importToken = self.rawSkip(LKeyword, "import")
        let path = arrayBuilderOf[String]()
        while { self.current().is(LLower) } {
            path.append(self.parseDashedName())
            self.skip(LDot)
        }
        let file = self.skip(LUpper).raw()
        let alias = if(self.current().rawIs("as")) {
            self.rawSkip(LKeyword, "as")
            self.skip(LUpper).raw()
        } else { file }
        let package = if(self.current().rawIs("from")) {
            self.rawSkip(LKeyword, "from")
            let userName = self.parseDashedName()
            self.skip(LColon)
            let packageName = self.parseDashedName()
            Pair(userName, packageName)
        } else {
            self.packagePair
        }
        DImport(importToken.at(), alias, package, path.getList(), file)
    }
    
    parseDependencyDefinition(): DDependency {
        let safety = (
            if(self.current().rawIs("safe")) { Safe } else:
            if(self.current().rawIs("unsafe")) { Unsafe } else:
            Trust
        )
        let at = self.skip(LKeyword).at()
        let user = self.skip(LLower).raw()
        self.skip(LColon)
        let name = self.skip(LLower).raw()
        let goodVersions = arrayBuilderOf[Version]()
        let badVersions = arrayBuilderOf[Version]()
        if(self.current().rawIs("(")) {
            self.skip(LBracketLeft)
            while { !self.current().is(LBracketRight) } {
                let bad = self.current().rawIs("!")
                if(bad) { self.skip(LOperator) }
                let version = self.parseVersion()
                if(bad) { badVersions.append(version) } else { goodVersions.append(version) }
                if(!self.current().is(LBracketRight)) { self.skip(LComma) }
            }
            self.skip(LBracketRight)
        }
        DDependency(at, Pair(user, name), safety, goodVersions.getList(), badVersions.getList())
    }
    
    parseVersion(): Version {
        if(self.current().is(LFloat)) {
            let majorMinor = self.skip(LFloat)
            let parts = majorMinor.raw().split('.')
            let patch = if(self.current().is(LDot)) {
                 self.skip(LDot)
                 self.skip(LInt).raw().expectInt()
            } else { 0 }
            Version(majorMinor.at(), parts.expect(0).expectInt(), parts.expect(1).expectInt(), patch)
        } else {
            let major = self.skip(LInt)
            Version(major.at(), major.raw().expectInt(), 0, 0)
        }
    }
    
    parseDashedName(): String {
        let at = self.current().at()
        function readPart(): String {
            if(self.current().is(LInt)) {
                let prefix = self.skip(LInt).raw()
                if(self.current().is(LLower)) { prefix + self.skip(LLower).raw() } else { prefix }
            } else {
                self.skip(LLower).raw()
            }
        }
        mutable part = readPart()
        while { self.current().rawIs("-") } {
            self.skip(LOperator)
            part = part + "-" + readPart()
        }
        if(part.exists { _.getIsUpper() }) {
            self.fail(at, "Package names and paths must not contain upper case letters: " + part)
        }
        if(part.exists { _ == '_' } || part.exists { _ == '.' }) {
            self.fail(at, "Package names and paths must not contain underscores or dots: " + part)
        }
        part
    }
    
    parseTypeParameters(): Poly {
        self.rawSkip(LBracketLeft, "[")
        let parameters = arrayBuilderOf[String]()
        let constraints = arrayBuilderOf[Constraint]()
        while {!self.current().is(LBracketRight) && !self.current().is(LSemicolon)} {
            if(self.ahead().is(LBracketLeft)) {
                constraints.append(Constraint(self.parseType()))
            } else {
                let parameterNameToken = self.skip(LUpper)
                parameters.append(parameterNameToken.raw())
                while {self.current().is(LColon)} {
                    self.skip(LColon)
                    self.parseType().{
                        | TVariable t => self.fail(t.at, "Unexpected type variable: $" + t.index)
                        | TConstructor t =>
                            constraints.append(Constraint(t.TConstructor(generics =
                                [TConstructor(t.at, parameterNameToken.raw(), []), ...t.generics]
                            )))
                    }
                }
            }
            if(!self.current().is(LBracketRight)) { self.skip(LComma) }
        }
        if(self.current().is(LSemicolon)) {
            self.skip(LSemicolon)
            while {!self.current().is(LBracketRight)} {
                constraints.append(Constraint(self.parseType()))
                if(!self.current().is(LBracketRight)) { self.skip(LComma) }
            }
        }
        self.rawSkip(LBracketRight, "]")
        Poly(parameters.getList(), constraints.getList())
    }
    
    parseTypeArguments(parenthesis: Bool = False): List[Type] {
        self.rawSkip(LBracketLeft, if(parenthesis) {"("} else {"["})
        let types = arrayBuilderOf[Type]()
        while {!self.current().is(LBracketRight)} {
            types.append(self.parseType())
            if(!self.current().is(LBracketRight)) {self.skip(LComma)}
        }
        self.rawSkip(LBracketRight, if(parenthesis) {")"} else {"]"})
        types.getList()
    }
    
    parseFunctionParameters(allowMutable: Bool = False): List[Parameter] {
        let parameters = arrayBuilderOf[Parameter]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let mutable = allowMutable && self.current().is(LKeyword) && self.current().rawIs("mutable")
            if(mutable) {self.skip(LKeyword)}
            let parameterNameToken = self.skip(LLower)
            self.skip(LColon)
            let parameterType = self.parseType()
            let default = if(!self.current().is(LAssign)) {None} else {
                self.skip(LAssign)
                Some(self.parseTerm())
            }
            parameters.append(Parameter(parameterNameToken.at(), mutable, parameterNameToken.raw(), parameterType, default))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        parameters.getList()
    }
    
    parseFunctionArguments(): List[Argument] {
        self.rawSkip(LBracketLeft, "(")
        let arguments = arrayBuilderOf[Argument]()
        while {!self.current().is(LBracketRight)} {
            let nameToken = if(self.current().is(LLower) && self.ahead().is(LAssign)) {
                let token = self.skip(LLower)
                self.skip(LAssign)
                Some(token)
            } else {None}
            let value = self.parseTerm()
            arguments.append(Argument(nameToken.map{_.at()}.getOrElse(value.at), nameToken.map{_.raw()}, value))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        arguments.getList()
    }
    
    parseLambda(
        defaultParameterCount: Int = 0,
        ignoreGenerateKeyword: Bool = False,
        allowColon: Bool = False
    ): Lambda {
        let colon = allowColon && self.current().is(LColon)
        let token = if(colon) {self.skip(LColon)} else {self.rawSkip(LBracketLeft, "{")}
        if(ignoreGenerateKeyword && self.current().is(LKeyword) && self.current().rawIs("generate")) {self.skip(LKeyword)}
        let result = if(self.current().is(LPipe)) {
            let cases = arrayBuilderOf[MatchCase]()
            while {self.current().is(LPipe)} {
                cases.append(self.parseCase())
            }
            cases.getList()
        } elseIf {self.current().is(LLower) && self.ahead().is2(LComma, LArrowThick)} {
            let parameters = arrayBuilderOf[MatchPattern]()
            while {!self.current().is(LArrowThick)} {
                let parameterToken = self.skip(LLower)
                parameters.append(PVariable(parameterToken.at(), Some(parameterToken.raw())))
                if(!self.current().is(LArrowThick)) {self.skip(LComma)}
            }
            self.skip(LArrowThick)
            let term = self.parseStatements()
            [MatchCase(token.at(), parameters.getList(), None, term)]
        } else {
            let term = self.parseStatements()
            let wildcards = Wildcards.make()
            let e = wildcards.fixWildcards(term)
            let arguments = if(wildcards.seenWildcards != 0) {
                1.getTo(wildcards.seenWildcards).map { i => PVariable(token.at(), Some("_w" + i)) }
            } else {
                1.getTo(defaultParameterCount).map { i => PVariable(token.at(), None) }
            }
            [MatchCase(token.at(), arguments, None, e)]
        }
        if(!colon) {self.rawSkip(LBracketRight, "}")}
        Lambda(token.at(), result)
    }
    
    parseCase(): MatchCase {
        let token = self.skip(LPipe)
        let patterns = arrayBuilderOf[MatchPattern]()
        while {!self.current().is(LArrowThick) && !self.current().rawIs("{")} {
            patterns.append(self.parsePattern())
            if(!self.current().is(LArrowThick) && !self.current().rawIs("{")) {self.skip(LComma)}
        }
        let condition = if(!self.current().rawIs("{")) {None} else {
            self.skip(LBracketLeft)
            let term = self.parseStatements()
            self.skip(LBracketRight)
            Some(term)
        }
        self.skip(LArrowThick)
        let body = self.parseStatements()
        MatchCase(token.at(), patterns.getList(), condition, body)
    }
    
    parsePattern(): MatchPattern {
        let pattern = if(self.current().is(LWildcard)) {
            let token = self.skip(LWildcard)
            PVariable(token.at(), None)
        } elseIf {self.current().is(LLower)} {
            let token = self.skip(LLower)
            PVariable(token.at(), Some(token.raw()))
        } elseIf {self.current().rawIs("(")} {
            let at = self.current().at()
            let pair = self.parseRecordPattern().getUnzip()
            PVariant(at, "Record$" + pair.first.join("$"), pair.second)
        } elseIf {self.current().rawIs("[")} {
            self.parseListPattern()
        } else {
            let token = self.skip(LUpper)
            if(self.current().rawIs("(")) {
                let patterns = arrayBuilderOf[MatchPattern]()
                self.rawSkip(LBracketLeft, "(")
                while {!self.current().is(LBracketRight)} {
                    patterns.append(self.parsePattern())
                    if(!self.current().is(LBracketRight)) {self.skip(LComma)}
                }
                self.rawSkip(LBracketRight, ")")
                PVariant(token.at(), token.raw(), patterns.getList())
            } else {
                if(self.current().is(LLower)) {
                    let asToken = self.skip(LLower)
                    PVariantAs(token.at(), token.raw(), Some(asToken.raw()))
                } elseIf { self.current().is(LWildcard) } {
                    self.skip(LWildcard)
                    PVariantAs(token.at(), token.raw(), None)
                } else {
                    PVariant(token.at(), token.raw(), [])
                }
            }
        }
        if(self.current().rawIs("@")) {
            let atToken = self.skip(LOperator)
            let asToken = self.skip(LLower)
            PAlias(atToken.at(), pattern, asToken.raw())
        } else { pattern }
    }
    
    parseType(): Type {
        let leftTypes = if(self.current().rawIs("(") && self.ahead().is(LLower) && self.aheadAhead().is(LColon)) {
            let at = self.current().at()
            let pair = self.parseRecordType().getUnzip()
            [TConstructor(at, "Record$" + pair.first.join("$"), pair.second)]
        } elseIf {self.current().rawIs("(")} {
            self.parseTypeArguments(parenthesis = True)
        } else {
            let namespace = if(self.current().is(LNamespace)) {self.skip(LNamespace).raw()} else {""}
            let token = self.skip(LUpper)
            let arguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
            [TConstructor(token.at(), namespace + token.raw(), arguments)]
        }
        if(!self.current().is(LArrowThick) && leftTypes.getSize() == 1) {leftTypes.expectFirst()} else {
            let arrowToken = self.skip(LArrowThick)
            let rightType = self.parseType()
            TConstructor(arrowToken.at(), "Function$" + leftTypes.getSize(), [...leftTypes, rightType])
        }
    }
    
    parseStatements(): Term {
        if(self.current().is2(LBracketRight, LPipe)) {EVariant(self.current().at(), "Unit", [], None)} else {
            mutable result = self.parseStatement()
            while {self.currentIsSeparator(LSemicolon)} {
                let token = self.skipSeparator(LSemicolon)
                result = ESequential(token.at(), result, self.parseStatement())
            }
            result
        }
    }
    
    parseStatement(): Term {
        if(self.current().is(LKeyword) && (self.current().rawIs("let") || self.current().rawIs("mutable"))) {self.parseLet()} else:
        if(self.current().is(LKeyword) && self.current().rawIs("function")) {self.parseFunctions()} else:
        let term = self.parseTerm()
        if(!self.current().is(LAssign) && !self.current().is3(LAssignPlus, LAssignMinus, LAssignLink)) {term} else:
        let token = do {
            if(self.current().is(LAssignPlus)) {self.skip(LAssignPlus)} else:
            if(self.current().is(LAssignMinus)) {self.skip(LAssignMinus)} else:
            if(self.current().is(LAssignLink)) {self.skip(LAssignLink)} else:
            self.skip(LAssign)
        }
        let operator = token.raw().dropLast(1)
        let value = self.parseTerm()
        term.{
            | EVariable(_, name, _, _) => EAssign(token.at(), operator, name, value)
            | EField e => EAssignField(token.at(), operator, e.record, e.field, value)
            | _ => self.fail(token.at(), "Only variables and fields are assignable")
        }
    }
    
    parseLet(): Term {
        let mutable = self.current().rawIs("mutable")
        if(mutable) {self.rawSkip(LKeyword, "mutable")} else {self.rawSkip(LKeyword, "let")}
        let nameToken = self.skip(LLower)
        let valueType = if(!self.current().is(LColon)) { self.freshTypeVariable(nameToken.at()) } else {
            self.skip(LColon)
            self.parseType()
        }
        self.skip(LAssign)
        let value = self.parseTerm()
        self.skipSeparator(LSemicolon)
        let body = self.parseStatements()
        ELet(nameToken.at(), mutable, nameToken.raw(), valueType, value, body)
    }
    
    parseFunctions(): Term {
        let at = self.current().at()
        let functions = arrayBuilderOf[DFunction]()
        while {self.current().rawIs("function")} {
            let functionAt = self.rawSkip(LKeyword, "function").at()
            let signature = self.parseSignature()
            let body = self.parseLambda(defaultParameterCount = signature.parameters.getSize())
            functions.append(DFunction(functionAt, signature, body))
            self.skipSeparator(LSemicolon)
        }
        let body = self.parseStatements()
        EFunctions(at, functions.getList(), body)
    }
    
    parseTerm(): Term {
        self.parseBinary(0)
    }
    
    parseBinary(level: Int): Term {
        if(level >= binaryOperators.getSize()) {self.parseUnary()} else:
        let operators = binaryOperators.expect(level)
        mutable result = self.parseBinary(level + 1)
        if(self.current().is(LOperator)) {
            while {operators.exists(self.current().rawIs)} {
                let token = self.skip(LOperator)
                let right = self.parseBinary(level + 1)
                let arguments = [Argument(result.at, None, result), Argument(right.at, None, right)]
                result = ECall(token.at(), EVariable(token.at(), token.raw(), [], []), [], arguments)
            }
        }
        result
    }
    
    parseUnary(): Term {
        if(self.current().is(LOperator)) {
            let token = self.skip(LOperator)
            let term = self.parseUnary()
            ECall(token.at(), EVariable(token.at(), token.raw(), [], []), [], [Argument(term.at, None, term)])
        } else {
            self.parseFieldsAndCalls()
        }
    }
    
    parseFieldsAndCalls(): Term {
        mutable result = self.parseAtom()
        while {self.current().is(LBracketLeft) || self.current().is(LColon) || self.current().is(LDot)} {
            if(self.current().is(LDot)) {
                self.skip(LDot)
                if(self.current().rawIs("{")) {
                    let term = self.parseAtom()
                    result = EPipe(term.at, result, term)
                } elseIf {self.current().is2(LUpper, LNamespace)} {
                    result = self.parseCopy(result)
                } else {
                    let token = self.skip(LLower)
                    result = EField(token.at(), result, token.raw())
                }
            } else {
                let at = self.current().at()
                let typeArguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
                let arguments = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionArguments()}
                let moreArguments = arrayBuilderOf[Argument]()
                mutable lastWasCurly = False
                while {self.current().rawIs("{") || self.current().is(LColon)} {
                    lastWasCurly = self.current().rawIs("{")
                    let lambda = self.parseLambda(allowColon = True)
                    moreArguments.append(Argument(lambda.at, None, ELambda(lambda.at, lambda)))
                }
                result = ECall(at, result, typeArguments, [...arguments, ...moreArguments.getList()])
                if(lastWasCurly && self.current().is(LLower)) {
                    let token = self.skip(LLower)
                    result = EField(token.at(), result, token.raw())
                }
            }
        }
        result
    }
    
    parseAtom(): Term {
        if(self.current().is(LString)) {
            let token = self.skip(LString)
            EString(token.at(), token.raw())
        } elseIf {self.current().is(LChar)} {
            let token = self.skip(LChar)
            EChar(token.at(), token.raw())
        } elseIf {self.current().is(LInt)} {
            let token = self.skip(LInt)
            EInt(token.at(), token.raw())
        } elseIf {self.current().is(LFloat)} {
            let token = self.skip(LFloat)
            EFloat(token.at(), token.raw())
        } elseIf {self.current().is(LLower)} {
            let token = self.skip(LLower)
            EVariable(token.at(), token.raw(), [], [])
        } elseIf {self.current().is(LNamespace)} {
            let namespaceToken = self.skip(LNamespace)
            let extraNamespace = if(!self.current().is(LNamespace)) {None} else {Some(self.skip(LNamespace).raw())}
            let prefix = namespaceToken.raw() + extraNamespace.getOrElse("")
            if(self.current().is(LLower)) {
                let token = self.skip(LLower)
                EVariable(token.at(), prefix + token.raw(), [], [])
            } else {
                self.parseVariant(prefix)
            }
        } elseIf {self.current().is(LUpper)} {
            self.parseVariant("")
        } elseIf {self.current().rawIs("{")} {
            let lambda = self.parseLambda()
            ELambda(lambda.at, lambda)
        } elseIf {self.current().rawIs("[")} {
            self.parseList()
        } elseIf {self.current().rawIs("(") && self.ahead().is(LLower) && self.aheadAhead().is(LAssign)} {
            ERecord(self.current().at(), self.parseRecord())
        } elseIf {self.current().rawIs("(")} {
            self.rawSkip(LBracketLeft, "(")
            let result = self.parseTerm()
            self.rawSkip(LBracketRight, ")")
            result
        } elseIf {self.current().is(LWildcard)} {
            let token = self.skip(LWildcard)
            EWildcard(token.at(), 0)
        } else {
            self.fail(self.current().at(), "Expected atom, got " + self.current().raw())
        }
    }
    
    parseVariant(prefix: String): Term {
        let token = self.skip(LUpper)
        let name = prefix + token.raw()
        let typeArguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
        if(self.current().rawIs("?")) { self.skip(LOperator); EVariantIs(token.at(), name, typeArguments) } else:
        let arguments = if(!self.current().rawIs("(")) {None} else {Some(self.parseFunctionArguments())}
        EVariant(token.at(), name, typeArguments, arguments)
    }
    
    parseCopy(record: Term): Term {
        let namespace = if(!self.current().is(LNamespace)) {""} else {self.skip(LNamespace).raw()}
        let extraNamespace = if(!self.current().is(LNamespace)) {""} else {self.skip(LNamespace).raw()}
        let prefix = namespace + extraNamespace
        let token = self.skip(LUpper)
        let name = prefix + token.raw()
        let fields = self.parseRecord()
        ECopy(token.at(), name, record, fields)
    }
    
    parseRecord(): List[Field] {
        let fields = arrayBuilderOf[Field]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let fieldToken = self.skip(LLower)
            self.skip(LAssign)
            fields.append(Field(fieldToken.at(), fieldToken.raw(), self.parseTerm()))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        fields.getList()
    }
    
    parseRecordType(): List[Pair[String, Type]] {
        let fields = arrayBuilderOf[Pair[String, Type]]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let fieldToken = self.skip(LLower)
            self.skipSeparator(LColon)
            fields.append(Pair(fieldToken.raw(), self.parseType()))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        fields.getList().sortBy { _.first }
    }
    
    parseRecordPattern(): List[Pair[String, MatchPattern]] {
        let fields = arrayBuilderOf[Pair[String, MatchPattern]]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let fieldToken = self.skip(LLower)
            self.skip(LAssign)
            fields.append(Pair(fieldToken.raw(), self.parsePattern()))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        fields.getList().sortBy { _.first }
    }

    parseListPattern(): MatchPattern {
        let items = arrayBuilderOf[Pair[MatchPattern, Bool]]()
        let at = self.rawSkip(LBracketLeft, "[").at()
        while {!self.current().rawIs("]")} {
            let spread = self.current().is(LDotDotDot)
            if(spread) { self.skip(LDotDotDot) }
            let pattern = if(spread && self.current().rawIs("]")) {
                PVariable(self.current().at(), None)
            } else {
                self.parsePattern()
            }
            items.append(Pair(pattern, spread))
            if(!self.current().rawIs("]")) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, "]")
        PList(at, self.freshTypeVariable(at), items.getList())
    }

    parseList(): Term {
        let items = arrayBuilderOf[Pair[Term, Bool]]()
        let at = self.rawSkip(LBracketLeft, "[").at()
        while {!self.current().rawIs("]")} {
            let spread = self.current().is(LDotDotDot)
            if(spread) { self.skip(LDotDotDot) }
            items.append(Pair(self.parseTerm(), spread))
            if(!self.current().rawIs("]")) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, "]")
        EList(at, self.freshTypeVariable(at), items.getList())
    }

}

binaryOperators = [
    ["||"]
    ["&&"]
    ["!=", "=="]
    ["<=", ">=", "<", ">"]
    ["++"]
    ["+", "-"]
    ["*", "/", "%"]
    ["^"]
].getArray()
