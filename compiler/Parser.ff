type Parser(
    file: String,
    tokens: Array[Token],
    end: Token,
    mutable offset: Int
)

Parser_of(file: String, tokens: Array[Token]): Parser {
    Parser(
        file,
        tokens,
        tokens.last,
        0
    )
}

Parser_fail[T](self: Parser, at: Location, message: String): T {
    panic(message + " " + at.show)
}

Parser_current(self: Parser): Token {
    if(self.offset < self.tokens.length) { self.tokens(self.offset) } else { self.end }
}

Parser_ahead(self: Parser): Token {
    if(self.offset + 1 < self.tokens.length) { self.tokens(self.offset + 1) } else { self.end }
}

Parser_aheadAhead(self: Parser): Token {
    if(self.offset + 2 < self.tokens.length) { self.tokens(self.offset + 2) } else { self.end }
}

Parser_skip(self: Parser, kind: TokenKind): Token {
    let c = self.current
    if(c.kind != kind) {
        self.fail(c.at, "Expected " + kind + ", got " + c.raw)
    }
    self.offset += 1
    c
}

Parser_rawSkip(self: Parser, kind: TokenKind, value: String): Token {
    let c = self.current
    if(c.kind != kind) {
        self.fail(c.at, "Expected " + kind + " " + value + ", got " + c.raw)
    }
    if(!c.rawIs(value)) {
        self.fail(c.at, "Expected " + value + " got " + c.raw)
    }
    self.offset += 1
    c
}

Parser_currentIsSeparator(self: Parser, kind: TokenKind): Bool {
    self.current.is(kind) || self.current.is(LSeparator)
}

Parser_skipSeparator(self: Parser, kind: TokenKind): Unit {
    if(self.current.is(LSeparator)) {
        self.skip(LSeparator)
    } else {
        self.skip(kind)
    }
}

/*
Parser_parseModule(self: Parser): Module {
    mutable result = Module(file, List(), List(), List(), List(), List())
    while {!self.current.is(LEnd)} {
        if(self.current.is(LLower) && (self.ahead.is(LAssign) || self.ahead.is(LColon))) {
            result = result.Module(lets = parseLetDefinition() :: result.lets)
        } elseIf {self.current.is(LNamespace) && self.ahead.is(LLower) && self.aheadAhead.is2(LAssign, LColon)} {
            val namespace = Some(skip(LNamespace).raw)
            result = result.Module(lets = parseLetDefinition(namespace) :: result.lets)
        } elseIf {self.current.is(LLower) && self.ahead.is(LBracketLeft)} {
            result = result.Module(functions = parseFunctionDefinition() :: result.functions)
        } elseIf {self.current.is(LNamespace) && self.ahead.is(LLower) && self.aheadAhead.is(LBracketLeft)} {
            val namespace = Some(skip(LNamespace).raw)
            result = result.Module(functions = parseFunctionDefinition(namespace) :: result.functions)
        } elseIf {self.current.is(LKeyword) && self.current.rawIs("trait")} {
            result = result.Module(traits = parseTraitDefinition() :: result.traits)
        } elseIf {self.current.is(LKeyword) && self.current.rawIs("instance")} {
            result = result.Module(instances = parseInstanceDefinition() :: result.instances)
        } elseIf {self.current.is(LKeyword) && self.current.rawIs("type")} {
            result = result.Module(types = parseTypeDefinition() :: result.types)
        } else {
            skip(LEnd)
        }
        if(!self.current.is(LEnd)) skipSeparator(LSemicolon)
    }
    Module(
        file = file,
        lets = result.lets.reverse,
        functions = result.functions.reverse,
        types = result.types.reverse,
        traits = result.traits.reverse,
        instances = result.instances.reverse
    )
}

Parser_parseLetDefinition(scopeType : Option[String] = None) : DLet {
    val nameToken = skip(LLower)
    val variableType = if(self.current.is(LColon)) {
        skip(LColon)
        parseType()
    } else Type(nameToken.at, "?", List())
    skip(LAssign)
    val value = parseTerm()
    DLet(nameToken.at, scopeType, nameToken.raw, variableType, value)
}

Parser_parseFunctionDefinition(scopeType : Option[String] = None) : DFunction {
    val signature = parseSignature(scopeType)
    val body = parseLambda(signature.parameters.size)
    DFunction(
        signature.at,
        scopeType,
        signature,
        body
    )
}

Parser_parseSignature(scopeType : Option[String] = None) : Signature {
    val nameToken = skip(LLower)
    val (generics, constraints) = if(self.current.rawIs("[")) parseTypeParameters() else List() -> List()
    val parameters = parseFunctionParameters()
    val returnType = parseOptionalType()
    Signature(nameToken.at, nameToken.raw, generics, constraints, parameters, returnType)
}

Parser_parseTraitDefinition(self: Parser): DTrait {
    skip(LKeyword, "trait")
    val nameToken = skip(LUpper)
    val (generics, constraints) = if(!self.current.rawIs("[")) List() -> List() else parseTypeParameters()
    val generatorParameters = if(!self.current.rawIs("(")) List() else parseFunctionParameters()
    var methodGenerators = List[(String, Term)]()
    var methodDefaults = List[(String, Term)]()
    val methodSignatures = if(!self.current.rawIs("{")) List() else {
        var signatures = List[Signature]()
        skip(LBracketLeft, "{")
        while {!self.current.is(LBracketRight)} {
            val signature = parseSignature(Some(nameToken.raw))
            signatures ::= signature
            if(self.current.rawIs("{")) {
                val generator = self.ahead.is(LKeyword) && self.ahead.rawIs("generate")
                val body = parseLambda(signature.parameters.size, ignoreGenerateKeyword = true)
                if(generator) {
                    methodGenerators ::= signature.name -> body
                } else {
                    methodDefaults ::= signature.name -> body
                }
            }
            if(!self.current.is(LBracketRight)) skipSeparator(LSemicolon)
        }
        skip(LBracketRight, "}")
        signatures
    }
    DTrait(
        nameToken.at,
        nameToken.raw,
        generics,
        constraints,
        generatorParameters,
        methodSignatures.reverse,
        methodDefaults.reverse,
        methodGenerators.reverse
    )
}

Parser_parseInstanceDefinition(self: Parser): DInstance {
    skip(LKeyword, "instance")
    val nameToken = skip(LUpper)
    var typeArguments = List[Type]()
    skip(LBracketLeft, "[")
    val token = skip(LUpper)
    val (typeParameters, constraints) = if(!self.current.rawIs("[")) List() -> List() else parseTypeParameters()
    typeArguments ::= Type(token.at, token.raw, typeParameters.map(p => Type(token.at, p, List())))
    while {self.current.is(LComma)} {
        skip(LComma)
        typeArguments ::= parseType()
    }
    skip(LBracketRight, "]")
    val generatorArguments = if(!self.current.rawIs("(")) List() else parseFunctionArguments()
    val methods = if(!self.current.rawIs("{")) List() else {
        var definitions = List[DFunction]()
        skip(LBracketLeft, "{")
        while {!self.current.is(LBracketRight)} {
            definitions ::= parseFunctionDefinition(Some(nameToken.raw))
            if(!self.current.is(LBracketRight)) skipSeparator(LSemicolon)
        }
        skip(LBracketRight, "}")
        definitions
    }
    val traitType = Type(nameToken.at, nameToken.raw, typeArguments.reverse)
    DInstance(nameToken.at, typeParameters, constraints, traitType, generatorArguments, methods)
}

Parser_parseTypeDefinition(self: Parser): DType {
    skip(LKeyword, "type")
    val nameToken = skip(LUpper)
    val (generics, constraints) = if(!self.current.rawIs("[")) List() -> List() else parseTypeParameters()
    val commonFields = if(!self.current.rawIs("(")) List() else parseFunctionParameters(allowMutable = true)
    val variants = if(!self.current.rawIs("{")) List(Variant(nameToken.at, nameToken.raw, List())) else {
        skip(LBracketLeft, "{")
        var reverseVariants = List[Variant]()
        while {!self.current.is(LBracketRight)} {
            val variantNameToken = skip(LUpper)
            val variantFields = if(!self.current.rawIs("(")) List() else parseFunctionParameters(allowMutable = true)
            reverseVariants ::= Variant(variantNameToken.at, variantNameToken.raw, variantFields)
            if(!self.current.is(LBracketRight)) skipSeparator(LSemicolon)
        }
        skip(LBracketRight, "}")
        reverseVariants.reverse
    }
    DType(nameToken.at, nameToken.raw, generics, constraints, commonFields, variants)
}

Parser_parseTypeParameters(self: Parser): (List[String], List[Constraint]) {
    skip(LBracketLeft, "[")
    var parameters = List[String]()
    var constraints = List[Constraint]()
    while {!self.current.is(LBracketRight) && !self.current.is(LSemicolon)} {
        if(self.ahead.is(LBracketLeft)) {
            constraints ::= Constraint(parseType())
        } else {
            val parameterNameToken = skip(LUpper)
            parameters ::= parameterNameToken.raw
            while {self.current.is(LColon)} {
                skip(LColon)
                val t = parseType()
                constraints ::= Constraint(t.copy(generics =
                    Type(t.at, parameterNameToken.raw, List()) :: t.generics
                ))
            }
        }
        if(!self.current.is(LBracketRight)) skip(LComma)
    }
    if(self.current.is(LSemicolon)) {
        skip(LSemicolon)
        while {!self.current.is(LBracketRight)} {
            constraints ::= Constraint(parseType())
            if(!self.current.is(LBracketRight)) skip(LComma)
        }
    }
    skip(LBracketRight, "]")
    parameters.reverse -> constraints.reverse
}

Parser_parseTypeArguments(parenthesis : Boolean = false) : List[Type] {
    skip(LBracketLeft, if(parenthesis) "(" else "[")
    var types = List[Type]()
    while {!self.current.is(LBracketRight)} {
        types ::= parseType()
        if(!self.current.is(LBracketRight)) skip(LComma)
    }
    skip(LBracketRight, if(parenthesis) ")" else "]")
    types.reverse
}

Parser_parseFunctionParameters(allowMutable : Boolean = false) : List[Parameter] {
    var parameters = List[Parameter]()
    skip(LBracketLeft, "(")
    while {!self.current.is(LBracketRight)} {
        val mutable = allowMutable && self.current.is(LKeyword) && self.current.rawIs("mutable")
        if(mutable) skip(LKeyword)
        val parameterNameToken = skip(LLower)
        val parameterType = parseOptionalType()
        val default = if(!self.current.is(LAssign)) None else Some {
            skip(LAssign)
            parseTerm()
        }
        parameters ::= Parameter(parameterNameToken.at, mutable, parameterNameToken.raw, parameterType, default)
        if(!self.current.is(LBracketRight)) skipSeparator(LComma)
    }
    skip(LBracketRight, ")")
    parameters.reverse
}

Parser_parseFunctionArguments(self: Parser): List[Term] {
    skip(LBracketLeft, "(")
    var arguments = List[Term]()
    while {!self.current.is(LBracketRight)} {
        arguments ::= parseTerm()
        if(!self.current.is(LBracketRight)) skipSeparator(LComma)
    }
    skip(LBracketRight, ")")
    arguments.reverse
}

Parser_parseOptionalType(self: Parser): Type {
    val token = current
    if(token.is(LColon)) {
        skip(LColon)
        parseType()
    } else Type(token.at, "?", List())
}

Parser_parseLambda(
    self: Parser,
    defaultParameterCount : Int = 0,
    ignoreGenerateKeyword : Boolean = false,
    allowColon : Boolean = false
) : ELambda {
    val colon = allowColon && self.current.is(LColon)
    val token = if(colon) skip(LColon) else skip(LBracketLeft, "{")
    if(ignoreGenerateKeyword && self.current.is(LKeyword) && self.current.rawIs("generate")) skip(LKeyword)
    val result = if(self.current.is(LPipe)) {
        var cases = List[MatchCase]()
        while {self.current.is(LPipe)} {
            cases ::= parseCase()
        }
        cases.reverse
    } elseIf {self.current.is(LLower) && self.ahead.is(LComma, LArrowThick)} {
        var parameters = List[MatchPattern]()
        while {!self.current.is(LArrowThick)} {
            val parameterToken = skip(LLower)
            parameters ::= PVariable(parameterToken.at, Some(parameterToken.raw))
            if(!self.current.is(LArrowThick)) skip(LComma)
        }
        skip(LArrowThick)
        val term = parseStatements()
        List(MatchCase(token.at, parameters.reverse, term))
    } else {
        val term = parseStatements()
        val wildcards = new Wildcards()
        val e = wildcards.fixWildcards(term)
        val arguments = if(wildcards.seenWildcards != 0) {
            1.to(wildcards.seenWildcards).toList.map(i => PVariable(token.at, Some("_w" + i)))
        } else {
            1.to(defaultParameterCount).toList.map(_ => PVariable(token.at, None))
        }
        List(MatchCase(token.at, arguments, e))
    }
    if(!colon) skip(LBracketRight, "}")
    ELambda(token.at, result)
}

Parser_parseCase(self: Parser): MatchCase {
    val token = skip(LPipe)
    var patterns = List[MatchPattern]()
    while {!self.current.is(LArrowThick)} {
        patterns ::= parsePattern()
        if(!self.current.is(LArrowThick)) skip(LComma)
    }
    skip(LArrowThick)
    val body = parseStatements()
    MatchCase(token.at, patterns.reverse, body)
}

Parser_parsePattern(self: Parser): MatchPattern {
    if(self.current.is(LWildcard)) {
        val token = skip(LWildcard)
        PVariable(token.at, None)
    } elseIf {self.current.is(LLower)} {
        val token = skip(LLower)
        PVariable(token.at, Some(token.raw))
    } elseIf {self.current.rawIs("(")} {
        val at = self.current.at
        val (fields, fieldPatterns) = parseRecordPattern().unzip
        PVariant(at, "Record_" + fields.mkString("_"), fieldPatterns)
    } else {
        val token = skip(LUpper)
        if(self.current.rawIs("(")) {
            var patterns = List[MatchPattern]()
            skip(LBracketLeft, "(")
            while {!self.current.is(LBracketRight)} {
                patterns ::= parsePattern()
                if(!self.current.is(LBracketRight)) skip(LComma)
            }
            skip(LBracketRight, ")")
            PVariant(token.at, token.raw, patterns.reverse)
        } else {
            if(self.current.is(LLower)) {
                val asToken = skip(LLower)
                PVariantAs(token.at, token.raw, asToken.raw)
            } else {
                PVariant(token.at, token.raw, List())
            }
        }
    }
}

Parser_parseType(self: Parser): Type {
    val leftTypes = if(self.current.rawIs("(") && self.ahead.is(LLower) && self.aheadAhead.is(LColon)) {
        val at = self.current.at
        val (fields, fieldTypes) = parseRecordType().unzip
        List(Type(at, "Record_" + fields.mkString("_"), fieldTypes))
    } elseIf {self.current.rawIs("(")} {
        parseTypeArguments(parenthesis = true)
    } else {
        val namespace = if(self.current.is(LNamespace)) skip(LNamespace).raw else ""
        val token = skip(LUpper)
        val arguments = if(!self.current.rawIs("[")) List() else parseTypeArguments()
        List(Type(token.at, namespace + token.raw, arguments))
    }
    if(!self.current.is(LArrowThick) && leftTypes.size == 1) leftTypes.head else {
        val arrowToken = skip(LArrowThick)
        val rightType = parseType()
        Type(arrowToken.at, "Function_" + leftTypes.size, leftTypes ++ List(rightType))
    }
}

Parser_parseStatements(self: Parser): Term =
    if(self.current.is(LBracketRight, LPipe)) EVariant(self.current.at, "Unit", List(), List()) else {
        var result = parseStatement()
        while {currentIsSeparator(LSemicolon)} {
            val token = skipSeparator(LSemicolon)
            result = ESequential(token.at, result, parseStatement())
        }
        result
    }

Parser_parseStatement(self: Parser): Term {
    if(self.current.is(LKeyword) && (self.current.rawIs("let") || self.current.rawIs("mutable"))) parseLet()
    else if(self.current.is(LKeyword) && self.current.rawIs("function")) parseFunctions()
    else {
        val term = parseTerm()
        if(!self.current.is(LAssign, LAssignPlus, LAssignMinus)) term else {
            val token =
                if(self.current.is(LAssignPlus)) skip(LAssignPlus)
                else if(self.current.is(LAssignMinus)) skip(LAssignMinus)
                else skip(LAssign)
            val value = parseTerm()
            term match {
                case EVariable(_, name) => EAssign(token.at, token.raw, name, value)
                case e : EField => EAssignField(token.at, token.raw, e, value)
                case _ => self.fail(token.at, "Only variables and fields are assignable")
            }
        }
    }
}

Parser_parseLet(self: Parser): Term {
    val mutable = self.current.rawIs("mutable")
    if(mutable) skip(LKeyword, "mutable") else skip(LKeyword, "let")
    val nameToken = skip(LLower)
    val valueType = if(!self.current.is(LColon)) Type(nameToken.at, "?", List()) else {
        skip(LColon)
        parseType()
    }
    skipSeparator(LAssign)
    val value = parseTerm()
    skipSeparator(LSemicolon)
    val body = parseStatements()
    ELet(nameToken.at, mutable, nameToken.raw, valueType, value, body)
}

Parser_parseFunctions(self: Parser): Term {
    val at = self.current.at
    var functions = List[LocalFunction]()
    while {self.current.rawIs("function")} {
        skip(LKeyword, "function")
        val signature = parseSignature()
        val body = parseLambda()
        functions ::= LocalFunction(signature, body)
        skipSeparator(LSemicolon)
    }
    val body = parseStatements()
    EFunctions(at, functions.reverse, body)
}

Parser_parseTerm(self: Parser): Term {
    parseBinary(0)
}

val binaryOperators = Array(
    List("||"),
    List("&&"),
    List("!=", "=="),
    List("<=", ">=", "<", ">"),
    List("++"),
    List("+", "-"),
    List("*", "/", "%"),
    List("^")
)

Parser_parseBinary(level : Int) : Term = if(level >= binaryOperators.length) parseUnary() else {
    val operators = binaryOperators(level)
    var result = parseBinary(level + 1)
    if(self.current.is(LOperator)) {
        while {operators.exists(self.current.rawIs)} {
            val token = skip(LOperator)
            val right = parseBinary(level + 1)
            result = ECall(token.at, EVariable(token.at, token.raw), List(), List(result, right))
        }
    }
    result
}

Parser_parseUnary(self: Parser): Term {
    if(self.current.is(LOperator)) {
        val token = skip(LOperator)
        val term = parseUnary()
        ECall(token.at, EVariable(token.at, token.raw), List(), List(term))
    } else {
        parseFieldsAndCalls()
    }
}

Parser_parseFieldsAndCalls(self: Parser): Term {
    var result = parseAtom()
    while {self.current.is(LBracketLeft) || self.current.is(LColon) || self.current.is(LDot)} {
        if(self.current.is(LDot)) {
            skip(LDot)
            if(self.current.rawIs("{")) {
                val term = parseAtom()
                result = EPipe(term.at, result, term)
            } elseIf {self.current.is(LUpper, LNamespace)} {
                result = parseCopy(result)
            } else {
                val token = skip(LLower)
                result = EField(token.at, result, token.raw)
            }
        } else {
            val at = self.current.at
            val typeArguments = if(!self.current.rawIs("[")) List() else parseTypeArguments()
            val arguments = if(!self.current.rawIs("(")) List() else parseFunctionArguments()
            var moreArguments = List[Term]()
            var lastWasCurly = false
            while {self.current.rawIs("{") || self.current.is(LColon)} {
                lastWasCurly = self.current.rawIs("{")
                moreArguments ::= parseLambda(allowColon = true)
            }
            result = ECall(at, result, typeArguments, arguments ++ moreArguments.reverse)
            if(lastWasCurly && self.current.is(LLower)) {
                val token = skip(LLower)
                result = EField(token.at, result, token.raw)
            }
        }
    }
    result
}

Parser_parseAtom(self: Parser): Term {
    if(self.current.is(LString)) {
        val token = skip(LString)
        EString(token.at, token.raw)
    } elseIf {self.current.is(LChar)} {
        val token = skip(LChar)
        EChar(token.at, token.raw)
    } elseIf {self.current.is(LInt)} {
        val token = skip(LInt)
        EInt(token.at, token.raw)
    } elseIf {self.current.is(LFloat)} {
        val token = skip(LFloat)
        EFloat(token.at, token.raw)
    } elseIf {self.current.is(LLower)} {
        val token = skip(LLower)
        EVariable(token.at, token.raw)
    } elseIf {self.current.is(LNamespace)} {
        val namespaceToken = skip(LNamespace)
        val extraNamespace = if(!self.current.is(LNamespace)) None else Some(skip(LNamespace).raw)
        val prefix = namespaceToken.raw + extraNamespace.getOrElse("")
        if(self.current.is(LLower)) { val token = skip(LLower); EVariable(token.at, prefix + token.raw) } else {
            parseVariant(prefix)
        }
    } elseIf {self.current.is(LUpper)} {
        parseVariant("")
    } elseIf {self.current.rawIs("{")} {
        parseLambda()
    } elseIf {self.current.rawIs("[")} {
        parseList()
    } elseIf {self.current.rawIs("(") && self.ahead.is(LLower) && self.aheadAhead.is(LAssign)} {
        ERecord(self.current.at, parseRecord())
    } elseIf {self.current.rawIs("(")} {
        skip(LBracketLeft, "(")
        val result = parseTerm()
        skip(LBracketRight, ")")
        result
    } elseIf {self.current.is(LWildcard)} {
        val token = skip(LWildcard)
        EWildcard(token.at, 0)
    } else {
        self.fail(self.current.at, "Expected atom, got " + self.current.raw)
    }
}

Parser_parseVariant(prefix : String) : Term {
    val token = skip(LUpper)
    val name = prefix + token.raw
    val typeArguments = if(!self.current.rawIs("[")) List() else parseTypeArguments()
    val arguments = if(!self.current.rawIs("(")) List() else parseFunctionArguments()
    EVariant(token.at, name, typeArguments, arguments)
}

Parser_parseCopy(record : Term) : Term {
    val namespace = if(!self.current.is(LNamespace)) "" else skip(LNamespace).raw
    val extraNamespace = if(!self.current.is(LNamespace)) "" else skip(LNamespace).raw
    val prefix = namespace + extraNamespace
    val token = skip(LUpper)
    val name = prefix + token.raw
    val fields = parseRecord()
    ECopy(token.at, name, record, fields)
}

Parser_parseRecord(self: Parser): List[(String, Term)] {
    var fields = List[(String, Term)]()
    skip(LBracketLeft, "(")
    while {!self.current.is(LBracketRight)} {
        val fieldToken = skip(LLower)
        skipSeparator(LAssign)
        fields ::= fieldToken.raw -> parseTerm()
        if(!self.current.is(LBracketRight)) skipSeparator(LComma)
    }
    skip(LBracketRight, ")")
    fields.reverse
}

Parser_parseRecordType(self: Parser): List[(String, Type)] {
    var fields = List[(String, Type)]()
    skip(LBracketLeft, "(")
    while {!self.current.is(LBracketRight)} {
        val fieldToken = skip(LLower)
        skipSeparator(LColon)
        fields ::= fieldToken.raw -> parseType()
        if(!self.current.is(LBracketRight)) skipSeparator(LComma)
    }
    skip(LBracketRight, ")")
    fields.reverse.sortBy(_._1)
}

Parser_parseRecordPattern(self: Parser): List[(String, MatchPattern)] {
    var fields = List[(String, MatchPattern)]()
    skip(LBracketLeft, "(")
    while {!self.current.is(LBracketRight)} {
        val fieldToken = skip(LLower)
        skipSeparator(LAssign)
        fields ::= fieldToken.raw -> parsePattern()
        if(!self.current.is(LBracketRight)) skipSeparator(LComma)
    }
    skip(LBracketRight, ")")
    fields.reverse
}

Parser_parseList(self: Parser): Term {
    var items = List[Term]()
    val at = skip(LBracketLeft, "[").at
    while {!self.current.rawIs("]")} {
        items ::= parseTerm()
        if(!self.current.rawIs("]")) skipSeparator(LComma)
    }
    skip(LBracketRight, "]")
    EList(at, items.reverse)
}
*/
