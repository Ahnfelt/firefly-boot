import Token
import Wildcards
import Syntax

class Parser(
    packagePair: PackagePair
    file: String
    tokens: Array[Token]
    end: Token
    targetIsNode: Bool
    attemptFixes: Bool
    mutable offset: Int
    mutable nextUnificationVariableIndex: Int
)

data Poly(generics: List[String], constraints: List[Constraint])

data ParsedTargets(
    js: Option[Lambda]
    jsSync: Option[String]
    jsAsync: Option[String]
    browser: Option[Lambda]
    browserSync: Option[String]
    browserAsync: Option[String]
    node: Option[Lambda]
    nodeSync: Option[String]
    nodeAsync: Option[String]
)

make(packagePair: PackagePair, file: String, tokens: Array[Token], targetIsNode: Bool, attemptFixes: Bool): Parser {
    Parser(
        packagePair = packagePair
        file = file
        tokens = tokens
        end = tokens.grabLast()
        targetIsNode = targetIsNode
        attemptFixes = attemptFixes
        offset = 0
        nextUnificationVariableIndex = 1 // To avoid collision with the unification and resolver
    )
}

extend self: Parser {

    fail[T](at: Location, message: String): T {
        panic(message + " " + at.show())
    }
    
    current(): Token {
        if(self.offset < self.tokens.size()) {self.tokens.grab(self.offset)} else {self.end}
    }
    
    ahead(): Token {
        if(self.offset + 1 < self.tokens.size()) {self.tokens.grab(self.offset + 1)} else {self.end}
    }
    
    aheadAhead(): Token {
        if(self.offset + 2 < self.tokens.size()) {self.tokens.grab(self.offset + 2)} else {self.end}
    }
    
    skip(kind: TokenKind): Token {
        let c = self.current()
        if(c.kind != kind) {
            if(self.attemptFixes && kind == LUpper && c.kind == LLower) {} else:
            throw(CompileError(c.at(), "Expected " + Show.show(kind) + ", got " + c.raw()))
        }
        self.offset += 1
        c
    }
    
    rawSkip(kind: TokenKind, value: String): Token {
        let c = self.current()
        if(c.kind != kind) {
            if(self.attemptFixes && (value == ")" || value == "]" || value == "}")) {} else:
            throw(CompileError(c.at(), "Expected " + Show.show(kind) + " " + value + ", got " + c.raw()))
        }
        if(!c.rawIs(value)) {
            if(self.attemptFixes && (value == ")" || value == "]" || value == "}")) {self.offset -= 1} else:
            throw(CompileError(c.at(), "Expected " + value + " got " + c.raw()))
        }
        self.offset += 1
        c
    }

    freshUnificationVariable(at: Location): Type {
        let result = TVariable(at, self.nextUnificationVariableIndex)
        self.nextUnificationVariableIndex += 3
        result
    }
    
    currentIsSeparator(kind: TokenKind): Bool {
        self.current().is(kind) || self.current().is(LSeparator)
    }
    
    skipSeparator(kind: TokenKind): Token {
        if(self.current().is(LSeparator)) {
            self.skip(LSeparator)
        } else {
            self.skip(kind)
        }
    }

    parseModuleWithoutPackageInfo(): Module {
        let moduleWithPackageInfo = self.parseModuleWithPackageInfo()
        moduleWithPackageInfo.packageInfo.each {info =>
            throw(CompileError(info.package.at, "Package and dependencies already declared in package.ff"))
        }
        moduleWithPackageInfo.module
    }

    parseModuleWithPackageInfo(): ModuleWithPackageInfo {
        let packageInfo = if(self.current().is(LKeyword) && self.current().rawIs3("package", "dependency", "include")) {
            self.parsePackageInfo()
        }
        let module = self.parseModule()
        ModuleWithPackageInfo(packageInfo, module)
    }

    parsePackageInfo(): PackageInfo {
        let location = self.current().at()
        let package = if(self.current().is(LKeyword) && self.current().rawIs("package")) {
            let p = self.parsePackageDefinition()
            if(!self.current().is(LEnd)) {self.skipSeparator(LSemicolon)}
            p
        } else {
            DPackage(
                location
                self.packagePair
                Version(location, 0, 0, 0)
                TargetNames(node = self.targetIsNode, browser = !self.targetIsNode)
            )
        }
        if(self.current().is(LKeyword) && self.current().rawIs("package")) {
            throw(CompileError(self.current().at(), "Duplicate package definition"))
        }
        /* TODO: if(self.package != None && self.current().is(LKeyword) && self.current().rawIs("dependency")) {
            self.fail(self.current().at(), "Dependencies must be defined in the same file as the package declaration")
        }*/
        let dependencies = Stack.make[DDependency]()
        while {self.current().is(LKeyword) && self.current().rawIs("dependency")} {
            dependencies.push(self.parseDependencyDefinition(package.targets))
            if(!self.current().is(LEnd)) {self.skipSeparator(LSemicolon)}
        }
        let includes = Stack.make[DInclude]()
        while {self.current().is(LKeyword) && self.current().rawIs("include")} {
            includes.push(self.parseIncludeDefinition())
            if(!self.current().is(LEnd)) {self.skipSeparator(LSemicolon)}
        }
        // TODO: When this method is called directly for package.ff, check that the whole file has been consumed
        PackageInfo(package, dependencies.toList(), includes.toList())
    }

    parseModule(): Module {
        let imports = Stack.make[DImport]()
        let types = Stack.make[DType]()
        let traits = Stack.make[DTrait]()
        let instances = Stack.make[DInstance]()
        let extends = Stack.make[DExtend]()
        let lets = Stack.make[DLet]()
        let functions = Stack.make[DFunction]()
        while {!self.current().is(LEnd)} {
            if(self.current().is(LLower) && (self.ahead().is(LAssign) || self.ahead().is(LColon))) {
                lets.push(self.parseLetDefinition())
            } elseIf {self.current().is(LLower) && self.ahead().is(LBracketLeft)} {
                functions.push(self.parseFunctionDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("extend")} {
                extends.push(self.parseExtendDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("trait")} {
                traits.push(self.parseTraitDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("instance")} {
                instances.push(self.parseInstanceDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs4("data", "class", "capability", "newtype")} {
                types.push(self.parseTypeDefinition())
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("import")} {
                imports.push(self.parseImportDefinition(self.packagePair))
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("include")} {
                throw(CompileError(self.current().at()
                    "Includes must be at the top of the file or below 'package'"
                ))
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("dependency")} {
                throw(CompileError(self.current().at()
                "Dependencies must be at the top of the file or below 'package'"
            ))
            } elseIf {self.current().is(LKeyword) && self.current().rawIs("package")} {
                throw(CompileError(self.current().at()
                    "Package definition must be at the top of the file"
                ))
            } else {
                self.skip(LEnd)
            }
            if(!self.current().is(LEnd)) {self.skipSeparator(LSemicolon)}
        }

        Module(
            file = self.file
            packagePair = self.packagePair
            imports = imports.toList()
            lets = lets.toList()
            functions = functions.toList()
            extends = extends.toList()
            types = types.toList()
            traits = traits.toList()
            instances = instances.toList()
        )
    }
    
    parseLetDefinition(): DLet {
        let nameToken = self.skip(LLower)
        let variableType = if(self.current().is(LColon)) {
            self.skip(LColon)
            self.parseType()
        } else {self.freshUnificationVariable(nameToken.at())}
        self.skip(LAssign)
        let value = self.parseTerm()
        DLet(nameToken.at(), nameToken.raw(), variableType, value)
    }
    
    parseFunctionDefinition(): DFunction {
        let signature = self.parseSignature()
        let body = if(self.current().rawIs("{")) {self.parseLambda(signature.parameters.size())}
        let targets = self.parseTargets(signature.parameters.size())
        let bestTarget = findBestTarget(self.targetIsNode, body, targets)
        DFunction(
            signature.at
            signature
            bestTarget
        )
    }

    parseTargets(parameterCount: Int): ParsedTargets {
        function processCode(code: String): String {
            let dropCount = if(code.startsWith("\"\"\"")) {3} else {1}
            code.dropFirst(dropCount).dropLast(dropCount)
                .replace("\\\"", "\"")
                .replace("\\r", "\r")
                .replace("\\n", "\n")
                .replace("\\t", "\t")
                .replace("\\\\", "\\")
        }
        mutable targets = ParsedTargets(None, None, None, None, None, None, None, None, None)
        while {self.currentIsSeparator(LSemicolon) && self.ahead().is(LKeyword) && self.ahead().rawIs("target")} {
            self.skip(LSeparator)
            let at = self.skip(LKeyword).at()
            let target = if(self.current().is(LLower)) {self.skip(LLower).raw()} else {self.skip(LKeyword).raw()}
            if(self.current().rawIs("{")) {
                let lambda = self.parseLambda(parameterCount)
                target.{
                    | "js" =>
                        if(targets.jsSync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(js = Some(lambda))
                    | "browser" =>
                        if(targets.browserSync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(browser = Some(lambda))
                    | "node" =>
                        if(targets.nodeAsync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(node = Some(lambda))
                    | _ =>
                        throw(CompileError(at, "Unknown target"))
                }
            } else {
                let mode = self.skip(LKeyword).raw()
                let code = processCode(self.skip(LString).raw())
                Pair(target, mode).{
                    | Pair("js", "sync") =>
                        if(targets.jsSync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(jsSync = Some(code))
                    | Pair("js", "async") =>
                        if(targets.jsAsync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(jsAsync = Some(code))
                    | Pair("browser", "sync") =>
                        if(targets.browserSync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(browserSync = Some(code))
                    | Pair("browser", "async") =>
                        if(targets.browserAsync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(browserAsync = Some(code))
                    | Pair("node", "sync") =>
                        if(targets.nodeSync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(nodeSync = Some(code))
                    | Pair("node", "async") =>
                        if(targets.nodeAsync != None) {throw(CompileError(at, "Duplicate target definition"))}
                        targets = targets.ParsedTargets(nodeAsync = Some(code))
                    | Pair(_, _) =>
                        throw(CompileError(at, "Unknown target or mode"))
                }
            }
        }
        targets
    }

    parseSignature(): Signature {
        let nameToken = self.skip(LLower)
        let poly = if(self.current().rawIs("[")) {self.parseTypeParameters()} else {Poly([], [])}
        let parameters = self.parseFunctionParameters()
        let returnType = if(self.current().is(LColon)) {
            self.skip(LColon)
            self.parseType()
        } else {
            TConstructor(self.current().at(), "ff:core/Unit.Unit", [])
        }
        let temporaryEffect = TConstructor(nameToken.at(), "TemporaryEffect$", [])
        Signature(nameToken.at(), nameToken.raw(), poly.generics, poly.constraints, parameters, returnType, temporaryEffect)
    }
    
    parseExtendDefinition(): DExtend {
        self.rawSkip(LKeyword, "extend")
        let nameToken = self.skip(LLower)
        let poly = if(self.current().rawIs("[")) {self.parseTypeParameters()} else {Poly([], [])}
        self.skip(LColon)
        let type = self.parseType()
        self.rawSkip(LBracketLeft, "{")
        let methods = Stack.make[DFunction]()
        while {!self.current().is(LBracketRight)} {
            methods.push(self.parseFunctionDefinition())
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LSemicolon)}
        }
        self.rawSkip(LBracketRight, "}")
        DExtend(
            nameToken.at()
            nameToken.raw()
            poly.generics
            poly.constraints
            type
            methods.toList()
        )
    }
    
    parseTraitDefinition(): DTrait {
        self.rawSkip(LKeyword, "trait")
        let typeParameterToken = self.skip(LUpper)
        self.skip(LColon)
        let nameToken = self.skip(LUpper)
        let poly = if(!self.current().rawIs("[")) {Poly([], [])} else {self.parseTypeParameters()}
        let constraints = Stack.make[Constraint]()
        while {self.current().is(LColon)} {
            self.fail(self.current().at(), "Trait constraints is not yet implemented")
            self.skip(LColon)
            let constraint = self.parseConstraint()
            constraints.push(constraint.Constraint(generics =
                [TConstructor(typeParameterToken.at(), typeParameterToken.raw(), []), ...constraint.generics]
            ))
        }
        let generatorParameters = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionParameters()}
        let methodGenerators = Stack.make[Pair[String, Lambda]]()
        let methodDefaults = Stack.make[Pair[String, Lambda]]()
        let methodSignatures = if(!self.current().rawIs("{")) {[]} else {
            let signatures = Stack.make[Signature]()
            self.rawSkip(LBracketLeft, "{")
            while {!self.current().is(LBracketRight)} {
                let signature = self.parseSignature()
                signatures.push(signature)
                if(self.current().rawIs("{")) {
                    let generator = self.ahead().is(LKeyword) && self.ahead().rawIs("generate")
                    let body = self.parseLambda(signature.parameters.size(), ignoreGenerateKeyword = True)
                    if(generator) {
                        methodGenerators.push(Pair(signature.name, body))
                    } else {
                        methodDefaults.push(Pair(signature.name, body))
                    }
                }
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LSemicolon)}
            }
            self.rawSkip(LBracketRight, "}")
            signatures.toList()
        }
        DTrait(
            nameToken.at()
            nameToken.raw()
            [typeParameterToken.raw(), ...poly.generics]
            [...constraints.toList(), ...poly.constraints]
            generatorParameters
            methodSignatures
            methodDefaults.toList()
            methodGenerators.toList()
        )
    }

    parseInstanceDefinition(): DInstance {
        self.rawSkip(LKeyword, "instance")
        let token = self.skip(LUpper)
        let poly = if(!self.current().rawIs("[")) {Poly([], [])} else {self.parseTypeParameters()}
        let typeArguments = Stack.make[Type]()
        typeArguments.push(TConstructor(token.at(), token.raw(), poly.generics.map {TConstructor(token.at(), _, [])}))
        self.skip(LColon)
        let nameToken = self.skip(LUpper)
        if(self.current().rawIs("[")) {
            self.rawSkip(LBracketLeft, "[")
            while {!self.current().is(LBracketRight)} {
                typeArguments.push(self.parseType())
                if(!self.current().is(LBracketRight)) {self.skip(LComma)}
            }
            self.rawSkip(LBracketRight, "]")
        }
        let generatorArguments = self.parseFunctionArguments(False).first
        let methods = if(!self.current().rawIs("{")) {[]} else {
            let definitions = Stack.make[DFunction]()
            self.rawSkip(LBracketLeft, "{")
            while {!self.current().is(LBracketRight)} {
                definitions.push(self.parseFunctionDefinition())
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LSemicolon)}
            }
            self.rawSkip(LBracketRight, "}")
            definitions.toList()
        }
        DInstance(
            at = nameToken.at()
            generics = poly.generics
            constraints = poly.constraints
            traitName = nameToken.raw()
            typeArguments = typeArguments.toList()
            generatorArguments = generatorArguments
            methods = methods
        )
    }

    parseTypeDefinition(): DType {
        let newtype = self.current().rawIs("newtype")
        let effectParameter = if(self.current().rawIs("capability")) {["Q$"]} else {[]}
        let allowMutable = self.current().rawIs2("class", "capability")
        if(self.current().rawIs("newtype")) {
            self.rawSkip(LKeyword, "newtype")
        } elseIf {self.current().rawIs("data")} {
            self.rawSkip(LKeyword, "data")
        } elseIf {self.current().rawIs("class")} {
            self.rawSkip(LKeyword, "class")
        } else {
            self.rawSkip(LKeyword, "capability")
        }
        let nameToken = self.skip(LUpper)
        let poly = if(!self.current().rawIs("[")) {Poly([], [])} else {self.parseTypeParameters()}
        if(!self.current().rawIs("(") && !self.current().rawIs("{")) {self.rawSkip(LBracketLeft, "{")}
        let commonFields = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionParameters(allowMutable = True)}
        let variants = if(newtype || !self.current().rawIs("{")) {
            [Variant(nameToken.at(), nameToken.raw(), [])]
        } else {
            self.rawSkip(LBracketLeft, "{")
            let variantsBuilder = Stack.make[Variant]()
            while {!self.current().is(LBracketRight)} {
                let variantNameToken = self.skip(LUpper)
                let variantFields = if(!self.current().rawIs("(")) {[]} else {self.parseFunctionParameters(allowMutable = True)}
                if(!allowMutable && variantFields.any {_.mutable}) {
                    throw(CompileError(variantFields.find {_.mutable}.grab().at
                        "Only classes can have mutable fields"
                    ))
                }
                variantsBuilder.push(
                    Variant(variantNameToken.at(), variantNameToken.raw(), variantFields)
                )
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LSemicolon)}
            }
            self.rawSkip(LBracketRight, "}")
            variantsBuilder.toList()
        }
        if(newtype && commonFields.size() != 1) {
            Log.show(commonFields)
            throw(CompileError(nameToken.at(), "Newtypes must have exactly one field"))
        }
        if(!allowMutable && commonFields.any {_.mutable}) {
            throw(CompileError(
                commonFields.find {_.mutable}.grab().at
                "Only classes and capabilities can have mutable fields"
            ))
        }
        let generics = [...effectParameter, ...poly.generics]
        DType(nameToken.at(), newtype, nameToken.raw(), generics, poly.constraints, commonFields, variants)
    }
    
    parseImportDefinition(currentPackagePair: PackagePair): DImport {
        let importToken = self.rawSkip(LKeyword, "import")
        let path = Stack.make[String]()
        while {self.current().is(LLower)} {
            path.push(self.parseDashedName())
            self.skip(LDot)
        }
        let file = self.skip(LUpper).raw()
        let alias = if(self.current().rawIs("as")) {
            self.rawSkip(LKeyword, "as")
            self.skip(LUpper).raw()
        } else {file}
        let packagePair = if(self.current().rawIs("from")) {
            self.rawSkip(LKeyword, "from")
            let userName = self.parseDashedName()
            self.skip(LColon)
            let packageName = self.parseDashedName()
            PackagePair(userName, packageName)
        } else {
            currentPackagePair
        }
        DImport(importToken.at(), alias, packagePair, path.toList(), file)
    }

    parsePackageDefinition(): DPackage {
        let at = self.skip(LKeyword).at()
        let user = self.skip(LLower).raw()
        self.skip(LColon)
        let name = self.skip(LLower).raw()
        self.skip(LColon)
        let version = self.parseVersion()
        let targets = self.parseTargetNames(TargetNames(True, True))
        DPackage(
            at = at
            packagePair = PackagePair(user, name)
            version = version
            targets = targets
        )
    }

    parseDependencyDefinition(defaultTargetNames: TargetNames): DDependency {
        let at = self.skip(LKeyword).at()
        let user = self.skip(LLower).raw()
        self.skip(LColon)
        let name = self.skip(LLower).raw()
        self.skip(LColon)
        let version = self.parseVersion()
        let safety = (
            if(self.current().rawIs("trusted")) {Trusted} else:
            if(self.current().rawIs("unsafe")) {Unsafe} else:
            Safe
        )
        let targets = self.parseTargetNames(defaultTargetNames)
        DDependency(
            at = at
            packagePair = PackagePair(user, name)
            version = version
            safety = safety
            targets = targets
        )
    }

    parseIncludeDefinition(): DInclude {
        let at = self.skip(LKeyword).at()
        let path = self.skip(LString).raw()
        DInclude(
            at = at
            path = path.dropFirst().dropLast() // TODO: Fix string escaping
        )
    }

    parseTargetNames(defaultTargets: TargetNames): TargetNames {
        mutable targets = TargetNames(False, False)
        while {self.current().is2(LKeyword, LLower)} {
            let token = if(self.current().is(LLower)) {self.skip(LLower)} else {self.skip(LKeyword)}
            token.raw().{
                | "node" {targets.node} => throw(CompileError(token.at(), "Duplicate target name"))
                | "node" => targets = targets.TargetNames(node = True)
                | "browser" {targets.browser} => throw(CompileError(token.at(), "Duplicate target name"))
                | "browser" => targets = targets.TargetNames(browser = True)
                | t => throw(CompileError(token.at(), "Unexpected target: " + t))
            }
        }
        if(!targets.node && !targets.browser) {
            defaultTargets
        } else {
            targets
        }
    }
    
    parseVersion(): Version {
        if(self.current().is(LFloat)) {
            let majorMinor = self.skip(LFloat)
            let parts = majorMinor.raw().split('.')
            let patch = if(self.current().is(LDot)) {
                 self.skip(LDot)
                 self.skip(LInt).raw().grabInt()
            } else {0}
            Version(majorMinor.at(), parts.grab(0).grabInt(), parts.grab(1).grabInt(), patch)
        } else {
            let major = self.skip(LInt)
            Version(major.at(), major.raw().grabInt(), 0, 0)
        }
    }
    
    parseDashedName(): String {
        let at = self.current().at()
        function readPart(): String {
            if(self.current().is(LInt)) {
                let prefix = self.skip(LInt).raw()
                if(self.current().is(LLower)) {prefix + self.skip(LLower).raw()} else {prefix}
            } else {
                self.skip(LLower).raw()
            }
        }
        mutable part = readPart()
        while {self.current().rawIs("-")} {
            self.skip(LOperator)
            part = part + "-" + readPart()
        }
        if(part.any {_.isAsciiUpper()}) {
            throw(CompileError(at, "Package names and paths must not contain upper case letters: " + part))
        }
        if(part.any {_ == '_'} || part.any {_ == '.'}) {
            throw(CompileError(at, "Package names and paths must not contain underscores or dots: " + part))
        }
        part
    }
    
    parseTypeParameters(): Poly {
        self.rawSkip(LBracketLeft, "[")
        let parameters = Stack.make[String]()
        let constraints = Stack.make[Constraint]()
        while {!self.current().is(LBracketRight) && !self.current().is(LSemicolon)} {
            if(self.ahead().is(LBracketLeft)) {
                constraints.push(self.parseConstraint())
            } else {
                let parameterNameToken = self.skip(LUpper)
                parameters.push(parameterNameToken.raw())
                while {self.current().is(LColon)} {
                    self.skip(LColon)
                    let constraint = self.parseConstraint()
                    constraints.push(constraint.Constraint(generics =
                        [TConstructor(parameterNameToken.at(), parameterNameToken.raw(), []), ...constraint.generics]
                    ))
                }
            }
            if(!self.current().is(LBracketRight)) {self.skip(LComma)}
        }
        self.rawSkip(LBracketRight, "]")
        Poly(parameters.toList(), constraints.toList())
    }
    
    parseTypeArguments(parenthesis: Bool = False): List[Type] {
        self.rawSkip(LBracketLeft, if(parenthesis) {"("} else {"["})
        let types = Stack.make[Type]()
        while {!self.current().is(LBracketRight)} {
            types.push(self.parseType())
            if(!self.current().is(LBracketRight)) {self.skip(LComma)}
        }
        self.rawSkip(LBracketRight, if(parenthesis) {")"} else {"]"})
        types.toList()
    }
    
    parseFunctionParameters(allowMutable: Bool = False): List[Parameter] {
        let parameters = Stack.make[Parameter]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let mutable = allowMutable && self.current().is(LKeyword) && self.current().rawIs("mutable")
            if(mutable) {self.skip(LKeyword)}
            let parameterNameToken = self.skip(LLower)
            self.skip(LColon)
            let parameterType = self.parseType()
            let default = if(!self.current().is(LAssign)) {None} else {
                self.skip(LAssign)
                Some(self.parseTerm())
            }
            parameters.push(Parameter(parameterNameToken.at(), mutable, parameterNameToken.raw(), parameterType, default))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        parameters.toList()
    }
    
    parseFunctionArguments(trailing: Bool): Pair[List[Argument], Bool] {
        let arguments = Stack.make[Argument]()
        if(self.current().rawIs("(")){
            self.rawSkip(LBracketLeft, "(")
            while {!self.current().is(LBracketRight)} {
                let nameToken = if(self.current().is(LLower) && self.ahead().is(LAssign)) {
                    let token = self.skip(LLower)
                    self.skip(LAssign)
                    Some(token)
                } else {None}
                let value = self.parseTerm()
                arguments.push(Argument(nameToken.map {_.at()}.else {value.at}, nameToken.map {_.raw()}, value))
                if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
            }
            self.rawSkip(LBracketRight, ")")
        }
        mutable lastWasCurly = False
        if(trailing) {
            while {self.current().rawIs("{") || self.current().is(LColon)} {
                lastWasCurly = self.current().rawIs("{")
                let lambda = self.parseLambda(allowColon = True)
                arguments.push(Argument(lambda.at, None, ELambda(lambda.at, lambda)))
            }
        }
        Pair(arguments.toList(), lastWasCurly)
    }
    
    parseLambda(
        defaultParameterCount: Int = 0
        ignoreGenerateKeyword: Bool = False
        allowColon: Bool = False
    ): Lambda {
        let colon = allowColon && self.current().is(LColon)
        let token = if(colon) {self.skip(LColon)} else {self.rawSkip(LBracketLeft, "{")}
        if(ignoreGenerateKeyword && self.current().is(LKeyword) && self.current().rawIs("generate")) {self.skip(LKeyword)}
        let result = if(self.current().is(LPipe)) {
            let cases = Stack.make[MatchCase]()
            while {self.current().is(LPipe)} {
                cases.push(self.parseCase())
            }
            cases.toList()
        } elseIf {self.current().is2(LLower, LWildcard) && self.ahead().is2(LComma, LArrowThick)} {
            let parameters = Stack.make[MatchPattern]()
            while {!self.current().is(LArrowThick)} {
                let isVariable = self.current().is(LLower)
                let parameterToken = if(isVariable) {self.skip(LLower)} else {self.skip(LWildcard)}
                parameters.push(PVariable(parameterToken.at(), if(isVariable) {Some(parameterToken.raw())} else {None}))
                if(!self.current().is(LArrowThick)) {self.skip(LComma)}
            }
            self.skip(LArrowThick)
            let term = self.parseStatements()
            [MatchCase(token.at(), parameters.toList(), [], term)]
        } else {
            let term = self.parseStatements()
            let wildcards = Wildcards.make()
            let e = wildcards.fixWildcards(term)
            let arguments = if(wildcards.seenWildcards != 0) {
                List.range(wildcards.seenWildcards).map {i => PVariable(token.at(), Some("_w" + (i + 1)))}
            } else {
                List.range(defaultParameterCount).map {i => PVariable(token.at(), None)}
            }
            [MatchCase(token.at(), arguments, [], e)]
        }
        if(!colon) {self.rawSkip(LBracketRight, "}")}
        let temporaryEffect = TConstructor(token.at(), "TemporaryEffect$", [])
        Lambda(token.at(), temporaryEffect, result)
    }
    
    parseCase(): MatchCase {
        let token = self.skip(LPipe)
        let patterns = Stack.make[MatchPattern]()
        while {!self.current().is3(LArrowThick, LPipe, LBracketRight) && !self.current().rawIs("{")} {
            patterns.push(self.parsePattern())
            if(!self.current().is3(LArrowThick, LPipe, LBracketRight) && !self.current().rawIs("{")) {
                self.skip(LComma)
            }
        }
        let guards = Stack.make[MatchGuard]()
        while {self.current().rawIs("{")} {
            guards.push(self.parseCaseGuard())
        }
        if(!self.attemptFixes || !self.current().is2(LPipe, LBracketRight)) {
            self.skip(LArrowThick)
        }
        let body = self.parseStatements()
        MatchCase(token.at(), patterns.toList(), guards.toList(), body)
    }

    parseCaseGuard(): MatchGuard {
        let guardToken = self.skip(LBracketLeft)
        let term = self.parseStatements()
        let p = if(!self.current().is(LPipe)) {
            PVariant(guardToken.at(), "True", [])
        } else {
            self.skip(LPipe)
            self.parsePattern()
        }
        self.skip(LBracketRight)
        MatchGuard(guardToken.at(), term, p)
    }
    
    parsePattern(): MatchPattern {
        let pattern = if(self.current().is(LWildcard)) {
            let token = self.skip(LWildcard)
            PVariable(token.at(), None)
        } elseIf {self.current().is(LLower)} {
            let token = self.skip(LLower)
            PVariable(token.at(), Some(token.raw()))
        } elseIf {self.current().rawIs("(")} {
            let at = self.current().at()
            let pair = self.parseRecordPattern().unzip()
            PVariant(at, "Record$" + pair.first.join("$"), pair.second)
        } elseIf {self.current().rawIs("[")} {
            self.parseListPattern()
        } elseIf {self.current().is(LString)} {
            let token = self.skip(LString)
            PString(token.at(), token.raw())
        } elseIf {self.current().is(LInt)} {
            let token = self.skip(LInt)
            PInt(token.at(), token.raw())
        } elseIf {self.current().is(LChar)} {
            let token = self.skip(LChar)
            PChar(token.at(), token.raw())
        } else {
            let token = self.skip(LUpper)
            if(self.current().rawIs("(")) {
                let patterns = Stack.make[MatchPattern]()
                self.rawSkip(LBracketLeft, "(")
                while {!self.current().is(LBracketRight)} {
                    patterns.push(self.parsePattern())
                    if(!self.current().is(LBracketRight)) {self.skip(LComma)}
                }
                self.rawSkip(LBracketRight, ")")
                PVariant(token.at(), token.raw(), patterns.toList())
            } else {
                if(self.current().is(LLower)) {
                    let asToken = self.skip(LLower)
                    PVariantAs(asToken.at(), token.raw(), Some(asToken.raw()))
                } elseIf {self.current().is(LWildcard)} {
                    let wildcardToken = self.skip(LWildcard)
                    PVariantAs(wildcardToken.at(), token.raw(), None)
                } else {
                    PVariant(token.at(), token.raw(), [])
                }
            }
        }
        if(self.current().rawIs("@")) {
            let atToken = self.skip(LOperator)
            let asToken = self.skip(LLower)
            PAlias(asToken.at(), pattern, asToken.raw())
        } else {pattern}
    }
    
    parseType(): Type {
        let leftTypes = if(self.current().rawIs("(") && self.ahead().is(LLower) && self.aheadAhead().is(LColon)) {
            let at = self.current().at()
            let pair = self.parseRecordType().unzip()
            [TConstructor(at, "Record$" + pair.first.join("$"), pair.second)]
        } elseIf {self.current().rawIs("(")} {
            self.parseTypeArguments(parenthesis = True)
        } else {
            let namespace = if(self.current().is(LNamespace)) {self.skip(LNamespace).raw()} else {""}
            let token = self.skip(LUpper)
            let arguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
            [TConstructor(token.at(), namespace + token.raw(), arguments)]
        }
        if(!self.current().is(LArrowThick) && leftTypes.size() == 1) {leftTypes.grabFirst()} else {
            let arrowToken = self.skip(LArrowThick)
            let rightType = self.parseType()
            TConstructor(arrowToken.at(), "Function$" + leftTypes.size(), [...leftTypes, rightType])
        }
    }

    parseConstraint(): Constraint {
        let namespace = if(self.current().is(LNamespace)) {self.skip(LNamespace).raw()} else {""}
        let token = self.skip(LUpper)
        let arguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
        Constraint(token.at(), namespace + token.raw(), arguments)
    }

    parseStatements(): Term {
        if(self.current().is2(LBracketRight, LPipe)) {EVariant(self.current().at(), "Unit", [], None)} else {
            mutable result = self.parseStatement()
            while {self.currentIsSeparator(LSemicolon)} {
                let token = self.skipSeparator(LSemicolon)
                result = ESequential(token.at(), result, self.parseStatement())
            }
            result
        }
    }
    
    parseStatement(): Term {
        if(self.current().is(LKeyword) && (self.current().rawIs("let") || self.current().rawIs("mutable"))) {self.parseLet()} else:
        if(self.current().is(LKeyword) && self.current().rawIs("function")) {self.parseFunctions()} else:
        let term = self.parseTerm()
        if(!self.current().is(LAssign) && !self.current().is3(LAssignPlus, LAssignMinus, LAssignLink)) {term} else:
        let token = do {
            if(self.current().is(LAssignPlus)) {self.skip(LAssignPlus)} else:
            if(self.current().is(LAssignMinus)) {self.skip(LAssignMinus)} else:
            if(self.current().is(LAssignLink)) {self.skip(LAssignLink)} else:
            self.skip(LAssign)
        }
        let operator = token.raw().dropLast(1)
        let value = self.parseTerm()
        term.{
            | EVariable(at, name) => EAssign(at, operator, name, value)
            | EField e => EAssignField(e.at, operator, e.record, e.field, value)
            | _ => throw(CompileError(token.at(), "Only variables and fields are assignable"))
        }
    }
    
    parseLet(): Term {
        let mutable = self.current().rawIs("mutable")
        if(mutable) {self.rawSkip(LKeyword, "mutable")} else {self.rawSkip(LKeyword, "let")}
        let nameToken = self.skip(LLower)
        let valueType = if(!self.current().is(LColon)) {self.freshUnificationVariable(nameToken.at())} else {
            self.skip(LColon)
            self.parseType()
        }
        self.skip(LAssign)
        let value = self.parseTerm()
        self.skipSeparator(LSemicolon)
        let body = self.parseStatements()
        ELet(nameToken.at(), mutable, nameToken.raw(), valueType, value, body)
    }
    
    parseFunctions(): Term {
        let at = self.current().at()
        let functions = Stack.make[DFunction]()
        while {self.current().rawIs("function")} {
            let functionAt = self.rawSkip(LKeyword, "function").at()
            let signature = self.parseSignature()
            let body = self.parseLambda(defaultParameterCount = signature.parameters.size())
            functions.push(DFunction(functionAt, signature, FireflyTarget(body)))
            self.skipSeparator(LSemicolon)
        }
        let body = self.parseStatements()
        EFunctions(at, functions.toList(), body)
    }
    
    parseTerm(): Term {
        self.parseBinary(0)
    }
    
    parseBinary(level: Int): Term {
        if(level >= binaryOperators.size()) {self.parseUnary()} else:
        let operators = binaryOperators.grab(level)
        mutable result = self.parseBinary(level + 1)
        if(self.current().is(LOperator)) {
            while {operators.any(self.current().rawIs)} {
                let token = self.skip(LOperator)
                let right = self.parseBinary(level + 1)
                let arguments = [Argument(result.at, None, result), Argument(right.at, None, right)]
                let effect = self.freshUnificationVariable(token.at())
                let target = token.raw().{
                    | "==" => DynamicCall(EVariable(token.at(), "ff:core/Equal.equals"), False)
                    | "!=" => DynamicCall(EVariable(token.at(), "ff:core/Equal.notEquals"), False)
                    | "<" => DynamicCall(EVariable(token.at(), "ff:core/Ordering.before"), False)
                    | "<=" => DynamicCall(EVariable(token.at(), "ff:core/Ordering.notAfter"), False)
                    | ">" => DynamicCall(EVariable(token.at(), "ff:core/Ordering.after"), False)
                    | ">=" => DynamicCall(EVariable(token.at(), "ff:core/Ordering.notBefore"), False)
                    | o => DynamicCall(EVariable(token.at(), o), False)
                }
                result = ECall(token.at(), target, effect, [], arguments, [])
            }
        }
        result
    }
    
    parseUnary(): Term {
        if(self.current().is(LOperator)) {
            let token = self.skip(LOperator)
            let term = self.parseUnary()
            let effect = self.freshUnificationVariable(token.at())
            let target = DynamicCall(EVariable(token.at(), token.raw()), False)
            ECall(token.at(), target, effect, [], [Argument(term.at, None, term)], [])
        } else {
            self.parseFieldsAndCalls()
        }
    }
    
    parseFieldsAndCalls(): Term {
        let tailCall = if(self.current().is(LKeyword) && self.current().rawIs("tailcall")) {
            self.skip(LKeyword)
            True
        } else {False}
        mutable result = self.parseAtom()
        while {self.current().is(LBracketLeft) || self.current().is(LColon) || self.current().is(LDot)} {
            if(self.current().is(LDot)) {
                self.skip(LDot)
                if(self.current().rawIs("{")) {
                    let term = self.parseAtom()
                    let effect = self.freshUnificationVariable(term.at)
                    result = EPipe(term.at, result, effect, term)
                } elseIf {self.current().is2(LUpper, LNamespace)} {
                    result = self.parseCopy(result)
                } else {
                    let token = self.skip(LLower)
                    result = EField(token.at(), False, result, token.raw())
                }
            } else {
                let at = self.current().at()
                let typeArguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
                let arguments = self.parseFunctionArguments(True)
                let effect = self.freshUnificationVariable(at)
                let target = DynamicCall(result, tailCall)
                result = ECall(result.at, target, effect, typeArguments, arguments.first, [])
                if(arguments.second && self.current().is(LLower)) {
                    let token = self.skip(LLower)
                    result = EField(token.at(), False, result, token.raw())
                }
            }
        }
        result
    }
    
    parseAtom(): Term {
        if(self.current().is(LString)) {
            let token = self.skip(LString)
            EString(token.at(), token.raw())
        } elseIf {self.current().is(LChar)} {
            let token = self.skip(LChar)
            EChar(token.at(), token.raw())
        } elseIf {self.current().is(LInt)} {
            let token = self.skip(LInt)
            EInt(token.at(), token.raw())
        } elseIf {self.current().is(LFloat)} {
            let token = self.skip(LFloat)
            EFloat(token.at(), token.raw())
        } elseIf {self.current().is(LLower)} {
            let token = self.skip(LLower)
            EVariable(token.at(), token.raw())
        } elseIf {self.current().is(LNamespace)} {
            let namespaceToken = self.skip(LNamespace)
            let extraNamespace = if(!self.current().is(LNamespace)) {None} else {Some(self.skip(LNamespace).raw())}
            let prefix = namespaceToken.raw() + extraNamespace.else{""}
            if(self.current().is(LLower)) {
                let token = self.skip(LLower)
                EVariable(token.at(), prefix + token.raw())
            } else {
                self.parseVariant(prefix)
            }
        } elseIf {self.current().is(LUpper)} {
            self.parseVariant("")
        } elseIf {self.current().rawIs("{")} {
            let lambda = self.parseLambda()
            ELambda(lambda.at, lambda)
        } elseIf {self.current().rawIs("[")} {
            self.parseList()
        } elseIf {self.current().rawIs("(") && self.ahead().is(LLower) && self.aheadAhead().is(LAssign)} {
            ERecord(self.current().at(), self.parseRecord())
        } elseIf {self.current().rawIs("(")} {
            self.rawSkip(LBracketLeft, "(")
            let result = self.parseTerm()
            self.rawSkip(LBracketRight, ")")
            result
        } elseIf {self.current().is(LWildcard)} {
            let token = self.skip(LWildcard)
            EWildcard(token.at(), 0)
        } else {
            throw(CompileError(self.current().at(), "Expected atom, got " + self.current().raw()))
        }
    }

    parseVariant(prefix: String): Term {
        let token = self.skip(LUpper)
        let name = prefix + token.raw()
        let typeArguments = if(!self.current().rawIs("[")) {[]} else {self.parseTypeArguments()}
        if(self.current().rawIs("?")) {self.skip(LOperator); EVariantIs(token.at(), name, typeArguments)} else:
        let arguments = Some(self.parseFunctionArguments(True))
        EVariant(token.at(), name, typeArguments, arguments.map {_.first})
    }
    
    parseCopy(record: Term): Term {
        let namespace = if(!self.current().is(LNamespace)) {""} else {self.skip(LNamespace).raw()}
        let extraNamespace = if(!self.current().is(LNamespace)) {""} else {self.skip(LNamespace).raw()}
        let prefix = namespace + extraNamespace
        let token = self.skip(LUpper)
        let name = prefix + token.raw()
        let fields = if(self.attemptFixes && !self.current().rawIs("(")) {[]} else {self.parseRecord()}
        ECopy(token.at(), name, record, fields)
    }
    
    parseRecord(): List[Field] {
        let fields = Stack.make[Field]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let fieldToken = self.skip(LLower)
            self.skip(LAssign)
            fields.push(Field(fieldToken.at(), fieldToken.raw(), self.parseTerm()))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        fields.toList()
    }
    
    parseRecordType(): List[Pair[String, Type]] {
        let fields = Stack.make[Pair[String, Type]]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let fieldToken = self.skip(LLower)
            self.skipSeparator(LColon)
            fields.push(Pair(fieldToken.raw(), self.parseType()))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        fields.toList().sortBy {_.first}
    }
    
    parseRecordPattern(): List[Pair[String, MatchPattern]] {
        let fields = Stack.make[Pair[String, MatchPattern]]()
        self.rawSkip(LBracketLeft, "(")
        while {!self.current().is(LBracketRight)} {
            let fieldToken = self.skip(LLower)
            self.skip(LAssign)
            fields.push(Pair(fieldToken.raw(), self.parsePattern()))
            if(!self.current().is(LBracketRight)) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, ")")
        fields.toList().sortBy {_.first}
    }

    parseListPattern(): MatchPattern {
        function convertListPattern(at: Location, items: List[Pair[MatchPattern, Bool]]): MatchPattern {
            | _, [] => PVariant(at, "ff:core/List.Empty", [])
            | _, [Pair(p, False), ...ps] =>
                PVariant(p.at, "ff:core/List.Link", [p, convertListPattern(p.at, ps)])
            | _, [Pair(p, True)] => p
            | _, [Pair(p, True), ...] =>
                throw(CompileError(p.at, "Invalid pattern: ... is only allowed for the last element in a list"))
        }
        let items = Stack.make[Pair[MatchPattern, Bool]]()
        let at = self.rawSkip(LBracketLeft, "[").at()
        while {!self.current().rawIs("]")} {
            let spread = self.current().is(LDotDotDot)
            if(spread) {self.skip(LDotDotDot)}
            let pattern = if(spread && self.current().rawIs("]")) {
                PVariable(self.current().at(), None)
            } else {
                self.parsePattern()
            }
            items.push(Pair(pattern, spread))
            if(!self.current().rawIs("]")) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, "]")
        convertListPattern(at, items.toList())
    }

    parseList(): Term {
        let items = Stack.make[Pair[Term, Bool]]()
        let at = self.rawSkip(LBracketLeft, "[").at()
        while {!self.current().rawIs("]")} {
            let spread = self.current().is(LDotDotDot)
            if(spread) {self.skip(LDotDotDot)}
            items.push(Pair(self.parseTerm(), spread))
            if(!self.current().rawIs("]")) {self.skipSeparator(LComma)}
        }
        self.rawSkip(LBracketRight, "]")
        EList(at, self.freshUnificationVariable(at), items.toList())
    }

}

binaryOperators = [
    ["||"]
    ["&&"]
    ["!=", "=="]
    ["<=", ">=", "<", ">"]
    ["+", "-"]
    ["*", "/", "%"]
    ["^"]
].toArray()

findBestTarget(targetIsNode: Bool, body: Option[Lambda], targets: ParsedTargets): Target {
    let foreignTarget = if(targetIsNode) {
        let sync = targets.nodeSync.orElse {targets.jsSync}
        let async = targets.nodeAsync.orElse {targets.jsAsync}
        ForeignTarget(sync, async)
    } else {
        let sync = targets.browserSync.orElse {targets.jsSync}
        let async = targets.browserAsync.orElse {targets.jsAsync}
        ForeignTarget(sync, async)
    }
    foreignTarget.{
        | ForeignTarget(None, None) {targetIsNode} =>
            targets.node.orElse {targets.js.orElse {body}}.map {FireflyTarget(_)}.else {foreignTarget}
        | ForeignTarget(None, None) {!targetIsNode} =>
            targets.browser.orElse {targets.js.orElse {body}}.map {FireflyTarget(_)}.else {foreignTarget}
        | _ => foreignTarget
    }
}
