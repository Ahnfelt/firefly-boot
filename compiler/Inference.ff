import Syntax
import Unification
import Environment
import Substitution

type Inference(
    unification: Unification
)

make(modules: List[Module]): Inference {
    Inference(
        unification = Unification.make(modules)
    )
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

core(name: String): String {
    "ff:core/" + name + "." + name
}

extend self: Inference {

    inferModule(module: Module, otherModules: List[Module]): Module {
        let environment = Environment.make(module, otherModules)

        let lets = module.lets.map { self.inferLetDefinition(environment, _) }
        let functions = module.functions.map { self.inferFunctionDefinition(environment, _) }
        let extends = module.extends.map { self.inferExtendDefinition(environment, _) }
        let traits = module.traits.map { self.inferTraitDefinition(environment, _) }
        let instances = module.instances.map { self.inferInstanceDefinition(environment, _) }
        let result = module.Module(
            traits = traits,
            instances = instances,
            extends = extends,
            lets = lets,
            functions = functions,
        )
        Substitution(self.unification.substitution).substituteModule(result)
    }

    inferTraitDefinition(environment: Environment, definition: DTrait): DTrait {
        definition.DTrait(

        )
    }

    inferInstanceDefinition(environment: Environment, definition: DInstance): DInstance {
        let instances = constraintsToInstances(definition.constraints)
        self.unification.withLocalInstances(instances) {
            definition.DInstance(
                methods = definition.methods.map { self.inferFunctionDefinition(environment, _) }
            )
        }
    }

    inferLetDefinition(environment: Environment, definition: DLet): DLet {
        let value = self.inferTerm(environment, definition.variableType, definition.value)
        definition.DLet(
            value = value
        )
    }

    inferExtendDefinition(environment: Environment, definition: DExtend): DExtend {
        let selfParameter = Parameter(
            at = definition.at
            mutable = False
            name = definition.name
            valueType = definition.type
            default = None
        )
        let functions = definition.methods.map { method =>
            let signature = method.signature.Signature(
                generics = [...definition.generics, ...method.signature.generics]
                constraints = [...definition.constraints, ...method.signature.constraints]
                parameters = [selfParameter, ...method.signature.parameters]
            )
            let lambda = method.body.Lambda(
                cases = method.body.cases.map { case =>
                    let selfPattern = PVariable(method.at, Some(definition.name))
                    case.MatchCase(
                        patterns = [selfPattern, ...case.patterns]
                    )
                }
            )
            let function = method.DFunction(
                signature = signature
                body = lambda
            )
            self.inferFunctionDefinition(environment, function)
        }
        definition.DExtend(
            methods = functions
        )
    }

    inferFunctionDefinition(environment: Environment, definition: DFunction): DFunction {
        let parameters = definition.signature.parameters.map { p =>
            let scheme =
                Scheme(True, False, False, False, Signature(p.at, p.name, [], [], [], [], SUnknown, p.valueType))
            Pair(p.name, scheme)
        }
        let parameterMap = parameters.toMap()
        let environment2 = environment.Environment(symbols = environment.symbols.addAll(parameterMap))
        let functionType = TConstructor(
            definition.at,
            "Function$" + parameters.size(),
            [...parameters.map { _.second.signature.returnType }, definition.signature.returnType],
            []
        )
        let instances = constraintsToInstances(definition.signature.constraints)
        self.unification.withLocalInstances(instances) {
            definition.DFunction(body = self.inferLambda(environment2, functionType, definition.body))
        }
    }

    inferLambda(environment: Environment, expected: Type, lambda: Lambda): Lambda {
        let unitName = core("Unit")
        let returnsUnit = self.unification.substitute(expected).{
            | TConstructor(_, name, ts, _) {name.startsWith("Function$")} =>
                ts.expectLast().{
                    | TConstructor(_, n, [], _) => n == unitName
                    | _ => False
                }
            | _ => False
        }
        let cases = if(!returnsUnit) { lambda.cases } else {
            lambda.cases.map { c =>
                c.MatchCase(body = ESequential(c.at, c.body, EVariant(c.at, unitName, [], None)))
            }
        }
        lambda.Lambda(
            cases = cases.map { self.inferMatchCase(environment, expected, _) }
        )
    }

    inferMatchCase(environment: Environment, expected: Type, case: MatchCase): MatchCase {
        let parameterTypes = case.patterns.map { self.unification.freshUnificationVariable(_.at) }
        let returnType = self.unification.freshUnificationVariable(case.at)
        let functionType = TConstructor(
            case.at,
            "Function$" + case.patterns.size(),
            [...parameterTypes, returnType],
            []
        )
        self.unification.unify(case.at, expected, functionType)
        let environment1 = parameterTypes.zip(case.patterns).foldLeft(environment) {| environment1, Pair(t, c) =>
            let symbols = self.inferPattern(environment, t, c).map {| Pair(name, type) =>
                Pair(name, Scheme(True, False, False, False, Signature(c.at, name, [], [], [], [], SSync, type)))
            }
            Environment(environment1.symbols.addAll(symbols))
        }
        mutable guards = []
        let environment3 = case.guards.foldLeft(environment1) { environment2, g =>
            let guardType = self.unification.freshUnificationVariable(g.at)
            let guardTerm = self.inferTerm(environment2, guardType, g.term)
            let symbols = self.inferPattern(environment2, guardType, g.pattern).map {| Pair(name, type) =>
                Pair(name, Scheme(True, False, False, False, Signature(g.at, name, [], [], [], [], SSync, type)))
            }
            guards = [g.MatchGuard(term = guardTerm), ...guards]
            Environment(environment2.symbols.addAll(symbols))
        }
        case.MatchCase(
            body = self.inferTerm(environment3, returnType, case.body)
            guards = guards.reverse()
        )
    }

    inferPattern(environment: Environment, expected: Type, pattern: MatchPattern): Map[String, Type] {
        function literal(coreTypeName: String): Map[String, Type] {
            self.unification.unify(pattern.at, expected, TConstructor(pattern.at, core(coreTypeName), [], []))
            Map.empty()
        }
        pattern.{
            | PString _ =>
                literal("String")
            | PInt _ =>
                literal("Int")
            | PChar _ =>
                literal("Char")
            | PVariable(at, None) =>
                Map.empty()
            | PVariable(at, Some(name)) =>
                [Pair(name, expected)].toMap()
            | PAlias(at, pattern, variable) =>
                self.inferPattern(environment, expected, pattern).add(variable, expected)
            | PVariantAs(at, name, None) =>
                let instantiated = self.lookup(environment, at, name, []).else {
                    fail(at, "No such variant: " + name)
                }
                if(instantiated.scheme.isNewtype) {
                    fail(at, "This kind of pattern is not allowed for newtypes")
                }
                Map.empty()
            | PVariantAs(at, name, Some(variable)) =>
                let instantiated = self.lookup(environment, at, name, []).else {
                    fail(at, "No such variant: " + name)
                }
                if(instantiated.scheme.isNewtype) {
                     fail(at, "This kind of pattern is not allowed for newtypes")
                }
                self.unification.unify(at, expected, instantiated.scheme.signature.returnType)
                let parameters = instantiated.scheme.signature.parameters.sortBy { _.name }
                let recordType =
                    TConstructor(at, "Record$" + parameters.map { _.name }.join("$"), parameters.map { _.valueType }, [])
                [Pair(variable, recordType)].toMap()
            | PVariant(at, name, patterns) =>
                let instantiated = self.lookup(environment, at, name, []).else {
                    fail(at, "No such variant: " + name)
                }
                self.unification.unify(at, expected, instantiated.scheme.signature.returnType)
                patterns.zip(instantiated.scheme.signature.parameters).map {| Pair(pattern, parameter) =>
                    self.inferPattern(environment, parameter.valueType, pattern)
                }.foldLeft(Map.empty[String, Type]()) { _.addAll(_) }
        }
    }

    inferTerm(environment: Environment, expected: Type, term: Term): Term {
        function literal(coreTypeName: String): Term {
            self.unification.unify(term.at, expected, TConstructor(term.at, core(coreTypeName), [], []))
            term
        }
        term.{
            | EString _ => literal("String")
            | EChar _ => literal("Char")
            | EInt _ => literal("Int")
            | EFloat _ => literal("Float")
            | EVariable e =>
                self.lookup(environment, e.at, e.name, []).map { instantiated =>
                    if(instantiated.scheme.isVariable) {
                        self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                        term
                    } else {
                        self.inferEtaExpansion(
                            environment,
                            expected,
                            e.at,
                            instantiated.scheme.isTraitMethod,
                            instantiated.scheme.signature,
                            term
                        )
                    }
                } else {
                    fail(e.at, "Symbol not in scope: " + e.name)
                }
            | EField e =>
                let recordType = self.unification.freshUnificationVariable(e.at)
                let record = self.inferTerm(environment, recordType, e.record)
                let e2 = e.EField(record = record)
                self.unification.substitute(recordType).{
                    | TConstructor(_, name, typeArguments, _)@t {name.startsWith("Record$")} =>
                        let fieldNames = name.split('$').toList().dropFirst(1)
                        fieldNames.pairs().find { _.second == e.field }.map { _.first }.map { index =>
                            let t1 = typeArguments.expect(index)
                            self.unification.unify(e.at, expected, t1)
                            e2
                        }.else {
                            fail(e.at, "No such field " + e.field + " on type: " + t.show())
                        }
                    | TConstructor(_, name, typeArguments, _)@t =>
                        let methodName = name + "_" + e.field
                        self.lookup(environment, e.at, methodName, typeArguments).{
                            | Some(instantiated) {!instantiated.scheme.isVariable} =>
                                let signature = instantiated.scheme.signature.Signature(
                                    // Drop self for eta expansion
                                    parameters = instantiated.scheme.signature.parameters.dropFirst(1)
                                )
                                self.unification.unify(
                                    e.at,
                                    recordType,
                                    instantiated.scheme.signature.parameters.expect(0).valueType
                                )
                                self.inferEtaExpansion(environment, expected, e.at, False, signature, e2)
                            | Some(instantiated) =>
                                /*self.unification.unify(
                                    e.at,
                                    recordType,
                                    instantiated.scheme.signature.parameters.expect(0).valueType
                                )*/
                                self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                                e.EField(newtype = instantiated.scheme.isNewtype, record = record)
                            | None =>
                                fail(e.at, "No such field " + e.field + " on type: " + t.show())
                        }
                    | TVariable(_, index) =>
                        fail(e.at, "No such field " + e.field + " on unknown type: $" + index)
                }
            | EWildcard e =>
                self.lookup(environment, e.at, "_w" + e.index, []).map { instantiated =>
                    self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                    term
                }.expect()
            | EList(at, t, items) =>
                let listType = TConstructor(term.at, core("List"), [t], [])
                self.unification.unify(at, expected, listType)
                EList(at, t, items.map { | Pair(item, spread) =>
                    Pair(self.inferTerm(environment, if(spread) { listType } else { t }, item), spread)
                })
            | ESequential(at, before, after) =>
                let newExpected = self.unification.freshUnificationVariable(at)
                before.{
                    | EPipe(at1, value, ELambda(at2, Lambda(at3, cases))) =>
                        let e = EVariant(at, "ff:core/Unit.Unit", [], None)
                        let newCases = cases.map { case => case.MatchCase(body = ESequential(case.at, case.body, e)) }
                        let newPipe = EPipe(at1, value, ELambda(at2, Lambda(at3, newCases)))
                        after.{
                            | EVariant(at, "ff:core/Unit.Unit", _, _) =>
                                let unitType = TConstructor(at, core("Unit"), [], [])
                                self.unification.unify(at, expected, unitType)
                                self.inferTerm(environment, newExpected, newPipe)
                            | _ =>
                                ESequential(
                                    at = at
                                    before = self.inferTerm(environment, newExpected, newPipe)
                                    after = self.inferTerm(environment, expected, after)
                                )
                        }
                    | _ =>
                        ESequential(
                            at = at
                            before = self.inferTerm(environment, newExpected, before)
                            after = self.inferTerm(environment, expected, after)
                        )
                }
            | ELet e =>
                let scheme =
                    Scheme(True, e.mutable, False, False, Signature(e.at, e.name, [], [], [], [], SSync, e.valueType))
                let environment2 = environment.Environment(symbols = environment.symbols.add(e.name, scheme))
                e.ELet(
                    value = self.inferTerm(environment, e.valueType, e.value)
                    body = self.inferTerm(environment2, expected, e.body)
                )
            | ELambda(at, l) =>
                let lambda = self.inferLambda(environment, expected, l)
                ELambda(at, lambda)
            | EVariant e =>
                let instantiated = self.lookup(environment, e.at, e.name, e.typeArguments).else {
                    fail(e.at, "Symbol not in scope: " + e.name)
                }
                self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                let arguments = e.arguments.map {
                    self.inferArguments(e.at, environment, instantiated.scheme.signature.parameters, _)
                }
                e.EVariant(
                    typeArguments = instantiated.typeArguments.map { _.second }
                    arguments = arguments
                )
            | EVariantIs e =>
                let instantiated = self.lookup(environment, e.at, e.name, e.typeArguments).else {
                    fail(e.at, "Symbol not in scope: " + e.name)
                }
                let parameters = instantiated.scheme.signature.parameters.sortBy { _.name }
                let recordType =
                    TConstructor(e.at, "Record$" + parameters.map { _.name }.join("$"), parameters.map { _.valueType }, [])
                let functionType = TConstructor(e.at, "Function$1", [
                    instantiated.scheme.signature.returnType
                    TConstructor(e.at, core("Option"), [recordType], [])
                ], [])
                self.unification.unify(e.at, expected, functionType)
                e.EVariantIs(
                    typeArguments = instantiated.typeArguments.map { _.second }
                )
            | ECopy e =>
                let scheme = self.lookup(environment, e.at, e.name, []).else {
                    fail(e.at, "Symbol not in scope: " + e.name)
                }.scheme
                if(scheme.isNewtype) {
                    fail(e.at, "Newtypes can't be copied")
                }
                let signature = scheme.signature
                let parameterNames = signature.parameters.map { _.name }
                e.arguments.find { a => !parameterNames.any { _ == a.name } }.each {
                    | Field(at, name, value) => fail(at, "Unknown parameter: " + name)
                }
                let arguments = parameterNames.map { name =>
                    e.arguments.find { _.name == name }.map {
                        | Field(at, _, value) => Argument(at, Some(name), value)
                    }.else {
                        Argument(e.at, Some(name), EField(e.at, False, EVariable(e.at, "_c"), name))
                    }
                }
                let body = EVariant(e.at, e.name, [], Some(arguments))
                let term = EPipe(e.at, e.record,
                    ELambda(e.at, Lambda(e.at, [MatchCase(e.at, [PVariable(e.at, Some("_c"))], [], body)]))
                )
                self.inferTerm(environment, expected, term)
            | EPipe e =>
                let valueType = self.unification.freshUnificationVariable(e.at)
                let functionType = TConstructor(e.at, "Function$1", [valueType, expected], [])
                let value = self.inferTerm(environment, valueType, e.value)
                let function = self.inferTerm(environment, functionType, e.function)
                e.EPipe(
                    value = value
                    function = function
                )
            | ECall e =>
                e.function.{
                    | EVariable(variableAt, x) =>
                        if(x.first().any { c => c != '_' && !c.isAsciiLetter() }) {
                            self.inferOperator(environment, expected, x, term)
                        } else {
                            self.lookup(environment, e.at, x, e.typeArguments).{
                                | Some(instantiated) =>
                                    if(instantiated.scheme.isVariable) {
                                        self.inferLambdaCall(environment, expected, term)
                                    } else {
                                        let signature = instantiated.scheme.signature
                                        self.inferFunctionCall(
                                            environment,
                                            expected,
                                            signature,
                                            instantiated.scheme.isTraitMethod
                                            instantiated.typeArguments,
                                            term,
                                            x
                                        )
                                    }
                                | None =>
                                    fail(variableAt, "No such function: " + x)
                            }
                        }
                    | EField f =>
                        let recordType = self.unification.freshUnificationVariable(f.at)
                        let record = self.inferTerm(environment, recordType, f.record)
                        let e2 = e.ECall(function = f.EField(record = record))
                        self.unification.substitute(recordType).{
                            | TConstructor(_, name, typeParameters, _)@t =>
                                let methodName = name + "_" + f.field
                                self.lookup(environment, f.at, methodName, []).{
                                    | Some(instantiated) {!instantiated.scheme.isVariable} =>
                                        self.inferMethodCall(
                                            environment,
                                            expected,
                                            instantiated.scheme.signature,
                                            instantiated.typeArguments,
                                            e2,
                                            record,
                                            methodName
                                        )
                                    | Some(instantiated) =>
                                        self.inferLambdaCall(environment, expected, e2)
                                    | None =>
                                        fail(f.at, "No such field " + f.field + " on type: " + t.show())
                                }
                            | TVariable(_, index) =>
                                fail(f.at, "No such field " + f.field + " on unknown type: $" + index)
                        }
                    | _ =>
                        self.inferLambdaCall(environment, expected, term)
                }
            | ERecord e =>
                let fields = e.fields.sortBy {_.name}
                let fieldTypes = fields.map { self.unification.freshUnificationVariable(_.at) }
                let recordType =
                    TConstructor(e.at, "Record$" + fields.map {_.name}.join("$"), fieldTypes, [])
                self.unification.unify(e.at, expected, recordType)
                let newFields = fields.zip(fieldTypes).map {| Pair(field, t) =>
                    field.Field(value = self.inferTerm(environment, t, field.value))
                }
                e.ERecord(
                    fields = newFields
                )
            | EFunctions(at, functions, body) =>
                let functionMap = functions.map { f =>
                    let scheme = Scheme(False, False, False, False, f.signature)
                    Pair(f.signature.name, scheme)
                }.toMap()
                let environment2 = environment.Environment(symbols = environment.symbols.addAll(functionMap))
                let newFunctions = functions.map { self.inferFunctionDefinition(environment2, _) }
                let newBody = self.inferTerm(environment2, expected, body)
                EFunctions(
                    at = at,
                    functions = newFunctions,
                    body = newBody
                )
            | EAssign e =>
                self.lookup(environment, e.at, e.variable, []).map { instantiated =>
                    if(instantiated.scheme.isMutable) {
                        let value = self.inferAssignment(
                            environment = environment
                            expected = expected
                            at = e.at
                            operator = e.operator
                            value = e.value
                            signature = instantiated.scheme.signature
                        )
                        e.EAssign(
                            value = value
                        )
                    } else {
                        fail(e.at, "Symbol is not mutable: " + e.variable)
                    }
                } else {
                    fail(e.at, "Symbol not in scope: " + e.variable)
                }
            | EAssignField e =>
                let recordType = self.unification.freshUnificationVariable(e.at)
                let record = self.inferTerm(environment, recordType, e.record)
                self.unification.substitute(recordType).{
                    | TConstructor(_, name, typeArguments, _)@t {name.startsWith("Record$")} =>
                        fail(e.at, "Can't assign fields of anonymous records: " + e.field)
                    | TConstructor(_, name, typeArguments, _)@t =>
                        let methodName = name + "_" + e.field
                        self.lookup(environment, e.at, methodName, typeArguments).{
                            | Some(instantiated) {instantiated.scheme.isMutable} =>
                                let value = self.inferAssignment(
                                    environment = environment
                                    expected = expected
                                    at = e.at
                                    operator = e.operator
                                    value = e.value
                                    signature = instantiated.scheme.signature
                                )
                                e.EAssignField(
                                    record = record
                                    value = value
                                )
                            | Some(instantiated) =>
                                fail(e.at, "Can't assign an immutable field " + e.field + " on type: " + t.show())
                            | None =>
                                fail(e.at, "No such field " + e.field + " on type: " + t.show())
                        }
                    | TVariable(_, index) =>
                        fail(e.at, "No such field " + e.field + " on unknown type: $" + index)
                }
        }
    }

    inferAssignment(
        environment: Environment
        expected: Type
        at: Location
        operator: String
        value: Term
        signature: Signature
    ): Term {
        let t = signature.returnType
        if(operator == "+" || operator == "-") {
            self.unification.unify(at, t, TConstructor(at, core("Int"), [], []))
        } elseIf {operator != ""} {
            fail(at, "Only +=, -= and = assignments are supported. Got: " + operator + "=")
        }
        let newValue = self.inferTerm(environment, t, value)
        self.unification.unify(at, expected, TConstructor(at, core("Unit"), [], []))
        newValue
    }

    inferMethodCall(
        environment: Environment,
        expected: Type,
        signature: Signature,
        instantiation: List[Pair[String, Type]],
        term: Term,
        record: Term,
        name: String
    ): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected") }
        let e2 = e.ECall(
            function = EVariable(e.at, name)
            arguments = [Argument(record.at, None, record), ...e.arguments]
        )
        self.inferFunctionCall(environment, expected, signature, False, instantiation, e2, name)
    }

    inferFunctionCall(
        environment: Environment,
        expected: Type,
        signature: Signature,
        instanceCall: Bool
        instantiation: List[Pair[String, Type]],
        term: Term,
        name: String
    ): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected") }
        self.unification.unify(e.at, expected, signature.returnType)
        let arguments = self.inferArguments(e.at, environment, signature.parameters, e.arguments)
        e.ECall(
            instanceCall = instanceCall
            function = e.function // It's always a function name - should we propagate that information?
            typeArguments = instantiation.map { _.second }
            arguments = arguments
        )
    }

    inferLambdaCall(environment: Environment, expected: Type, term: Term): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected") }
        let argumentTypes = e.arguments.map { self.unification.freshUnificationVariable(_.at) }
        let functionType = TConstructor(e.at, "Function$" + e.arguments.size(), [...argumentTypes, expected], [])
        let function = self.inferTerm(environment, functionType, e.function)
        let arguments = e.arguments.zip(argumentTypes).map { | Pair(argument, t) =>
            argument.name.each { name =>
                fail(argument.at, "Named argument not allowed here: " + name)
            }
            argument.Argument(value = self.inferTerm(environment, t, argument.value))
        }
        e.typeArguments.first().each { typeArgument =>
            fail(typeArgument.at, "Type arguments not allowed here")
        }
        e.ECall(
            function = function
            typeArguments = []
            arguments = arguments
        )
    }

    inferOperator(environment: Environment, expected: Type, operator: String, term: Term): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected") }
        e.arguments.{
            | [a1] {
                operator == "!"
            } =>
                let t = TConstructor(e.at, core("Bool"), [], [])
                let e1 = self.inferTerm(environment, t, a1.value)
                self.unification.unify(e.at, expected, t)
                e.ECall(arguments = [a1.Argument(value = e1)])
            | [a1] {
                operator == "-"
            } =>
                let t1 = self.unification.freshUnificationVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                self.unification.substitute(t1).{
                    | TConstructor(_, name, [], _) {name == core("Float")} =>
                        self.unification.unify(e.at, expected, t1)
                    | TConstructor(_, name, [], _) {name == core("Int")} =>
                        self.unification.unify(e.at, expected, t1)
                    | _ =>
                        fail(e.at, "Operators on unknown types not currently supported")
                }
                e.ECall(arguments = [a1.Argument(value = e1)])
            | [a1, a2] {
                operator == "||" || operator == "&&"
            } =>
                let t = TConstructor(e.at, core("Bool"), [], [])
                let e1 = self.inferTerm(environment, t, a1.value)
                let e2 = self.inferTerm(environment, t, a2.value)
                self.unification.unify(e.at, expected, t)
                e.ECall(arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | [a1, a2] {
                operator == "<" || operator == ">" ||
                operator == "<=" || operator == ">=" ||
                operator == "==" || operator == "!="
            } =>
                let t = TConstructor(e.at, core("Bool"), [], [])
                let t1 = self.unification.freshUnificationVariable(e.at)
                let t2 = self.unification.freshUnificationVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                let e2 = self.inferTerm(environment, t2, a2.value)
                let magic: Type => Option[String] = { t =>
                    self.unification.substitute(t).{
                        | TConstructor(_, name, [], _) {name == core("String")} => Some("String")
                        | TConstructor(_, name, [], _) {name == core("Float")} => Some("Float")
                        | TConstructor(_, name, [], _) {name == core("Int")} => Some("Int")
                        | TConstructor(_, name, [], _) {name == core("Char")} => Some("Char")
                        | TConstructor(_, name, [], _) {name == core("Duration")} => Some("Duration")
                        | TConstructor(_, name, [], _) {name == core("Instant")} => Some("Instant")
                        | _ => None
                    }
                }
                let chooseType: (Option[String], Option[String]) => Unit = {
                    | Some(_), _ =>
                        self.unification.unify(e.at, t1, t2)
                        self.unification.unify(e.at, expected, t)
                    | _, Some(_) =>
                        self.unification.unify(e.at, t2, t1)
                        self.unification.unify(e.at, expected, t)
                    | _, _ { operator == "==" || operator == "!=" } =>
                        // TODO: This case is cheating, remove it
                        self.unification.unify(e.at, t2, t1)
                        self.unification.unify(e.at, expected, t)
                    | None, None =>
                        fail(e.at, "Operators on unknown types not currently supported")
                }
                chooseType(magic(t1), magic(t2))
                e.ECall(arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | [a1, a2] {
                operator == "+" || operator == "-" ||
                operator == "*" || operator == "/" || operator == "%" ||
                operator == "^"
            } =>
                let t1 = self.unification.freshUnificationVariable(e.at)
                let t2 = self.unification.freshUnificationVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                let e2 = self.inferTerm(environment, t2, a2.value)
                let magic: Type => Option[String] = { t =>
                    self.unification.substitute(t).{
                        | TConstructor(_, name, [], _) {name == core("Float")} => Some("Float")
                        | TConstructor(_, name, [], _) {name == core("Int")} => Some("Int")
                        | TConstructor(_, name, [], _) {operator == "+" && name == core("String")} => Some("String")
                        | _ => None
                    }
                }
                let chooseType: (Option[String], Option[String]) => Unit = {
                    | Some("String"), Some(_) => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some("String") => self.unification.unify(e.at, expected, t2)
                    | Some("Float"), Some(_) => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some("Float") => self.unification.unify(e.at, expected, t2)
                    | Some("Int"), Some(_) => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some("Int") => self.unification.unify(e.at, expected, t2)
                    | Some(_), None =>
                        self.unification.unify(e.at, t1, t2)
                        self.unification.unify(e.at, expected, t1)
                    | None, Some(_) =>
                        self.unification.unify(e.at, t2, t1)
                        self.unification.unify(e.at, expected, t2)
                    | Some(_), Some(_) =>
                        fail(e.at, "Operators on these types not currently supported")
                    | None, None =>
                        fail(e.at, "Operators on unknown types not currently supported")
                }
                chooseType(magic(t1), magic(t2))
                e.ECall(arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | _ =>
                fail(e.at, "Unknown operator: " + operator)
        }
    }

    inferEtaExpansion(
        environment: Environment
        expected: Type
        at: Location
        instanceCall: Bool
        signature: Signature
        term: Term
    ): Term {
        let parameters = signature.parameters.filter { _.default.isEmpty() }.map { p =>
            p.name
        }
        let body = ECall(at, instanceCall, False, term, [], parameters.map { x =>
            Argument(at, Some(x), EVariable(at, x))
        }, [])
        let lambda = ELambda(at, Lambda(at, [MatchCase(
            at = at,
            patterns = parameters.map { PVariable(at, Some(_)) },
            guards = [],
            body = body
        )]))
        self.inferTerm(environment, expected, lambda)
    }

    inferArguments(
        at: Location
        environment: Environment
        parameters: List[Parameter]
        arguments: List[Argument]
    ): List[Argument] {
        mutable remainingArguments = arguments
        let newArguments = parameters.map { p =>
            let t = p.valueType
            function defaultArgument(): Argument {
                p.default.map { e =>
                    let e2 = self.inferTerm(environment, t, e)
                    Argument(at, Some(p.name), e2)
                }.else {
                    fail(at, "Missing argument: " + p.name)
                }
            }
            remainingArguments.{
                | [] =>
                    defaultArgument()
                | [Argument(at, None, e), ...remaining] =>
                    remainingArguments = remaining
                    let e2 = self.inferTerm(environment, t, e)
                    Argument(at, Some(p.name), e2)
                | _ =>
                    remainingArguments.find { _.name.contains(p.name) }.map { | Argument(at, _, e) =>
                        remainingArguments = remainingArguments.filter { !_.name.contains(p.name) }
                        let e2 = self.inferTerm(environment, t, e)
                        Argument(at, Some(p.name), e2)
                    }.else {
                        defaultArgument()
                    }
            }
        }
        remainingArguments.first().each {
            | Argument(at, None, _) => fail(at, "Too many arguments")
            | Argument(at, Some(name), _) => fail(at, "Unknown argument: " + name)
        }
        newArguments
    }

    lookup(environment: Environment, at: Location, symbol: String, typeArguments: List[Type]): Option[Instantiated] {

        environment.symbols.get(symbol).map: scheme =>

        let instantiation =
            if(!typeArguments.isEmpty()) {
                if(scheme.signature.generics.size() != typeArguments.size()) {
                    fail(at,
                        "Wrong number of type parameters for " + symbol +
                        ", expected " + scheme.signature.generics.size() +
                        ", got " + typeArguments.size()
                    )
                }
                scheme.signature.generics.zip(typeArguments)
            } else {
                scheme.signature.generics.map { name =>
                    Pair(name, self.unification.freshUnificationVariable(at))
                }
            }

        let instantiationMap = instantiation.toMap()
        let parameters = scheme.signature.parameters.map { p =>
            p.Parameter(valueType = self.unification.instantiate(instantiationMap, p.valueType))
        }
        let returnType = self.unification.instantiate(instantiationMap, scheme.signature.returnType)

        scheme.signature.constraints.each { c =>
            let generics = c.generics.map { self.unification.instantiate(instantiationMap, _) }
            self.unification.constrain(at, generics.expectFirst(), c.name, generics.dropFirst())
        }

        let signature = scheme.signature.Signature(
            generics = []
            constraints = []
            parameters = parameters
            returnType = returnType
        )

        Instantiated(
            typeArguments = instantiation
            scheme = scheme.Scheme(signature = signature)
        )

    }

}

constraintsToInstances(constraints: List[Constraint]): Map[InstanceKey, InstanceValue] {
    constraints.map { c =>
        let typeName = c.generics.expectFirst().{
            | TConstructor(_, name, _, _) => name
            | TVariable(at, i) => fail(c.at, "Unexpected unification variable: $" + i)
        }
        Pair(
            InstanceKey(c.name, typeName)
            InstanceValue(
                generics = []
                constraints = []
                packageName = ""
                moduleName = ""
                traitName = c.name
                typeArguments = c.generics
            )
        )
    }.toMap()
}
