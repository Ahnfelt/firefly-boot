import Syntax
import Unification
import Environment
import Substitution
import LspHook

class Inference(
    unification: Unification
    missing: StringMap[Pair[Instantiated, Option[List[Argument]]]]
    lspHook: LspHook
)

make(modules: List[Module], lspHook: LspHook): Inference {
    Inference(
        unification = Unification.make(modules, attemptFixes = lspHook.isEnabled())
        missing = StringMap.make()
        lspHook = lspHook
    )
}

fail[T](at: Location, message: String): T {
    throw(CompileError(at, message))
}

core(name: String): String {
    "ff:core/" + name + "." + name
}

extend self: Inference {

    inferModule(module: Module, otherModules: List[Module]): Module {
        let environment = Environment.make(module, otherModules, alreadyFlat = False)

        let lets = module.lets.map {self.inferLetDefinition(environment, _)}
        let functions = module.functions.map {self.inferFunctionDefinition(environment, _)}
        let extends = module.extends.map {self.inferExtendDefinition(environment, _)}
        let traits = module.traits.map {self.inferTraitDefinition(environment, _)}
        let instances = module.instances.map {self.inferInstanceDefinition(environment, _)}
        let result = module.Module(
            traits = traits
            instances = instances
            extends = extends
            lets = lets
            functions = functions
        )
        let subsititution = Substitution(self.unification.substitution)
        subsititution.substituteModule(result)
    }

    inferTraitDefinition(environment: Environment, definition: DTrait): DTrait {
        definition.DTrait(

        )
    }

    inferInstanceDefinition(environment: Environment, definition: DInstance): DInstance {
        if(self.lspHook.isEnabled() && definition.derived) {definition} else:
        let instances = constraintsToInstances(definition.constraints)
        self.unification.withLocalInstances(instances) {
            definition.DInstance(
                // TODO: Check that the methods adhere to the instantiated trait method signatures
                // It needs to look at the instantiated trait, e.g. `trait T: Show` and `instance Foo: Show`
                // gives an instantiation `T = Foo`, which should be applied to all the methods before checking.
                methods = definition.methods.map {instanceFunction =>
                    let methodName = instanceFunction.signature.name
                    let traitName = definition.traitName
                    let traitMethodName = traitName.reverse().dropWhile {_ != '.'}.reverse() + methodName
                    let traitMethod = environment.symbols.get(traitMethodName).else {
                        throw(CompileError(instanceFunction.at
                            "Trait " + traitName + " has no such method: " + methodName
                        ))
                    }
                    let newInstanceFunction = self.inferFunctionDefinition(environment, instanceFunction)
                    newInstanceFunction
                }
            )
        }
    }

    inferLetDefinition(environment: Environment, definition: DLet): DLet {
        let value = self.inferTerm(environment, definition.variableType, definition.value)
        definition.DLet(
            value = value
        )
    }

    inferExtendDefinition(environment: Environment, definition: DExtend): DExtend {
        let selfParameter = Parameter(
            at = definition.at
            mutable = False
            name = definition.name
            valueType = definition.type
            default = None
        )
        let functions = definition.methods.map {method =>
            let signature = method.signature.Signature(
                generics = [...definition.generics, ...method.signature.generics]
                constraints = [...definition.constraints, ...method.signature.constraints]
                parameters = [selfParameter, ...method.signature.parameters]
            )
            let body = method.body.mapFirefly {lambda =>
                lambda.Lambda(
                    cases = lambda.cases.map {case =>
                        case.MatchCase(
                            patterns = [PVariable(method.at, None), ...case.patterns]
                        )
                    }
                )
            }
            let function = method.DFunction(
                signature = signature
                body = body
            )
            self.inferFunctionDefinition(environment, function)
        }
        definition.DExtend(
            methods = functions
        )
    }

    inferFunctionDefinition(environment: Environment, definition: DFunction): DFunction {
        let parameters = definition.signature.parameters.map {p =>
            let noEffect = TConstructor(p.at, "ff:core/Nothing.Nothing", [])
            let scheme = Scheme(True, False, False, False, Signature(p.at, p.name, [], [], [], p.valueType, noEffect))
            if(self.lspHook.isAt(p.at)) {
                self.lspHook.emit(
                    InferParameterHook(self.unification, environment, p)
                )
            }
            Pair(p.name, scheme)
        }
        let parameterMap = parameters.toMap()
        let environment2 = environment.Environment(symbols = environment.symbols.addAll(parameterMap))
        let parameterTypes = parameters.map {_.second.signature.returnType}
        let functionType = TConstructor(
            definition.at
            "Function$" + parameterTypes.size()
            [definition.signature.effect, ...parameterTypes, definition.signature.returnType]
        )
        let instances = constraintsToInstances(definition.signature.constraints)
        self.unification.withLocalInstances(instances) {
            definition.DFunction(
                body = definition.body.mapFirefly {self.inferLambda(environment2, functionType, _)}
            )
        }
    }

    inferLambda(environment: Environment, expected: Type, lambda: Lambda): Lambda {
        let unitName = core("Unit")
        let returnsUnit = self.unification.substitute(expected).{
            | TConstructor(_, name, ts) {name.startsWith("Function$")} =>
                ts.grabLast().{
                    | TConstructor(_, n, []) => n == unitName
                    | _ => False
                }
            | _ => False
        }
        let cases = if(!returnsUnit) {lambda.cases} else {
            lambda.cases.map {c =>
                c.MatchCase(body = ESequential(c.at, c.body, EVariant(c.at, unitName, [], None)))
            }
        }
        let newEnvironment = environment.Environment(effect = lambda.effect)
        lambda.Lambda(
            cases = cases.map {self.inferMatchCase(newEnvironment, expected, _)}
        )
    }

    inferMatchCase(environment: Environment, expected: Type, case: MatchCase): MatchCase {
        let parameterTypes = case.patterns.map {self.unification.freshUnificationVariable(_.at)}
        let returnType = self.unification.freshUnificationVariable(case.at)
        let functionType = TConstructor(
            case.at
            "Function$" + case.patterns.size()
            [environment.effect, ...parameterTypes, returnType]
        )
        self.unification.unify(case.at, expected, functionType)
        let environment1 = parameterTypes.zip(case.patterns).foldLeft(environment) {| environment1, Pair(t, c) =>
            let symbols = self.inferPattern(environment, t, c).mapValues {name, type =>
                let noEffect = TConstructor(c.at, "ff:core/Nothing.Nothing", [])
                Scheme(True, False, False, False, Signature(c.at, name, [], [], [], type, noEffect))
            }
            environment.Environment(symbols = environment1.symbols.addAll(symbols))
        }
        mutable guards = []
        let environment3 = case.guards.foldLeft(environment1) {environment2, g =>
            let guardType = self.unification.freshUnificationVariable(g.at)
            let guardTerm = self.inferTerm(environment2, guardType, g.term)
            let symbols = self.inferPattern(environment2, guardType, g.pattern).mapValues {name, type =>
                let noEffect = TConstructor(g.at, "ff:core/Nothing.Nothing", [])
                Scheme(True, False, False, False, Signature(g.at, name, [], [], [], type, noEffect))
            }
            guards = [g.MatchGuard(term = guardTerm), ...guards]
            environment2.Environment(symbols = environment2.symbols.addAll(symbols))
        }
        case.MatchCase(
            body = self.inferTerm(environment3, returnType, case.body)
            guards = guards.reverse()
        )
    }

    inferPattern(environment: Environment, expected: Type, pattern: MatchPattern): Map[String, Type] {
        if(self.lspHook.isAt(pattern.at)) {
            self.lspHook.emit(
                InferPatternHook(self.unification, environment, expected, pattern)
            )
        }
        function literal(coreTypeName: String): Map[String, Type] {
            self.unification.unify(pattern.at, expected, TConstructor(pattern.at, core(coreTypeName), []))
            Map.empty()
        }
        pattern.{
            | PString _ =>
                literal("String")
            | PInt _ =>
                literal("Int")
            | PChar _ =>
                literal("Char")
            | PVariable(at, None) =>
                Map.empty()
            | PVariable(at, Some(name)) =>
                [Pair(name, expected)].toMap()
            | PAlias(at, pattern, variable) =>
                self.inferPattern(environment, expected, pattern).add(variable, expected)
            | PVariantAs(at, name, variableOption) =>
                let instantiated = self.lookup(environment, expected, at, name, [], None).else {
                    throw(CompileError(at, "No such variant: " + name))
                }
                if(instantiated.scheme.isNewtype) {
                     throw(CompileError(at, "This kind of pattern is not allowed for newtypes"))
                }
                self.unification.unify(at, expected, instantiated.scheme.signature.returnType)
                let parameters = instantiated.scheme.signature.parameters.sortBy {_.name}
                let recordType =
                    TConstructor(at, "Record$" + parameters.map {_.name}.join("$"), parameters.map {_.valueType})
                variableOption.toList().map {Pair(_, recordType)}.toMap()
            | PVariant(at, name, patterns) =>
                let instantiated = self.lookup(environment, expected, at, name, [], None).else {
                    throw(CompileError(at, "No such variant: " + name))
                }
                self.unification.unify(at, expected, instantiated.scheme.signature.returnType)
                if(patterns.size() != instantiated.scheme.signature.parameters.size() && !self.lspHook.isEnabled()) {
                    throw(CompileError(at, "Wrong number of subpatterns, expected " +
                        instantiated.scheme.signature.parameters.size() + ", got " + patterns.size() + "."
                    ))
                }
                patterns.zip(instantiated.scheme.signature.parameters).map {| Pair(pattern, parameter) =>
                    self.inferPattern(environment, parameter.valueType, pattern)
                }.foldLeft(Map.empty[String, Type]()) {_.addAll(_)}
        }
    }

    inferTerm(environment: Environment, expected: Type, term: Term): Term {
        let hookRecordTypeBox = if(self.lspHook.isAt(term.at)) {
            let box = Box(None)
            self.lspHook.emit(
                InferTermHook(self.unification, environment, expected, term, box, self.missing)
            )
            box
        }
        function literal(coreTypeName: String): Term {
            self.unification.unify(term.at, expected, TConstructor(term.at, core(coreTypeName), []))
            term
        }
        term.{
            | EString _ => literal("String")
            | EChar _ => literal("Char")
            | EInt _ => literal("Int")
            | EFloat _ => literal("Float")
            | EVariable e =>
                self.lookup(environment, expected, e.at, e.name, [], None).map {instantiated =>
                    if(instantiated.scheme.isVariable) {
                        self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                        term
                    } else {
                        self.inferEtaExpansion(
                            environment
                            expected
                            e.at
                            instantiated.scheme.signature
                            term
                        )
                    }
                }.else {
                    throw(CompileError(e.at, "Symbol not in scope: " + e.name))
                }
            | EField e =>
                let recordType = self.unification.freshUnificationVariable(e.at)
                if(self.lspHook.isAt(term.at)) {
                    hookRecordTypeBox.each {_.value = Some(recordType)}
                }
                let record = self.inferTerm(environment, recordType, e.record)
                self.unification.substitute(recordType).{
                    | TConstructor(_, name, typeArguments)@t {name.startsWith("Record$")} =>
                        if(self.lspHook.isAt(e.at)) {
                            let symbolHook = SymbolHook(e.field, e.at, e.at)
                            let noEffect = self.unification.freshUnificationVariable(e.at)
                            self.lspHook.emit(
                                InferRecordFieldHook(self.unification, environment, expected, t, e.field)
                            )
                        }
                        let fieldNames = name.split('$').toList().dropFirst(1)
                        fieldNames.pairs().find {_.second == e.field}.map {_.first}.map {index =>
                            let t1 = typeArguments.grab(index)
                            self.unification.unify(e.at, expected, t1)
                            e.EField(record = record)
                        }.elseIf {self.lspHook.isEnabled()} {
                            term
                        }.else {
                            throw(CompileError(e.at, "No such field " + e.field + " on type: " + t.show([])))
                        }
                    | TConstructor(_, name, typeArguments)@t =>
                        let memberPrefix = name + "_"
                        let memberName = memberPrefix + e.field
                        self.lookup(environment, expected, e.at, memberName, typeArguments, None).{
                            | Some(instantiated) {!instantiated.scheme.isVariable} =>
                                let signature = instantiated.scheme.signature.Signature(
                                    // Drop self for eta expansion
                                    parameters = instantiated.scheme.signature.parameters.dropFirst(1)
                                )
                                self.unification.unify(
                                    e.at
                                    recordType
                                    instantiated.scheme.signature.parameters.grab(0).valueType
                                )
                                self.inferEtaExpansion(environment, expected, e.at, signature, term)
                            | Some(instantiated) =>
                                /*self.unification.unify(
                                    e.at,
                                    recordType,
                                    instantiated.scheme.signature.parameters.grab(0).valueType
                                )*/
                                self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                                e.EField(newtype = instantiated.scheme.isNewtype, record = record)
                            | None =>
                                throw(CompileError(e.at, "No such field " + e.field + " on type: " + t.show([])))
                        }
                    | TVariable(_, _) {self.lspHook.isEnabled()} =>
                        term
                    | TVariable(_, index) =>
                        throw(CompileError(e.at, "No such field " + e.field + " on unknown type: $" + index))
                }
            | EWildcard e =>
                self.lookup(environment, expected, e.at, "_w" + e.index, [], None).map {instantiated =>
                    self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                    term
                }.grab()
            | EList(at, t, items) =>
                let listType = TConstructor(term.at, core("List"), [t])
                self.unification.unify(at, expected, listType)
                EList(at, t, items.map {| Pair(item, spread) =>
                    Pair(self.inferTerm(environment, if(spread) {listType} else {t}, item), spread)
                })
            | ESequential(at, before, after) =>
                if(self.lspHook.isAt(before.at)) {
                    self.lspHook.emit(
                        InferSequentialStartHook(self.unification, term, self.missing)
                    )
                }
                let newExpected = self.unification.freshUnificationVariable(at)
                before.{
                    | EPipe(at1, value, effect1, ELambda(at2, Lambda(at3, effect3, cases))) =>
                        let e = EVariant(at, "ff:core/Unit.Unit", [], None)
                        let newCases = cases.map {case => case.MatchCase(body = ESequential(case.at, case.body, e))}
                        let newPipe = EPipe(at1, value, effect1, ELambda(at2, Lambda(at3, effect3, newCases)))
                        after.{
                            | EVariant(at, "ff:core/Unit.Unit", _, _) =>
                                let unitType = TConstructor(at, core("Unit"), [])
                                self.unification.unify(at, expected, unitType)
                                self.inferTerm(environment, newExpected, newPipe)
                            | _ =>
                                ESequential(
                                    at = at
                                    before = self.inferTerm(environment, newExpected, newPipe)
                                    after = self.inferTerm(environment, expected, after)
                                )
                        }
                    | _ =>
                        ESequential(
                            at = at
                            before = self.inferTerm(environment, newExpected, before)
                            after = self.inferTerm(environment, expected, after)
                        )
                }
            | ELet e =>
                let noEffect = TConstructor(e.at, "ff:core/Nothing.Nothing", [])
                let scheme =
                    Scheme(True, e.mutable, False, False, Signature(e.at, e.name, [], [], [], e.valueType, noEffect))
                let environment2 = environment.Environment(symbols = environment.symbols.add(e.name, scheme))
                e.ELet(
                    value = self.inferTerm(environment, e.valueType, e.value)
                    body = self.inferTerm(environment2, expected, e.body)
                )
            | ELambda(at, l) =>
                l.cases.{
                    | [MatchCase(_, [], [], EVariable(insideAt, ""))] {self.lspHook.isAt(insideAt)} =>
                        self.lspHook.emit(InferLambdaStartHook(self.unification, environment, expected))
                    | [MatchCase(_, [], [],
                        ESequential(_, EVariable(insideAt, ""), EVariant(_, "ff:core/Unit.Unit", _, _))
                    )] {self.lspHook.isAt(insideAt)} =>
                        self.lspHook.emit(InferLambdaStartHook(self.unification, environment, expected))
                    | _ =>
                }
                let lambda = self.inferLambda(environment, expected, l)
                ELambda(at, lambda)
            | EVariant e =>
                let instantiated = self.lookup(environment, expected, e.at, e.name, e.typeArguments, e.arguments).else {
                    throw(CompileError(e.at, "Symbol not in scope: " + e.name))
                }
                self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                let arguments = e.arguments.map {
                    self.inferArguments(e.at, e.name, environment, instantiated.scheme.signature.parameters, _)
                }
                e.EVariant(
                    typeArguments = instantiated.typeArguments.map {_.second}
                    arguments = arguments
                )
            | EVariantIs e =>
                let instantiated = self.lookup(environment, expected, e.at, e.name, e.typeArguments, None).else {
                    throw(CompileError(e.at, "Symbol not in scope: " + e.name))
                }
                let parameters = instantiated.scheme.signature.parameters.sortBy {_.name}
                let recordType =
                    TConstructor(e.at, "Record$" + parameters.map {_.name}.join("$"), parameters.map {_.valueType})
                let functionType = TConstructor(e.at, "Function$1", [
                    self.unification.freshUnificationVariable(e.at)
                    instantiated.scheme.signature.returnType
                    TConstructor(e.at, core("Option"), [recordType])
                ])
                self.unification.unify(e.at, expected, functionType)
                e.EVariantIs(
                    typeArguments = instantiated.typeArguments.map {_.second}
                )
            | ECopy e =>
                let scheme = self.lookup(environment, expected, e.at, e.name, [], None).else {
                    throw(CompileError(e.at, "Symbol not in scope: " + e.name))
                }.scheme
                if(scheme.isNewtype) {
                    throw(CompileError(e.at, "Newtypes can't be copied"))
                }
                let signature = scheme.signature
                if(self.lspHook.isEnabled()) {
                    e.arguments.pairs().each {| Pair(i, a) =>
                        if(self.lspHook.isAt(a.at)) {
                            let arguments = e.arguments.map {f => f.Argument(name = Some(f.name))}
                            self.lspHook.emit(
                                InferArgumentHook(
                                    self.unification, environment
                                    True, term.at, e.name, signature.parameters, arguments, i
                                )
                            )
                        }
                    }
                }
                let parameterNames = signature.parameters.map {_.name}
                e.arguments.find {a => !parameterNames.any {_ == a.name}}.each {
                    | Field(at, name, value) => throw(CompileError(at, "Unknown parameter: " + name))
                }
                let arguments = parameterNames.map {name =>
                    e.arguments.find {_.name == name}.map {
                        | Field(at, _, value) => Argument(at, Some(name), value)
                    }.else {
                        Argument(e.at, Some(name), EField(e.at, False, EVariable(e.at, "_c"), name))
                    }
                }
                let body = EVariant(e.at, e.name, [], Some(arguments))
                let effect = self.unification.freshUnificationVariable(e.at)
                let e1 = EPipe(e.at, e.record, effect
                    ELambda(e.at, Lambda(e.at, effect, [MatchCase(e.at, [PVariable(e.at, Some("_c"))], [], body)]))
                )
                self.inferTerm(environment, expected, e1)
            | EPipe e =>
                let valueType = self.unification.freshUnificationVariable(e.at)
                let functionType = TConstructor(e.at, "Function$1", [
                    e.effect
                    valueType
                    expected
                ])
                let value = self.inferTerm(environment, valueType, e.value)
                let function = self.inferTerm(environment, functionType, e.function)
                self.unification.affect(term.at, e.effect, environment.effect)
                e.EPipe(
                    value = value
                    function = function
                )
            | ECall e =>
                if((self.lspHook.isEnabled()) && e.target.{| StaticCall _ => True | _ => False}) {term} else:
                let call = e.target.{
                    | DynamicCall call => call
                    | StaticCall _ => fail(e.at, "Internal error: Static calls not expected in the Inference phase")
                }
                call.function.{
                    | EVariable(variableAt, x) =>
                        if(x.first().any {c => c != '_' && !c.isAsciiLetter()}) {
                            self.inferOperator(environment, expected, x, term)
                        } else {
                            self.lookup(environment, expected, e.at, x, e.typeArguments, Some(e.arguments)).{
                                | Some(instantiated) =>
                                    if(instantiated.scheme.isVariable) {
                                        self.inferLambdaCall(environment, expected, term)
                                    } else {
                                        let signature = instantiated.scheme.signature
                                        self.inferFunctionCall(
                                            environment
                                            expected
                                            signature
                                            instantiated.scheme.isTraitMethod
                                            instantiated.typeArguments
                                            term
                                            x
                                        )
                                    }
                                | None =>
                                    throw(CompileError(variableAt, "No such function: " + x))
                            }
                        }
                    | EField f =>
                        let recordType = self.unification.freshUnificationVariable(f.at)
                        if(self.lspHook.isAt(term.at)) {
                            hookRecordTypeBox.each {_.value = Some(recordType)}
                        }
                        let record = self.inferTerm(environment, recordType, f.record)
                        let e2 = e.ECall(target = call.DynamicCall(function = f.EField(record = record)))
                        self.unification.substitute(recordType).{
                            | TConstructor(_, name, _)@t =>
                                let methodName = name + "_" + f.field
                                self.lookup(environment, expected, f.at, methodName, [], None).{
                                    | Some(instantiated) {!instantiated.scheme.isVariable} =>
                                        self.inferMethodCall(
                                            environment
                                            expected
                                            instantiated.scheme.signature
                                            instantiated.typeArguments
                                            e2
                                            record
                                            recordType
                                            methodName
                                        )
                                    | Some(instantiated) =>
                                        self.inferLambdaCall(environment, expected, e2)
                                    | None =>
                                        throw(CompileError(f.at
                                            "No such field " + f.field + " on type: " + t.show([])
                                        ))
                                }
                            | TVariable _ {self.lspHook.isEnabled()} =>
                                self.inferLambdaCall(environment, expected, e2)
                            | TVariable(_, index) =>
                                throw(CompileError(f.at
                                    "No such field " + f.field + " on unknown type: $" + index
                                ))
                        }
                    | _ =>
                        self.inferLambdaCall(environment, expected, term)
                }
            | ERecord e =>
                let fields = e.fields.sortBy {_.name}
                let fieldTypes = fields.map {self.unification.freshUnificationVariable(_.at)}
                let recordType =
                    TConstructor(e.at, "Record$" + fields.map {_.name}.join("$"), fieldTypes)
                self.unification.unify(e.at, expected, recordType)
                let newFields = fields.zip(fieldTypes).map {| Pair(field, t) =>
                    field.Field(value = self.inferTerm(environment, t, field.value))
                }
                e.ERecord(
                    fields = newFields
                )
            | EFunctions(at, functions, body) =>
                let functionMap = functions.map {f =>
                    let scheme = Scheme(False, False, False, False, f.signature)
                    Pair(f.signature.name, scheme)
                }.toMap()
                let environment2 = environment.Environment(symbols = environment.symbols.addAll(functionMap))
                let newFunctions = functions.map {self.inferFunctionDefinition(environment2, _)}
                let newBody = self.inferTerm(environment2, expected, body)
                EFunctions(
                    at = at
                    functions = newFunctions
                    body = newBody
                )
            | EAssign e =>
                self.lookup(environment, expected, e.at, e.variable, [], None).map {instantiated =>
                    if(instantiated.scheme.isMutable) {
                        let value = self.inferAssignment(
                            environment = environment
                            expected = expected
                            at = e.at
                            operator = e.operator
                            value = e.value
                            signature = instantiated.scheme.signature
                        )
                        e.EAssign(
                            value = value
                        )
                    } elseIf {self.lspHook.isEnabled()} {
                        term
                    } else {
                        throw(CompileError(e.at, "Symbol is not mutable: " + e.variable))
                    }
                } else {
                    throw(CompileError(e.at, "Symbol not in scope: " + e.variable))
                }
            | EAssignField e =>
                let recordType = self.unification.freshUnificationVariable(e.at)
                let record = self.inferTerm(environment, recordType, e.record)
                self.unification.substitute(recordType).{
                    | TConstructor(_, name, typeArguments)@t {name.startsWith("Record$")} =>
                        throw(CompileError(e.at, "Can't assign fields of anonymous records: " + e.field))
                    | TConstructor(_, name, typeArguments)@t =>
                        let methodName = name + "_" + e.field
                        self.lookup(environment, expected, e.at, methodName, typeArguments, None).{
                            | Some(instantiated) {instantiated.scheme.isMutable} =>
                                let value = self.inferAssignment(
                                    environment = environment
                                    expected = expected
                                    at = e.at
                                    operator = e.operator
                                    value = e.value
                                    signature = instantiated.scheme.signature
                                )
                                e.EAssignField(
                                    record = record
                                    value = value
                                )
                            | Some(instantiated) =>
                                throw(CompileError(e.at
                                    "Can't assign an immutable field " + e.field + " on type: " + t.show([])
                                ))
                            | None =>
                                throw(CompileError(e.at, "No such field " + e.field + " on type: " + t.show([])))
                        }
                    | TVariable(_, _) {self.lspHook.isEnabled()} =>
                        term
                    | TVariable(_, index) =>
                        throw(CompileError(e.at, "No such field " + e.field + " on unknown type: $" + index))
                }
        }
    }

    inferAssignment(
        environment: Environment
        expected: Type
        at: Location
        operator: String
        value: Term
        signature: Signature
    ): Term {
        let t = signature.returnType
        if(operator == "+" || operator == "-") {
            self.unification.unify(at, t, TConstructor(at, core("Int"), []))
        } elseIf {operator != ""} {
            throw(CompileError(at, "Only +=, -= and = assignments are supported. Got: " + operator + "="))
        }
        let newValue = self.inferTerm(environment, t, value)
        self.unification.unify(at, expected, TConstructor(at, core("Unit"), []))
        newValue
    }

    inferMethodCall(
        environment: Environment
        expected: Type
        signature: Signature
        instantiation: List[Pair[String, Type]]
        term: Term
        record: Term
        recordType: Type
        name: String
    ): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected")}
        let call = e.target.{
            | DynamicCall call => call
            | StaticCall _ => fail(e.at, "Internal error: Static calls not expected in inferMethodCall")
        }
        let selfParameter = signature.parameters.grabFirst()
        let selfArgument = Argument(record.at, Some(selfParameter.name), record) // Be careful not to infer again
        self.unification.unify(term.at, expected, signature.returnType)
        self.unification.unify(term.at, selfParameter.valueType, recordType)
        let arguments = self.inferArguments(term.at, name, environment, signature.parameters.dropFirst(), e.arguments)
        self.unification.affect(term.at, signature.effect, environment.effect)
        e.ECall(
            target = StaticCall(name, instanceCall = False, tailCall = call.tailCall)
            typeArguments = instantiation.map {_.second}
            arguments = [selfArgument, ...arguments]
            effect = signature.effect
        )
    }

    inferFunctionCall(
        environment: Environment
        expected: Type
        signature: Signature
        instanceCall: Bool
        instantiation: List[Pair[String, Type]]
        term: Term
        name: String
    ): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected")}
        let call = e.target.{
            | DynamicCall call => call
            | StaticCall _ => fail(e.at, "Internal error: Static calls not expected in inferFunctionCall")
        }
        self.unification.unify(e.at, expected, signature.returnType)
        let arguments = self.inferArguments(e.at, name, environment, signature.parameters, e.arguments)
        self.unification.affect(term.at, signature.effect, environment.effect)
        e.ECall(
            target = StaticCall(name, instanceCall = instanceCall, tailCall = call.tailCall)
            typeArguments = instantiation.map {_.second}
            arguments = arguments
            effect = signature.effect
        )
    }

    inferLambdaCall(environment: Environment, expected: Type, term: Term): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected")}
        let call = e.target.{
            | DynamicCall call {!call.tailCall} => call
            | DynamicCall _ => throw(CompileError(e.at, "Tailcalls not supported on lambda functions"))
            | StaticCall _ => fail(e.at, "Internal error: Static calls not expected in inferLambdaCall")
        }
        let effect = self.unification.freshUnificationVariable(term.at)
        let argumentTypes = e.arguments.map {self.unification.freshUnificationVariable(_.at)}
        let functionType = TConstructor(e.at, "Function$" + e.arguments.size(), [
            effect
            ...argumentTypes
            expected
        ])
        let function = self.inferTerm(environment, functionType, call.function)
        let arguments = e.arguments.zip(argumentTypes).map {| Pair(argument, t) =>
            argument.name.each {name =>
                throw(CompileError(argument.at, "Named argument not allowed here: " + name))
            }
            argument.Argument(value = self.inferTerm(environment, t, argument.value))
        }
        e.typeArguments.first().each {typeArgument =>
            throw(CompileError(typeArgument.at, "Type arguments not allowed here"))
        }
        self.unification.affect(term.at, effect, environment.effect)
        e.ECall(
            target = call.DynamicCall(function = function)
            typeArguments = []
            arguments = arguments
            effect = effect
        )
    }

    inferOperator(environment: Environment, expected: Type, operator: String, term: Term): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected") }
        let target = StaticCall(operator, instanceCall = False, tailCall = False)
        e.arguments.{
            | [a1] {
                operator == "!"
            } =>
                let t = TConstructor(e.at, core("Bool"), [])
                let e1 = self.inferTerm(environment, t, a1.value)
                self.unification.unify(e.at, expected, t)
                e.ECall(target = target, arguments = [a1.Argument(value = e1)])
            | [a1] {
                operator == "-"
            } =>
                let t1 = self.unification.freshUnificationVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                self.unification.substitute(t1).{
                    | TConstructor(_, name, []) {name == core("Float")} =>
                        self.unification.unify(e.at, expected, t1)
                    | TConstructor(_, name, []) {name == core("Int")} =>
                        self.unification.unify(e.at, expected, t1)
                    | _ {self.lspHook.isEnabled()} =>
                    | _ =>
                        throw(CompileError(e.at, "Operators on unknown types not currently supported"))
                }
                e.ECall(target = target, arguments = [a1.Argument(value = e1)])
            | [a1, a2] {
                operator == "||" || operator == "&&"
            } =>
                let t = TConstructor(e.at, core("Bool"), [])
                let e1 = self.inferTerm(environment, t, a1.value)
                let e2 = self.inferTerm(environment, t, a2.value)
                self.unification.unify(e.at, expected, t)
                e.ECall(target = target, arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | [a1, a2] {
                operator == "===" || operator == "!==" // For internal use
            } =>
                let t1 = self.unification.freshUnificationVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                let e2 = self.inferTerm(environment, t1, a2.value)
                self.unification.unify(e.at, expected, TConstructor(e.at, core("Bool"), []))
                e.ECall(target = target, arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | [a1, a2] {
                operator == "+" || operator == "-" ||
                operator == "*" || operator == "/" || operator == "%" ||
                operator == "^"
            } =>
                let t1 = self.unification.freshUnificationVariable(e.at)
                let t2 = self.unification.freshUnificationVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                let e2 = self.inferTerm(environment, t2, a2.value)
                let magic: Type => Option[String] = {t =>
                    self.unification.substitute(t).{
                        | TConstructor(_, name, []) {name == core("Float")} => Some("Float")
                        | TConstructor(_, name, []) {name == core("Int")} => Some("Int")
                        | TConstructor(_, name, []) {operator == "+" && name == core("String")} => Some("String")
                        | _ => None
                    }
                }
                let chooseType: (Option[String], Option[String]) => Unit = {
                    | Some("String"), Some(_) => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some("String") => self.unification.unify(e.at, expected, t2)
                    | Some("Float"), Some(_) => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some("Float") => self.unification.unify(e.at, expected, t2)
                    | Some("Int"), Some(_) => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some("Int") => self.unification.unify(e.at, expected, t2)
                    | Some(_), None =>
                        self.unification.unify(e.at, t1, t2)
                        self.unification.unify(e.at, expected, t1)
                    | None, Some(_) =>
                        self.unification.unify(e.at, t2, t1)
                        self.unification.unify(e.at, expected, t2)
                    | _, _ {self.lspHook.isEnabled()} =>
                    | Some(_), Some(_) =>
                        throw(CompileError(e.at, "Operators on these types not currently supported"))
                    | None, None =>
                        throw(CompileError(e.at, "Operators on unknown types not currently supported"))
                }
                chooseType(magic(t1), magic(t2))
                e.ECall(target = target, arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | _ {self.lspHook.isEnabled()} =>
                term
            | _ =>
                fail(e.at, "Unknown operator: " + operator)
        }
    }

    inferEtaExpansion(
        environment: Environment
        expected: Type
        at: Location
        signature: Signature
        term: Term
    ): Term {
        let parameters = signature.parameters.filter {_.default.isEmpty()}.map {p =>
            p.name
        }
        let effect1 = self.unification.freshUnificationVariable(at)
        let body = ECall(at, DynamicCall(term, False), effect1, [], parameters.map {x =>
            Argument(at, Some(x), EVariable(at, x))
        }, [])
        let effect2 = self.unification.freshUnificationVariable(at)
        let lambda = ELambda(at, Lambda(at, effect2, [MatchCase(
            at = at
            patterns = parameters.map {PVariable(at, Some(_))}
            guards = []
            body = body
        )]))
        self.inferTerm(environment.Environment(effect = effect2), expected, lambda)
    }

    inferArguments(
        callAt: Location
        callName: String
        environment: Environment
        parameters: List[Parameter]
        arguments: List[Argument]
    ): List[Argument] {
        if(self.lspHook.isEnabled()) {
            arguments.pairs().each {| Pair(i, a) =>
                if(self.lspHook.isAt(a.at)) {
                    self.lspHook.emit(
                        InferArgumentHook(
                            self.unification, environment
                            False, callAt, callName, parameters, arguments, i
                        )
                    )
                }
            }
        }
        mutable remainingArguments = arguments
        let newArguments = parameters.map {p =>
            let t = p.valueType
            function defaultArgument(): Argument {
                p.default.map {e =>
                    let e2 = self.inferTerm(environment, t, e)
                    Argument(callAt, Some(p.name), e2)
                }.else {
                    if(!self.lspHook.isEnabled()) {
                        fail(callAt, "Missing argument: " + p.name)
                    } else {
                        Argument(callAt, Some(p.name), EVariable(callAt, ""))
                    }
                }
            }
            remainingArguments.{
                | [] =>
                    defaultArgument()
                | [Argument(at, None, e), ...remaining] =>
                    remainingArguments = remaining
                    let e2 = self.inferTerm(environment, t, e)
                    Argument(at, Some(p.name), e2)
                | _ =>
                    remainingArguments.find {_.name.contains(p.name)}.map {| Argument(at, _, e) =>
                        remainingArguments = remainingArguments.filter {!_.name.contains(p.name)}
                        let e2 = self.inferTerm(environment, t, e)
                        Argument(at, Some(p.name), e2)
                    }.else {
                        defaultArgument()
                    }
            }
        }
        if(!self.lspHook.isEnabled()) {
            remainingArguments.first().each {
                | Argument(callAt, None, _) => fail(callAt, "Too many arguments")
                | Argument(callAt, Some(n), _) => fail(callAt, "Unknown argument: " + n)
            }
        }
        newArguments
    }

    lookup(
        environment: Environment
        expected: Type
        at: Location
        symbol: String
        typeArguments: List[Type]
        arguments: Option[List[Argument]]
    ): Option[Instantiated] {
        self.lookupOption(environment, expected, at, symbol, typeArguments).elseIf {self.lspHook.isEnabled()} {
            let instantiated = Instantiated([], Scheme(arguments.isEmpty(), False, False, False, Signature(
                at = at
                name = symbol
                generics = []
                constraints = []
                parameters = arguments.toList().flatten().pairs().map {| Pair(i, a) =>
                    let t = self.unification.freshUnificationVariable(at)
                    Parameter(a.at, False, a.name.else {"_p" + i}, t, None)
                }
                returnType = self.unification.freshUnificationVariable(at)
                effect = self.unification.freshUnificationVariable(at)
            )))
            if(!self.lspHook.isAt(at) && !self.missing.has(symbol)) {
                self.missing.set(symbol, Pair(instantiated, arguments))
            }
            instantiated
        }
    }

    lookupOption(environment: Environment, expected: Type, at: Location, symbol: String, typeArguments: List[Type]): Option[Instantiated] {

        let hook = if(self.lspHook.isAt(at)) {
            let symbolHook = SymbolHook(symbol, at, at)
            let h = InferLookupHook(self.unification, environment, expected, Box(symbolHook), Box(None))
            self.lspHook.emit(h)
            h
        }

        environment.symbols.get(symbol).map: scheme =>

        let instantiation =
            if(!typeArguments.isEmpty()) {
                let newTypeArguments = if(!scheme.isVariable && scheme.signature.generics.first().any {_ == "Q$"}) {
                    [self.unification.freshUnificationVariable(at), ...typeArguments]
                } else {
                    typeArguments
                }
                if(scheme.signature.generics.size() != newTypeArguments.size() && !self.lspHook.isEnabled()) {
                    let extra = newTypeArguments.size() - typeArguments.size()
                    throw(CompileError(at
                        "Wrong number of type arguments for " + symbol +
                        ", expected " + (scheme.signature.generics.size() - extra) +
                        ", got " + (newTypeArguments.size() - extra)
                    ))
                }
                scheme.signature.generics.zip(newTypeArguments)
            } else {
                scheme.signature.generics.map {name =>
                    Pair(name, self.unification.freshUnificationVariable(at))
                }
            }

        let instantiationMap = instantiation.toMap()
        let parameters = scheme.signature.parameters.map {p =>
            p.Parameter(valueType = self.unification.instantiate(instantiationMap, p.valueType))
        }
        let returnType = self.unification.instantiate(instantiationMap, scheme.signature.returnType)
        let effect = self.unification.instantiate(instantiationMap, scheme.signature.effect)

        scheme.signature.constraints.each {c =>
            let generics = c.generics.map {self.unification.instantiate(instantiationMap, _)}
            self.unification.constrain(at, generics.grabFirst(), c.name, generics.dropFirst())
        }

        let signature = scheme.signature.Signature(
            generics = []
            constraints = []
            parameters = parameters
            returnType = returnType
            effect = effect
        )

        let instantiated = Instantiated(
            typeArguments = instantiation
            scheme = scheme.Scheme(signature = signature)
        )

        if(self.lspHook.isAt(at) || self.lspHook.isDefinedAt(scheme.signature.at)) {
            let symbolHook = SymbolHook(symbol, at, scheme.signature.at)
            let emittedHook = hook.else {
                let h = InferLookupHook(self.unification, environment, expected, Box(symbolHook), Box(None))
                self.lspHook.emit(h)
                h
            }.{
                | InferLookupHook h =>
                    h.symbol.value = symbolHook
                    h.instantiated.value = Some(instantiated)
                | _ =>
            }
        }

        instantiated

    }

}

constraintsToInstances(constraints: List[Constraint]): Map[InstanceKey, InstanceValue] {
    constraints.map {c =>
        let typeName = c.generics.grabFirst().{
            | TConstructor(_, name, _) => name
            | TVariable(at, i) => fail(c.at, "Unexpected unification variable: $" + i)
        }
        Pair(
            InstanceKey(c.name, typeName)
            InstanceValue(
                generics = []
                constraints = []
                packagePair = PackagePair("", "")
                moduleName = ""
                traitName = c.name
                typeArguments = c.generics
            )
        )
    }.toMap()
}
