import Syntax
import Unification
import Environment
import Substitution

class Inference(
    unification: Unification
    hoverAt: Option[Location]
    completionAt: Option[Location]
    mutable hoverResult: HoverInfo
    mutable completionResult: List[CompletionInfo]
)

make(modules: List[Module], hoverAt: Option[Location], completionAt: Option[Location]): Inference {
    Inference(
        unification = Unification.make(modules, !completionAt.isEmpty())
        hoverAt = hoverAt
        completionAt = completionAt
        hoverResult = HoverInfo(None, None, None)
        completionResult = []
    )
}

fail[T](at: Location, message: String): T {
    throw(CompileError(at, message))
}

core(name: String): String {
    "ff:core/" + name + "." + name
}

extend self: Inference {

    inferModule(module: Module, otherModules: List[Module]): Module {
        let environment = Environment.make(module, otherModules, alreadyFlat = False)

        let lets = module.lets.map {self.inferLetDefinition(environment, _)}
        let functions = module.functions.map {self.inferFunctionDefinition(environment, _)}
        let extends = module.extends.map {self.inferExtendDefinition(environment, _)}
        let traits = module.traits.map {self.inferTraitDefinition(environment, _)}
        let instances = module.instances.map {self.inferInstanceDefinition(environment, _)}
        let result = module.Module(
            traits = traits
            instances = instances
            extends = extends
            lets = lets
            functions = functions
        )
        let subsititution = Substitution(self.unification.substitution)
        self.hoverResult = self.hoverResult.HoverInfo(
            type = self.hoverResult.type.map {subsititution.substituteType(_)}
            effect = self.hoverResult.effect.map {subsititution.substituteType(_)}
        )
        self.completionResult = self.completionResult.map {r => 
            r.CompletionInfo(
                type = subsititution.substituteType(r.type)
                expectedType = r.expectedType.map {subsititution.substituteType(_)}
            )
        }.distinct()
        subsititution.substituteModule(result)
    }

    inferTraitDefinition(environment: Environment, definition: DTrait): DTrait {
        definition.DTrait(

        )
    }

    inferInstanceDefinition(environment: Environment, definition: DInstance): DInstance {
        let instances = constraintsToInstances(definition.constraints)
        self.unification.withLocalInstances(instances) {
            definition.DInstance(
                // TODO: Check that the methods adhere to the instantiated trait method signatures
                // It needs to look at the instantiated trait, e.g. `trait T: Show` and `instance Foo: Show`
                // gives an instantiation `T = Foo`, which should be applied to all the methods before checking.
                methods = definition.methods.map {instanceFunction =>
                    let methodName = instanceFunction.signature.name
                    let traitName = definition.traitName
                    let traitMethodName = traitName.reverse().dropWhile {_ != '.'}.reverse() + methodName
                    let traitMethod = environment.symbols.get(traitMethodName).else {
                        throw(CompileError(instanceFunction.at
                            "Trait " + traitName + " has no such method: " + methodName
                        ))
                    }
                    let newInstanceFunction = self.inferFunctionDefinition(environment, instanceFunction)
                    newInstanceFunction
                }
            )
        }
    }

    inferLetDefinition(environment: Environment, definition: DLet): DLet {
        let value = self.inferTerm(environment, definition.variableType, definition.value)
        definition.DLet(
            value = value
        )
    }

    inferExtendDefinition(environment: Environment, definition: DExtend): DExtend {
        let selfParameter = Parameter(
            at = definition.at
            mutable = False
            name = definition.name
            valueType = definition.type
            default = None
        )
        let functions = definition.methods.map {method =>
            let signature = method.signature.Signature(
                generics = [...definition.generics, ...method.signature.generics]
                constraints = [...definition.constraints, ...method.signature.constraints]
                parameters = [selfParameter, ...method.signature.parameters]
            )
            let body = method.body.mapFirefly {lambda =>
                lambda.Lambda(
                    cases = lambda.cases.map {case =>
                        case.MatchCase(
                            patterns = [PVariable(method.at, None), ...case.patterns]
                        )
                    }
                )
            }
            let function = method.DFunction(
                signature = signature
                body = body
            )
            self.inferFunctionDefinition(environment, function)
        }
        definition.DExtend(
            methods = functions
        )
    }

    inferFunctionDefinition(environment: Environment, definition: DFunction): DFunction {
        let parameters = definition.signature.parameters.map {p =>
            let noEffect = TConstructor(p.at, "ff:core/Nothing.Nothing", [])
            let scheme = Scheme(True, False, False, False, Signature(p.at, p.name, [], [], [], p.valueType, noEffect))
            if(self.hoverAt.contains(p.at) && self.hoverResult.at.isEmpty()) {
                self.hoverResult = self.hoverResult.HoverInfo(
                    at = Some(p.at)
                    type = Some(p.valueType)
                )
            }
            Pair(p.name, scheme)
        }
        let parameterMap = parameters.toMap()
        let environment2 = environment.Environment(symbols = environment.symbols.addAll(parameterMap))
        let parameterTypes = parameters.map {_.second.signature.returnType}
        let functionType = TConstructor(
            definition.at
            "Function$" + parameterTypes.size()
            [definition.signature.effect, ...parameterTypes, definition.signature.returnType]
        )
        let instances = constraintsToInstances(definition.signature.constraints)
        self.unification.withLocalInstances(instances) {
            definition.DFunction(
                body = definition.body.mapFirefly {self.inferLambda(environment2, functionType, _)}
            )
        }
    }

    inferLambda(environment: Environment, expected: Type, lambda: Lambda): Lambda {
        let unitName = core("Unit")
        let returnsUnit = self.unification.substitute(expected).{
            | TConstructor(_, name, ts) {name.startsWith("Function$")} =>
                ts.grabLast().{
                    | TConstructor(_, n, []) => n == unitName
                    | _ => False
                }
            | _ => False
        }
        let cases = if(!returnsUnit) {lambda.cases} else {
            lambda.cases.map {c =>
                c.MatchCase(body = ESequential(c.at, c.body, EVariant(c.at, unitName, [], None)))
            }
        }
        let newEnvironment = environment.Environment(effect = lambda.effect)
        lambda.Lambda(
            cases = cases.map {self.inferMatchCase(newEnvironment, expected, _)}
        )
    }

    inferMatchCase(environment: Environment, expected: Type, case: MatchCase): MatchCase {
        let parameterTypes = case.patterns.map {self.unification.freshUnificationVariable(_.at)}
        let returnType = self.unification.freshUnificationVariable(case.at)
        let functionType = TConstructor(
            case.at
            "Function$" + case.patterns.size()
            [environment.effect, ...parameterTypes, returnType]
        )
        self.unification.unify(case.at, expected, functionType)
        let environment1 = parameterTypes.zip(case.patterns).foldLeft(environment) {| environment1, Pair(t, c) =>
            let symbols = self.inferPattern(environment, t, c).mapValues {name, type =>
                let noEffect = TConstructor(c.at, "ff:core/Nothing.Nothing", [])
                Scheme(True, False, False, False, Signature(c.at, name, [], [], [], type, noEffect))
            }
            environment.Environment(symbols = environment1.symbols.addAll(symbols))
        }
        mutable guards = []
        let environment3 = case.guards.foldLeft(environment1) {environment2, g =>
            let guardType = self.unification.freshUnificationVariable(g.at)
            let guardTerm = self.inferTerm(environment2, guardType, g.term)
            let symbols = self.inferPattern(environment2, guardType, g.pattern).mapValues {name, type =>
                let noEffect = TConstructor(g.at, "ff:core/Nothing.Nothing", [])
                Scheme(True, False, False, False, Signature(g.at, name, [], [], [], type, noEffect))
            }
            guards = [g.MatchGuard(term = guardTerm), ...guards]
            environment2.Environment(symbols = environment2.symbols.addAll(symbols))
        }
        case.MatchCase(
            body = self.inferTerm(environment3, returnType, case.body)
            guards = guards.reverse()
        )
    }

    inferPattern(environment: Environment, expected: Type, pattern: MatchPattern): Map[String, Type] {
        function literal(coreTypeName: String): Map[String, Type] {
            self.unification.unify(pattern.at, expected, TConstructor(pattern.at, core(coreTypeName), []))
            Map.empty()
        }
        pattern.{
            | PString _ =>
                literal("String")
            | PInt _ =>
                literal("Int")
            | PChar _ =>
                literal("Char")
            | PVariable(at, None) =>
                if(self.completionAt.contains(at)) {self.patternCompletion(environment, expected)}
                if(self.hoverAt.contains(at) && self.hoverResult.at.isEmpty()) {
                    self.hoverResult = self.hoverResult.HoverInfo(
                        at = Some(at)
                        type = Some(expected)
                    )
                }
                Map.empty()
            | PVariable(at, Some(name)) =>
                if(self.completionAt.contains(at)) {self.patternCompletion(environment, expected)}
                if(self.hoverAt.contains(at) && self.hoverResult.at.isEmpty()) {
                    self.hoverResult = self.hoverResult.HoverInfo(
                        at = Some(at)
                        type = Some(expected)
                    )
                }
                [Pair(name, expected)].toMap()
            | PAlias(at, pattern, variable) =>
                if(self.hoverAt.contains(at) && self.hoverResult.at.isEmpty()) {
                    self.hoverResult = self.hoverResult.HoverInfo(
                        at = Some(at)
                        type = Some(expected)
                    )
                }
                self.inferPattern(environment, expected, pattern).add(variable, expected)
            | PVariantAs(at, name, variableOption) =>
                if(self.completionAt.contains(at)) {self.patternCompletion(environment, expected)}
                let instantiated = self.lookup(environment, at, name, []).else {
                    throw(CompileError(at, "No such variant: " + name))
                }
                if(instantiated.scheme.isNewtype) {
                     throw(CompileError(at, "This kind of pattern is not allowed for newtypes"))
                }
                self.unification.unify(at, expected, instantiated.scheme.signature.returnType)
                let parameters = instantiated.scheme.signature.parameters.sortBy {_.name}
                let recordType =
                    TConstructor(at, "Record$" + parameters.map {_.name}.join("$"), parameters.map {_.valueType})
                if(self.hoverAt.contains(at)) {
                    self.hoverResult = self.hoverResult.HoverInfo(type = Some(expected))
                }
                variableOption.toList().map {Pair(_, recordType)}.toMap()
            | PVariant(at, name, patterns) =>
                if(self.completionAt.contains(at)) {self.patternCompletion(environment, expected)}
                let instantiated = self.lookup(environment, at, name, []).else {
                    throw(CompileError(at, "No such variant: " + name))
                }
                self.unification.unify(at, expected, instantiated.scheme.signature.returnType)
                if(patterns.size() != instantiated.scheme.signature.parameters.size() && self.completionAt.isEmpty()) {
                    throw(CompileError(at, "Wrong number of subpatterns, expected " +
                        instantiated.scheme.signature.parameters.size() + ", got " + patterns.size() + "."
                    ))
                }
                patterns.zip(instantiated.scheme.signature.parameters).map {| Pair(pattern, parameter) =>
                    self.inferPattern(environment, parameter.valueType, pattern)
                }.foldLeft(Map.empty[String, Type]()) {_.addAll(_)}
        }
    }

    inferTerm(environment: Environment, expected: Type, term: Term): Term {
        function literal(coreTypeName: String): Term {
            if(self.completionAt.contains(term.at)) {self.completion(environment, "", False, expected)}
            self.unification.unify(term.at, expected, TConstructor(term.at, core(coreTypeName), []))
            term
        }
        term.{
            | EString _ => literal("String")
            | EChar _ => literal("Char")
            | EInt _ => literal("Int")
            | EFloat _ => literal("Float")
            | EVariable e =>
                if(self.completionAt.contains(e.at)) {self.completion(environment, "", False, expected)}
                self.lookup(environment, e.at, e.name, []).map {instantiated =>
                    if(instantiated.scheme.isVariable) {
                        self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                        term
                    } else {
                        self.inferEtaExpansion(
                            environment
                            expected
                            e.at
                            instantiated.scheme.signature
                            term
                        )
                    }
                }.else {
                    throw(CompileError(e.at, "Symbol not in scope: " + e.name))
                }
            | EField e =>
                let recordType = self.unification.freshUnificationVariable(e.at)
                let record = self.inferTerm(environment, recordType, e.record)
                self.unification.substitute(recordType).{
                    | TConstructor(_, name, typeArguments)@t {name.startsWith("Record$")} =>
                        let fieldNames = name.split('$').toList().dropFirst(1)
                        if(self.completionAt.contains(e.at)) {
                            self.completionResult = fieldNames.zip(typeArguments).map {
                                | Pair(fieldName, typeArgument) => 
                                    CompletionInfo(fieldName, fieldName, True, typeArgument, "", Some(expected))
                            }
                            self.completion(environment, name, True, expected)
                        }
                        fieldNames.pairs().find {_.second == e.field}.map {_.first}.map {index =>
                            let t1 = typeArguments.grab(index)
                            self.unification.unify(e.at, expected, t1)
                            if(self.hoverAt.contains(e.at) && self.hoverResult.type.isEmpty()) {
                                self.hoverResult = self.hoverResult.HoverInfo(
                                    at = Some(e.at) // TODO: If from a pattern match, use location of true field
                                    type = Some(t1)
                                    effect = None
                                )
                            }
                            e.EField(record = record)
                        }.elseIf {!self.completionAt.isEmpty()} {
                            term
                        }.else {
                            throw(CompileError(e.at, "No such field " + e.field + " on type: " + t.show([])))
                        }
                    | TConstructor(_, name, typeArguments)@t =>
                        let memberPrefix = name + "_"
                        if(self.completionAt.contains(e.at)) {
                            self.completion(environment, memberPrefix, True, expected)
                        }
                        let memberName = memberPrefix + e.field
                        self.lookup(environment, e.at, memberName, typeArguments).{
                            | Some(instantiated) {!instantiated.scheme.isVariable} =>
                                let signature = instantiated.scheme.signature.Signature(
                                    // Drop self for eta expansion
                                    parameters = instantiated.scheme.signature.parameters.dropFirst(1)
                                )
                                self.unification.unify(
                                    e.at
                                    recordType
                                    instantiated.scheme.signature.parameters.grab(0).valueType
                                )
                                self.inferEtaExpansion(environment, expected, e.at, signature, term)
                            | Some(instantiated) =>
                                /*self.unification.unify(
                                    e.at,
                                    recordType,
                                    instantiated.scheme.signature.parameters.grab(0).valueType
                                )*/
                                self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                                e.EField(newtype = instantiated.scheme.isNewtype, record = record)
                            | None =>
                                throw(CompileError(e.at, "No such field " + e.field + " on type: " + t.show([])))
                        }
                    | TVariable(_, _) {!self.completionAt.isEmpty()} =>
                        term
                    | TVariable(_, index) =>
                        throw(CompileError(e.at, "No such field " + e.field + " on unknown type: $" + index))
                }
            | EWildcard e =>
                if(self.completionAt.contains(term.at)) {self.completion(environment, "", False, expected)}
                self.lookup(environment, e.at, "_w" + e.index, []).map {instantiated =>
                    self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                    term
                }.grab()
            | EList(at, t, items) =>
                let listType = TConstructor(term.at, core("List"), [t])
                self.unification.unify(at, expected, listType)
                EList(at, t, items.map {| Pair(item, spread) =>
                    Pair(self.inferTerm(environment, if(spread) {listType} else {t}, item), spread)
                })
            | ESequential(at, before, after) =>
                let newExpected = self.unification.freshUnificationVariable(at)
                before.{
                    | EPipe(at1, value, effect1, ELambda(at2, Lambda(at3, effect3, cases))) =>
                        let e = EVariant(at, "ff:core/Unit.Unit", [], None)
                        let newCases = cases.map {case => case.MatchCase(body = ESequential(case.at, case.body, e))}
                        let newPipe = EPipe(at1, value, effect1, ELambda(at2, Lambda(at3, effect3, newCases)))
                        after.{
                            | EVariant(at, "ff:core/Unit.Unit", _, _) =>
                                let unitType = TConstructor(at, core("Unit"), [])
                                self.unification.unify(at, expected, unitType)
                                self.inferTerm(environment, newExpected, newPipe)
                            | _ =>
                                ESequential(
                                    at = at
                                    before = self.inferTerm(environment, newExpected, newPipe)
                                    after = self.inferTerm(environment, expected, after)
                                )
                        }
                    | _ =>
                        ESequential(
                            at = at
                            before = self.inferTerm(environment, newExpected, before)
                            after = self.inferTerm(environment, expected, after)
                        )
                }
            | ELet e =>
                let noEffect = TConstructor(e.at, "ff:core/Nothing.Nothing", [])
                let scheme =
                    Scheme(True, e.mutable, False, False, Signature(e.at, e.name, [], [], [], e.valueType, noEffect))
                let environment2 = environment.Environment(symbols = environment.symbols.add(e.name, scheme))
                if(self.hoverAt.contains(e.at) && self.hoverResult.at.isEmpty()) {
                    self.hoverResult = self.hoverResult.HoverInfo(
                        at = Some(e.at)
                        type = Some(scheme.signature.returnType)
                    )
                }
                e.ELet(
                    value = self.inferTerm(environment, e.valueType, e.value)
                    body = self.inferTerm(environment2, expected, e.body)
                )
            | ELambda(at, l) =>
                if(!self.completionAt.isEmpty() && self.completionAt.contains(at.Location(column = at.column + 1))) {
                    if(l.cases.size() == 1) {
                        self.unification.substitute(expected).{
                            | TConstructor(_, name, [_, TConstructor(_, n, _), _]) {name == "Function$1"} =>
                                self.exhaustiveMatchCompletion(environment, n + "_", True)
                            | _ =>
                        }
                    }
                }
                let lambda = self.inferLambda(environment, expected, l)
                ELambda(at, lambda)
            | EVariant e =>
                if(self.completionAt.contains(e.at)) {self.completion(environment, "", False, expected)}
                let instantiated = self.lookup(environment, e.at, e.name, e.typeArguments).else {
                    throw(CompileError(e.at, "Symbol not in scope: " + e.name))
                }
                self.unification.unify(e.at, expected, instantiated.scheme.signature.returnType)
                let arguments = e.arguments.map {
                    self.inferArguments(e.at, environment, instantiated.scheme.signature.parameters, _)
                }
                e.EVariant(
                    typeArguments = instantiated.typeArguments.map {_.second}
                    arguments = arguments
                )
            | EVariantIs e =>
                let instantiated = self.lookup(environment, e.at, e.name, e.typeArguments).else {
                    throw(CompileError(e.at, "Symbol not in scope: " + e.name))
                }
                let parameters = instantiated.scheme.signature.parameters.sortBy {_.name}
                let recordType =
                    TConstructor(e.at, "Record$" + parameters.map {_.name}.join("$"), parameters.map {_.valueType})
                let functionType = TConstructor(e.at, "Function$1", [
                    self.unification.freshUnificationVariable(e.at)
                    instantiated.scheme.signature.returnType
                    TConstructor(e.at, core("Option"), [recordType])
                ])
                self.unification.unify(e.at, expected, functionType)
                e.EVariantIs(
                    typeArguments = instantiated.typeArguments.map {_.second}
                )
            | ECopy e =>
                let scheme = self.lookup(environment, e.at, e.name, []).else {
                    throw(CompileError(e.at, "Symbol not in scope: " + e.name))
                }.scheme
                if(scheme.isNewtype) {
                    throw(CompileError(e.at, "Newtypes can't be copied"))
                }
                let signature = scheme.signature
                if(!self.completionAt.isEmpty()) {
                    e.arguments.each {a => 
                        if(self.completionAt.contains(a.at)) {
                            signature.parameters.filter {p => !e.arguments.any {_.name == p.name}}.each {p =>
                                self.namedParameterCompletion(p, True)
                            }
                        }
                    }
                }
                let parameterNames = signature.parameters.map {_.name}
                e.arguments.find {a => !parameterNames.any {_ == a.name}}.each {
                    | Field(at, name, value) => throw(CompileError(at, "Unknown parameter: " + name))
                }
                let arguments = parameterNames.map {name =>
                    e.arguments.find {_.name == name}.map {
                        | Field(at, _, value) => Argument(at, Some(name), value)
                    }.else {
                        Argument(e.at, Some(name), EField(e.at, False, EVariable(e.at, "_c"), name))
                    }
                }
                let body = EVariant(e.at, e.name, [], Some(arguments))
                let effect = self.unification.freshUnificationVariable(e.at)
                let term = EPipe(e.at, e.record, effect
                    ELambda(e.at, Lambda(e.at, effect, [MatchCase(e.at, [PVariable(e.at, Some("_c"))], [], body)]))
                )
                self.inferTerm(environment, expected, term)
            | EPipe e =>
                let valueType = self.unification.freshUnificationVariable(e.at)
                let functionType = TConstructor(e.at, "Function$1", [
                    e.effect
                    valueType
                    expected
                ])
                let value = self.inferTerm(environment, valueType, e.value)
                let function = self.inferTerm(environment, functionType, e.function)
                self.unification.affect(term.at, e.effect, environment.effect)
                e.EPipe(
                    value = value
                    function = function
                )
            | ECall e =>
                if(!self.completionAt.isEmpty() && e.target.{| StaticCall _ => True | _ => False}) {term} else:
                let call = e.target.{
                    | DynamicCall call => call
                    | StaticCall _ => fail(e.at, "Internal error: Static calls not expected in the Inference phase")
                }
                call.function.{
                    | EVariable(variableAt, x) =>
                        if(self.completionAt.contains(variableAt)) {self.completion(environment, "", False, expected)}
                        if(x.first().any {c => c != '_' && !c.isAsciiLetter()}) {
                            self.inferOperator(environment, expected, x, term)
                        } else {
                            self.lookup(environment, e.at, x, e.typeArguments).{
                                | Some(instantiated) =>
                                    if(instantiated.scheme.isVariable) {
                                        self.inferLambdaCall(environment, expected, term)
                                    } else {
                                        let signature = instantiated.scheme.signature
                                        self.inferFunctionCall(
                                            environment
                                            expected
                                            signature
                                            instantiated.scheme.isTraitMethod
                                            instantiated.typeArguments
                                            term
                                            x
                                        )
                                    }
                                | None =>
                                    throw(CompileError(variableAt, "No such function: " + x))
                            }
                        }
                    | EField f =>
                        let recordType = self.unification.freshUnificationVariable(f.at)
                        let record = self.inferTerm(environment, recordType, f.record)
                        let e2 = e.ECall(target = call.DynamicCall(function = f.EField(record = record)))
                        self.unification.substitute(recordType).{
                            | TConstructor(_, name, _)@t =>
                                let memberPrefix = name + "_"
                                if(self.completionAt.contains(f.at)) {
                                    self.completion(environment, memberPrefix, True, expected)
                                }
                                let methodName = memberPrefix + f.field
                                self.lookup(environment, f.at, methodName, []).{
                                    | Some(instantiated) {!instantiated.scheme.isVariable} =>
                                        self.inferMethodCall(
                                            environment
                                            expected
                                            instantiated.scheme.signature
                                            instantiated.typeArguments
                                            e2
                                            record
                                            recordType
                                            methodName
                                        )
                                    | Some(instantiated) =>
                                        self.inferLambdaCall(environment, expected, e2)
                                    | None =>
                                        throw(CompileError(f.at
                                            "No such field " + f.field + " on type: " + t.show([])
                                        ))
                                }
                            | TVariable _ {!self.completionAt.isEmpty()} =>
                                self.inferLambdaCall(environment, expected, e2)
                            | TVariable(_, index) =>
                                throw(CompileError(f.at
                                    "No such field " + f.field + " on unknown type: $" + index
                                ))
                        }
                    | _ =>
                        self.inferLambdaCall(environment, expected, term)
                }
            | ERecord e =>
                let fields = e.fields.sortBy {_.name}
                let fieldTypes = fields.map {self.unification.freshUnificationVariable(_.at)}
                let recordType =
                    TConstructor(e.at, "Record$" + fields.map {_.name}.join("$"), fieldTypes)
                self.unification.unify(e.at, expected, recordType)
                let newFields = fields.zip(fieldTypes).map {| Pair(field, t) =>
                    field.Field(value = self.inferTerm(environment, t, field.value))
                }
                e.ERecord(
                    fields = newFields
                )
            | EFunctions(at, functions, body) =>
                let functionMap = functions.map {f =>
                    let scheme = Scheme(False, False, False, False, f.signature)
                    Pair(f.signature.name, scheme)
                }.toMap()
                let environment2 = environment.Environment(symbols = environment.symbols.addAll(functionMap))
                let newFunctions = functions.map {self.inferFunctionDefinition(environment2, _)}
                let newBody = self.inferTerm(environment2, expected, body)
                EFunctions(
                    at = at
                    functions = newFunctions
                    body = newBody
                )
            | EAssign e =>
                if(self.completionAt.contains(e.at)) {self.completion(environment, "", False, expected)}
                self.lookup(environment, e.at, e.variable, []).map {instantiated =>
                    if(instantiated.scheme.isMutable) {
                        let value = self.inferAssignment(
                            environment = environment
                            expected = expected
                            at = e.at
                            operator = e.operator
                            value = e.value
                            signature = instantiated.scheme.signature
                        )
                        e.EAssign(
                            value = value
                        )
                    } elseIf {!self.completionAt.isEmpty()} {
                        term
                    } else {
                        throw(CompileError(e.at, "Symbol is not mutable: " + e.variable))
                    }
                } else {
                    throw(CompileError(e.at, "Symbol not in scope: " + e.variable))
                }
            | EAssignField e =>
                let recordType = self.unification.freshUnificationVariable(e.at)
                let record = self.inferTerm(environment, recordType, e.record)
                self.unification.substitute(recordType).{
                    | TConstructor(_, name, typeArguments)@t {name.startsWith("Record$")} =>
                        throw(CompileError(e.at, "Can't assign fields of anonymous records: " + e.field))
                    | TConstructor(_, name, typeArguments)@t =>
                        let memberPrefix = name + "_"
                        if(self.completionAt.contains(e.at)) {
                            self.completion(environment, memberPrefix, True, expected)
                        }
                        let methodName = memberPrefix + e.field
                        self.lookup(environment, e.at, methodName, typeArguments).{
                            | Some(instantiated) {instantiated.scheme.isMutable} =>
                                let value = self.inferAssignment(
                                    environment = environment
                                    expected = expected
                                    at = e.at
                                    operator = e.operator
                                    value = e.value
                                    signature = instantiated.scheme.signature
                                )
                                e.EAssignField(
                                    record = record
                                    value = value
                                )
                            | Some(instantiated) =>
                                throw(CompileError(e.at
                                    "Can't assign an immutable field " + e.field + " on type: " + t.show([])
                                ))
                            | None =>
                                throw(CompileError(e.at, "No such field " + e.field + " on type: " + t.show([])))
                        }
                    | TVariable(_, _) {!self.completionAt.isEmpty()} =>
                        term
                    | TVariable(_, index) =>
                        throw(CompileError(e.at, "No such field " + e.field + " on unknown type: $" + index))
                }
        }
    }

    inferAssignment(
        environment: Environment
        expected: Type
        at: Location
        operator: String
        value: Term
        signature: Signature
    ): Term {
        let t = signature.returnType
        if(operator == "+" || operator == "-") {
            self.unification.unify(at, t, TConstructor(at, core("Int"), []))
        } elseIf {operator != ""} {
            throw(CompileError(at, "Only +=, -= and = assignments are supported. Got: " + operator + "="))
        }
        let newValue = self.inferTerm(environment, t, value)
        self.unification.unify(at, expected, TConstructor(at, core("Unit"), []))
        newValue
    }

    inferMethodCall(
        environment: Environment
        expected: Type
        signature: Signature
        instantiation: List[Pair[String, Type]]
        term: Term
        record: Term
        recordType: Type
        name: String
    ): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected")}
        let call = e.target.{
            | DynamicCall call => call
            | StaticCall _ => fail(e.at, "Internal error: Static calls not expected in inferMethodCall")
        }
        let selfParameter = signature.parameters.grabFirst()
        let selfArgument = Argument(record.at, Some(selfParameter.name), record) // Be careful not to infer again
        self.unification.unify(term.at, expected, signature.returnType)
        self.unification.unify(term.at, selfParameter.valueType, recordType)
        let arguments = self.inferArguments(term.at, environment, signature.parameters.dropFirst(), e.arguments)
        self.unification.affect(term.at, signature.effect, environment.effect)
        e.ECall(
            target = StaticCall(name, instanceCall = False, tailCall = call.tailCall)
            typeArguments = instantiation.map {_.second}
            arguments = [selfArgument, ...arguments]
            effect = signature.effect
        )
    }

    inferFunctionCall(
        environment: Environment
        expected: Type
        signature: Signature
        instanceCall: Bool
        instantiation: List[Pair[String, Type]]
        term: Term
        name: String
    ): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected")}
        let call = e.target.{
            | DynamicCall call => call
            | StaticCall _ => fail(e.at, "Internal error: Static calls not expected in inferFunctionCall")
        }
        self.unification.unify(e.at, expected, signature.returnType)
        let arguments = self.inferArguments(e.at, environment, signature.parameters, e.arguments)
        self.unification.affect(term.at, signature.effect, environment.effect)
        e.ECall(
            target = StaticCall(name, instanceCall = instanceCall, tailCall = call.tailCall)
            typeArguments = instantiation.map {_.second}
            arguments = arguments
            effect = signature.effect
        )
    }

    inferLambdaCall(environment: Environment, expected: Type, term: Term): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected")}
        let call = e.target.{
            | DynamicCall call {!call.tailCall} => call
            | DynamicCall _ => throw(CompileError(e.at, "Tailcalls not supported on lambda functions"))
            | StaticCall _ => fail(e.at, "Internal error: Static calls not expected in inferLambdaCall")
        }
        let effect = self.unification.freshUnificationVariable(term.at)
        let argumentTypes = e.arguments.map {self.unification.freshUnificationVariable(_.at)}
        let functionType = TConstructor(e.at, "Function$" + e.arguments.size(), [
            effect
            ...argumentTypes
            expected
        ])
        let function = self.inferTerm(environment, functionType, call.function)
        let arguments = e.arguments.zip(argumentTypes).map {| Pair(argument, t) =>
            argument.name.each {name =>
                throw(CompileError(argument.at, "Named argument not allowed here: " + name))
            }
            argument.Argument(value = self.inferTerm(environment, t, argument.value))
        }
        e.typeArguments.first().each {typeArgument =>
            throw(CompileError(typeArgument.at, "Type arguments not allowed here"))
        }
        self.unification.affect(term.at, effect, environment.effect)
        e.ECall(
            target = call.DynamicCall(function = function)
            typeArguments = []
            arguments = arguments
            effect = effect
        )
    }

    inferOperator(environment: Environment, expected: Type, operator: String, term: Term): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected") }
        let target = StaticCall(operator, instanceCall = False, tailCall = False)
        e.arguments.{
            | [a1] {
                operator == "!"
            } =>
                let t = TConstructor(e.at, core("Bool"), [])
                let e1 = self.inferTerm(environment, t, a1.value)
                self.unification.unify(e.at, expected, t)
                e.ECall(target = target, arguments = [a1.Argument(value = e1)])
            | [a1] {
                operator == "-"
            } =>
                let t1 = self.unification.freshUnificationVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                self.unification.substitute(t1).{
                    | TConstructor(_, name, []) {name == core("Float")} =>
                        self.unification.unify(e.at, expected, t1)
                    | TConstructor(_, name, []) {name == core("Int")} =>
                        self.unification.unify(e.at, expected, t1)
                    | _ {!self.completionAt.isEmpty()} =>
                    | _ =>
                        throw(CompileError(e.at, "Operators on unknown types not currently supported"))
                }
                e.ECall(target = target, arguments = [a1.Argument(value = e1)])
            | [a1, a2] {
                operator == "||" || operator == "&&"
            } =>
                let t = TConstructor(e.at, core("Bool"), [])
                let e1 = self.inferTerm(environment, t, a1.value)
                let e2 = self.inferTerm(environment, t, a2.value)
                self.unification.unify(e.at, expected, t)
                e.ECall(target = target, arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | [a1, a2] {
                operator == "===" || operator == "!==" // For internal use
            } =>
                let t1 = self.unification.freshUnificationVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                let e2 = self.inferTerm(environment, t1, a2.value)
                self.unification.unify(e.at, expected, TConstructor(e.at, core("Bool"), []))
                e.ECall(target = target, arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | [a1, a2] {
                operator == "+" || operator == "-" ||
                operator == "*" || operator == "/" || operator == "%" ||
                operator == "^"
            } =>
                let t1 = self.unification.freshUnificationVariable(e.at)
                let t2 = self.unification.freshUnificationVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                let e2 = self.inferTerm(environment, t2, a2.value)
                let magic: Type => Option[String] = { t =>
                    self.unification.substitute(t).{
                        | TConstructor(_, name, []) {name == core("Float")} => Some("Float")
                        | TConstructor(_, name, []) {name == core("Int")} => Some("Int")
                        | TConstructor(_, name, []) {operator == "+" && name == core("String")} => Some("String")
                        | _ => None
                    }
                }
                let chooseType: (Option[String], Option[String]) => Unit = {
                    | Some("String"), Some(_) => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some("String") => self.unification.unify(e.at, expected, t2)
                    | Some("Float"), Some(_) => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some("Float") => self.unification.unify(e.at, expected, t2)
                    | Some("Int"), Some(_) => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some("Int") => self.unification.unify(e.at, expected, t2)
                    | Some(_), None =>
                        self.unification.unify(e.at, t1, t2)
                        self.unification.unify(e.at, expected, t1)
                    | None, Some(_) =>
                        self.unification.unify(e.at, t2, t1)
                        self.unification.unify(e.at, expected, t2)
                    | _, _ {!self.completionAt.isEmpty()} =>
                    | Some(_), Some(_) =>
                        throw(CompileError(e.at, "Operators on these types not currently supported"))
                    | None, None =>
                        throw(CompileError(e.at, "Operators on unknown types not currently supported"))
                }
                chooseType(magic(t1), magic(t2))
                e.ECall(target = target, arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | _ {!self.completionAt.isEmpty()} =>
                term
            | _ =>
                fail(e.at, "Unknown operator: " + operator)
        }
    }

    inferEtaExpansion(
        environment: Environment
        expected: Type
        at: Location
        signature: Signature
        term: Term
    ): Term {
        let parameters = signature.parameters.filter {_.default.isEmpty()}.map {p =>
            p.name
        }
        let effect1 = self.unification.freshUnificationVariable(at)
        let body = ECall(at, DynamicCall(term, False), effect1, [], parameters.map {x =>
            Argument(at, Some(x), EVariable(at, x))
        }, [])
        let effect2 = self.unification.freshUnificationVariable(at)
        let lambda = ELambda(at, Lambda(at, effect2, [MatchCase(
            at = at
            patterns = parameters.map {PVariable(at, Some(_))}
            guards = []
            body = body
        )]))
        self.inferTerm(environment.Environment(effect = effect2), expected, lambda)
    }

    inferArguments(
        callAt: Location
        environment: Environment
        parameters: List[Parameter]
        arguments: List[Argument]
    ): List[Argument] {
        mutable remainingArguments = arguments
        let newArguments = parameters.map {p =>
            let t = p.valueType
            function defaultArgument(): Argument {
                p.default.map {e =>
                    let e2 = self.inferTerm(environment, t, e)
                    Argument(callAt, Some(p.name), e2)
                }.else {
                    if(self.completionAt.isEmpty()) {
                        fail(callAt, "Missing argument: " + p.name)
                    } else {
                        Argument(callAt, Some(p.name), EVariable(callAt, ""))
                    }
                }
            }
            remainingArguments.{
                | [] =>
                    defaultArgument()
                | [Argument(at, None, e), ...remaining] =>
                    if(self.completionAt.contains(at)) {
                        let preselect = arguments.any {!_.name.isEmpty()} || (
                            callAt.line != at.line && 
                            parameters.reverse().toStream().map {_.valueType}.dropWhile {
                                | TConstructor(_, n, _) => n.startsWith("Function$")
                                | _ => False
                            }.toList().size() > 1
                        )
                        self.namedParameterCompletion(p, preselect)
                    }
                    remainingArguments = remaining
                    let e2 = self.inferTerm(environment, t, e)
                    Argument(at, Some(p.name), e2)
                | _ =>
                    remainingArguments.find {_.name.contains(p.name)}.map {| Argument(at, _, e) =>
                        remainingArguments = remainingArguments.filter {!_.name.contains(p.name)}
                        if(self.hoverAt.contains(at) && self.hoverResult.at.isEmpty()) {
                            self.hoverResult = self.hoverResult.HoverInfo(
                                at = Some(p.at)
                                type = Some(t)
                            )
                        }
                        let e2 = self.inferTerm(environment, t, e)
                        Argument(at, Some(p.name), e2)
                    }.else {
                        defaultArgument()
                    }
            }
        }
        if(self.completionAt.isEmpty()) {
            remainingArguments.first().each {
                | Argument(callAt, None, _) => fail(callAt, "Too many arguments")
                | Argument(callAt, Some(name), _) => fail(callAt, "Unknown argument: " + name)
            }
        }
        newArguments
    }

    lookup(environment: Environment, at: Location, symbol: String, typeArguments: List[Type]): Option[Instantiated] {
        self.lookupOption(environment, at, symbol, typeArguments).elseIf {!self.completionAt.isEmpty()} {
            Instantiated([], Scheme(True, False, False, False, Signature(
                at
                symbol
                []
                []
                []
                self.unification.freshUnificationVariable(at)
                self.unification.freshUnificationVariable(at)
            )))
        }
    }

    lookupOption(environment: Environment, at: Location, symbol: String, typeArguments: List[Type]): Option[Instantiated] {

        environment.symbols.get(symbol).map: scheme =>

        let instantiation =
            if(!typeArguments.isEmpty()) {
                let newTypeArguments = if(!scheme.isVariable && scheme.signature.generics.first().any {_ == "Q$"}) {
                    [self.unification.freshUnificationVariable(at), ...typeArguments]
                } else {
                    typeArguments
                }
                if(scheme.signature.generics.size() != newTypeArguments.size() && self.completionAt.isEmpty()) {
                    let extra = newTypeArguments.size() - typeArguments.size()
                    throw(CompileError(at
                        "Wrong number of type arguments for " + symbol +
                        ", expected " + (scheme.signature.generics.size() - extra) +
                        ", got " + (newTypeArguments.size() - extra)
                    ))
                }
                scheme.signature.generics.zip(newTypeArguments)
            } else {
                scheme.signature.generics.map {name =>
                    Pair(name, self.unification.freshUnificationVariable(at))
                }
            }

        let instantiationMap = instantiation.toMap()
        let parameters = scheme.signature.parameters.map {p =>
            p.Parameter(valueType = self.unification.instantiate(instantiationMap, p.valueType))
        }
        let returnType = self.unification.instantiate(instantiationMap, scheme.signature.returnType)
        let effect = self.unification.instantiate(instantiationMap, scheme.signature.effect)

        scheme.signature.constraints.each {c =>
            let generics = c.generics.map {self.unification.instantiate(instantiationMap, _)}
            self.unification.constrain(at, generics.grabFirst(), c.name, generics.dropFirst())
        }

        let signature = scheme.signature.Signature(
            generics = []
            constraints = []
            parameters = parameters
            returnType = returnType
            effect = effect
        )

        if(self.hoverAt.contains(at) && self.hoverResult.type.isEmpty()) {
            self.hoverResult = self.hoverResult.HoverInfo(
                at = Some(scheme.signature.at)
                type = Some(returnType)
                effect = Some(effect)
            )
        }

        Instantiated(
            typeArguments = instantiation
            scheme = scheme.Scheme(signature = signature)
        )

    }

    completion(environment: Environment, prefix: String, member: Bool, expected: Type): Unit {

        let expectedName = expected.{
            | TConstructor(_, n, _) => n
            | _ => "##"
        }

        let members = Stack.make()

        function makeCompletion(prefix: String, memberName: String, memberScheme: Scheme, copy: Bool) {
            let shortName = memberName.dropFirst(prefix.size())
            let unqualifiedName = shortName.reverse().takeWhile {_ != '.'}.reverse()
            let upper = unqualifiedName.first().any {_.isAsciiUpper()}
            let variantWithoutParameters = upper && memberScheme.signature.parameters.isEmpty()
            let realParameters = memberScheme.signature.parameters.dropFirst(if(member && !copy) {1} else {0})
            let pair = if(!memberScheme.isVariable && !variantWithoutParameters) {
                let trailing = realParameters.pairs().reverse().map {| Pair(index, p) =>
                    p.valueType.{
                        | TConstructor(_, name, _) {name.startsWith("Function$")} =>
                            Some(Pair(
                                " {...}"
                                if(index == 0) {" {$0}"} else {" {}"}
                            ))
                        | _ => 
                            None
                    }
                }.toStream().takeWhile {_ != None}.collect {_}.toList().reverse()
                let allRequired = realParameters.filter {_.default.isEmpty()}
                let required =  allRequired.dropLast(trailing.size()).map {_.name}
                let optional = if(allRequired.size() != realParameters.size()) {"..."}
                Pair(
                    if(trailing.isEmpty() || !required.isEmpty()) {
                        "(" + [...required, ...optional.toList()].join(", ") + ")"
                    } else {
                        ""
                    } + trailing.map {_.first}.join()
                    if(copy) {
                        "(${1|" + realParameters.map {_.name}.map {f => f + " = "}.join(",") + "|}$0)"
                    } else {
                        if(trailing.isEmpty() || !required.isEmpty()) {
                            if(required.isEmpty()) {
                                "(" + required.join(", ") + ")"
                            } else {
                                "(${0:" + required.join(", ") + "})"
                            }
                        } else {
                            ""
                        } + if(trailing.isEmpty()) {""} else {trailing.map {_.second}.join()}
                    }
                )
            } else {Pair("", "")}
            let returnType = self.unification.substitute(memberScheme.signature.returnType)
            let documentation = if(memberScheme.isVariable || variantWithoutParameters) {
                let methodGenerics = memberScheme.signature.generics
                let generics = if(member || methodGenerics.isEmpty()) {""} else {"[" + methodGenerics.join(", ") + "]"}
                if(memberScheme.isMutable) {"mutable "} else {""} +
                unqualifiedName + generics +
                ": " + returnType.show([])
            } else {
                let selfType = memberScheme.signature.parameters.first().filter {_ => member && !copy}.map {_.valueType}
                let generics = selfType.map {
                    | TConstructor(_, _, gs) => 
                        // TODO: Needs constraints as well
                        // TODO: This drops the wrong number of type parameters - more environment needed
                        let methodGenerics = memberScheme.signature.generics.dropFirst(gs.size() + 1)
                        if(methodGenerics.isEmpty()) {""} else {"[" + methodGenerics.join(", ") + "]"}
                    | _ =>
                        ""
                }.else {
                    let methodGenerics = memberScheme.signature.generics.filter {_ != "Q$"}
                    if(methodGenerics.isEmpty()) {""} else {"[" + methodGenerics.join(", ") + "]"}
                }
                let selfIndent = selfType.map {_ => "    "}.else {""}
                let parameters = if(realParameters.isEmpty()) {""} else {
                    "\n" + realParameters.map {p =>
                        self.showCompletionParameter(selfIndent + "    ", p)
                    }.join("\n") + "\n" + selfIndent
                }
                selfType.map {_.show([])}.map {"extend " + _ + " {\n"}.else {""} +
                selfIndent + unqualifiedName + 
                generics + "(" + parameters + "): " + 
                returnType.show([]) + 
                selfType.map {_ => "\n}"}.else {""}
            }
            members.push(CompletionInfo(
                label = shortName + pair.first
                snippet = shortName + pair.second
                member = member && !copy
                type = returnType
                documentation = documentation
                expectedType = Some(expected)
            ))
        }

        let symbols = if(prefix == "") {
            environment.symbols.toList().collect {
                | Pair(name, _)@pair {name.all {_.isAsciiLetterOrDigit()}} => 
                    Some(pair)
                | Pair(name, _)@pair {name.startsWith("ff:core/Core.")} => 
                    Some(pair.mapFirst {_.dropFirst("ff:core/Core.".size())})
                | Pair(name, scheme) {name.dropWhile {_ != '/'}.dropFirst() | short} {
                    short.reverse().takeWhile {_ != '.'}.reverse() | shorter
                } {shorter.all {_.isAsciiLetterOrDigit()}} =>
                    if(shorter.first().any {_.isAsciiUpper()}) {
                        Some(Pair(shorter, scheme))
                    } else {
                        let module = name.dropLast(shorter.size() + 1)
                        let alias = environment.imports.find {_, i =>
                            module == i.package.groupName() + "/" + i.directory.map {_ + "/"}.join() + i.file
                        }
                        alias.map {| Pair(alias, i) => 
                            Pair(alias + short.dropFirst(i.file.size()), scheme)
                        }
                    }
                | _ => 
                    None
            }.toMap()
        } else {
            self.exhaustiveMatchCompletion(environment, prefix, False)
            let shorterPrefix = prefix.dropLast()
            let recordFields = prefix.split('$').dropFirst().toSet()
            environment.symbols.each {
                | shortName, scheme {shortName.dropWhile {_ != '/'}.dropFirst() | short} {
                    short.reverse().takeWhile {_ != '.'}.reverse() | shorter
                } {shorter.all {_.isAsciiLetterOrDigit()} && shorter.first().any {_.isAsciiUpper()}} => 
                    scheme.signature.returnType.{
                        | _ {prefix.startsWith("Record$")} =>
                            if(scheme.signature.parameters.any {recordFields.contains(_.name)}) {
                                makeCompletion("", shorter, scheme, True)
                            }
                        | TConstructor(_, name, _) {name.startsWith(shorterPrefix)} =>
                            if(!scheme.signature.parameters.isEmpty()) {
                                makeCompletion("", shorter, scheme, True)
                            }
                        | _ =>
                    }
                | _, _ => 
            }
            environment.symbols
        }

        symbols.each {memberName, memberScheme =>
            if(memberName.startsWith(prefix)) {
                makeCompletion(prefix, memberName, memberScheme, False)
            }
        }
        self.completionResult = [...self.completionResult, ...members.toList()]
    }

    exhaustiveMatchCompletion(environment: Environment, prefix: String, inside: Bool): Unit {
        if(prefix == "ff:core/List.List_") {
            let curly = if(inside) {Pair("", "")} else {Pair("{", "}")}
            self.completionResult = [...self.completionResult, CompletionInfo(
                label = curly.first + "| [] => ... | [first, ...rest] => ..." + curly.second
                snippet = curly.first + "\n    | [] => $0\n    | [first, ...rest] =>\n" + curly.second
                member = True
                type = TConstructor(Location("", 0, 0), "exhaustive match", [])
                documentation = "// Exhaustive list match"
                expectedType = None
            )]
        } else:
        let shorterPrefix = prefix.dropLast()
        let variants = environment.symbols.toList().filter {s => 
            !s.first.contains("_") &&
            s.first.reverse().takeWhile {_ != '.'}.reverse().first().any {_.isAsciiUpper()} &&
            s.second.signature.returnType.{
                | TConstructor(_, n, _) => n == shorterPrefix 
                | _ => False
            }
        }
        if(variants.isEmpty()) {} else:
        let label = if(inside) {""} else {"{"} + 
            variants.map {v =>
                "| " + v.first.reverse().takeWhile {_ != '.'}.reverse() + 
                if(v.second.signature.parameters.isEmpty()) {""} else {"(...)"} + " => ..."
            }.join(" ") +
            if(inside) {""} else {"}"}
        let snippetParts = variants.pairs().map {| Pair(index, Pair(name, scheme)) => 
            "| " + name.reverse().takeWhile {_ != '.'}.reverse() + 
            if(scheme.signature.parameters.isEmpty()) {""} else {
                "(" + scheme.signature.parameters.map {_.name}.join(", ") + ")"
            } +
            " => " + if(index == 0) {"$0"} else {""}
        }
        let snippet = 
            if(inside) {""} else {"{"} + 
            if(snippetParts.size() != 1) {
                "\n" + snippetParts.map {"    " + _}.join("\n") + "\n"
            } else {
                snippetParts.join(" ")
            } + 
            if(inside) {""} else {"}"}
        self.completionResult = [...self.completionResult, CompletionInfo(
            label = label
            snippet = snippet
            member = True
            type = TConstructor(Location("", 0, 0), "exhaustive match", [])
            documentation = "// Exhaustive match:\n" + snippetParts.join("\n").replace("$0", "")
            expectedType = None
        )]
    }

    patternCompletion(environment: Environment, expected: Type): Unit {
        let typeName = self.unification.substitute(expected).{
            | TConstructor(_, name, _) => name
            | _ => ""
        }
        if(typeName == "") {} else:
        if(typeName == "ff:core/List.List") {
            self.completionResult = [...self.completionResult, 
                CompletionInfo("[...]", "[${0:first, ...rest}]", False, expected, "// List pattern", Some(expected))
            ]
        } else:
        if(typeName == "ff:core/String.String") {
            self.completionResult = [...self.completionResult, 
                CompletionInfo("\"...\"", "\"$0\"", False, expected, "// String pattern", Some(expected))
            ]
        } else:
        if(typeName == "ff:core/Int.Int") {
            self.completionResult = [...self.completionResult, 
                CompletionInfo("0", "0", False, expected, "// Int pattern", Some(expected))
            ]
        } else:
        let variants = do {
            environment.symbols.toList().filter {s => 
                !s.first.contains("_") &&
                s.first.reverse().takeWhile {_ != '.'}.reverse().first().any {_.isAsciiUpper()} &&
                s.second.signature.returnType.{
                    | TConstructor(_, n, _) => n == typeName 
                    | _ => False
                }
            }
        }
        let completions = variants.map {| Pair(name, scheme) => 
            let shortName = name.reverse().takeWhile {_ != '.'}.reverse()
            let snippet = 
                shortName +
                if(scheme.signature.parameters.isEmpty()) {""} else {
                    "(${0:" + scheme.signature.parameters.map {_.name}.join(", ") + "})"
                }
            let generics = scheme.signature.generics.filter {_ != "Q$"}
            let documentation = 
                shortName + 
                if(generics.isEmpty()) {""} else {"[" + generics.join(", ") + "]"} +
                if(scheme.signature.parameters.isEmpty()) {""} else {
                    "(\n" + scheme.signature.parameters.map {
                        self.showCompletionParameter("    ", _)
                    }.join("\n") + "\n)"
                } + ": " + scheme.signature.returnType.show([])
            CompletionInfo(
                label = snippet.replace("${0:", "").replace("}", "")
                snippet = snippet
                member = False
                type = expected
                documentation = documentation
                expectedType = Some(expected)
            )
        }
        self.completionResult = [...self.completionResult, ...completions]
    }

    namedParameterCompletion(parameter: Parameter, preselect: Bool): Unit {
        self.completionResult = [...self.completionResult, CompletionInfo(
            label = parameter.name + " = ..."
            snippet = parameter.name + " = "
            member = False
            type = parameter.valueType
            documentation = self.showCompletionParameter("", parameter)
            expectedType = if(preselect) {parameter.valueType}
        )]
    }

    showCompletionParameter(indentation: String, parameter: Parameter): String {
        if(parameter.mutable) {indentation + "mutable "} else {indentation} +
        parameter.name + ": " + parameter.valueType.show([]) +
        parameter.default.map {
            | EVariant(_, n, _, None) =>
                n.reverse().takeWhile {_.isAsciiLetterOrDigit()}.reverse()
            | EVariant(_, n, _, Some([])) =>
                n.reverse().takeWhile {_.isAsciiLetterOrDigit()}.reverse()
            | EVariant(_, n, _, _) => 
                n.reverse().takeWhile {_.isAsciiLetterOrDigit()}.reverse() + "(...)"
            | EChar(_, v) => v
            | EInt(_, v) => v
            | EFloat(_, v) => v
            | EString(_, v) => v.replace("```", "'''")
            | ELambda(_, _) => "{...}"
            | EList(_, _, []) => "[]"
            | EList(_, _, _) => "[...]"
            | _ => " = ..."
        }.map {" = " + _}.else {""}
    }

}

constraintsToInstances(constraints: List[Constraint]): Map[InstanceKey, InstanceValue] {
    constraints.map {c =>
        let typeName = c.generics.grabFirst().{
            | TConstructor(_, name, _) => name
            | TVariable(at, i) => fail(c.at, "Unexpected unification variable: $" + i)
        }
        Pair(
            InstanceKey(c.name, typeName)
            InstanceValue(
                generics = []
                constraints = []
                packagePair = PackagePair("", "")
                moduleName = ""
                traitName = c.name
                typeArguments = c.generics
            )
        )
    }.toMap()
}
