import Syntax
import Unification
import Environment

type Inference(
    unification: Unification
)

make(instances: List[DInstance]): Inference {
    Inference(
        unification = Unification.make(instances)
    )
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

//myInt = 42
//myString: String = myInt
//myFunction(x: Int): String { | a, b => x }
//myInt = Location("foo", 1, 1).Location(line = 2)
//myFoo: String = 1.{x => x}
//myLambda: Int => Int = { x => 1 }
//myCall = myLambda[Int](1)
//myEta: Int => String = core
//myFieldEta: () => Set[Int] = [].toSet

core(name: String): String {
    "ff:core/Core." + name
}

extend self: Inference {

    inferModule(coreModule: Module, module: Module, otherModules: List[Module]): Module {
        // First infer everything, then substitute everything (failing on type variables that can't be substituted)

        let environment = Environment.make(coreModule, module, otherModules)

        let lets = module.lets.map { self.inferLetDefinition(environment, _) }
        let functions = module.functions.map { self.inferFunctionDefinition(environment, _) }
        let extends = module.extends.map { self.inferExtendDefinition(environment, _) }
        //let traits = module.traits.map { self.inferTraitDefinition(_) }
        //let instances = module.instances.map { self.inferInstanceDefinition(_) }
        module.Module(
            //traits = traits,
            //instances = instances,
            extends = extends,
            lets = lets,
            functions = functions,
        )
    }

    inferLetDefinition(environment: Environment, definition: DLet): DLet {
        let value = self.inferTerm(environment, definition.variableType, definition.value)
        definition.DLet(
            value = value
        )
    }

    inferExtendDefinition(environment: Environment, definition: DExtend): DExtend {
        let selfParameter = Parameter(
            at = definition.at
            mutable = False
            name = definition.name
            valueType = definition.type
            default = None
        )
        let functions = definition.methods.map { method =>
            let signature = method.signature.Signature(
                generics = definition.generics ++ method.signature.generics
                constraints = definition.constraints ++ method.signature.constraints
                parameters = [selfParameter, ...method.signature.parameters]
            )
            let lambda = method.body.Lambda(
                cases = method.body.cases.map { case =>
                    let selfPattern = PVariable(method.at, Some(definition.name))
                    case.MatchCase(
                        patterns = [selfPattern, ...case.patterns]
                    )
                }
            )
            let function = method.DFunction(
                signature = signature
                body = lambda
            )
            self.inferFunctionDefinition(environment, function)
        }
        definition.DExtend(
            methods = functions
        )
    }

    inferFunctionDefinition(environment: Environment, definition: DFunction): DFunction {
        let parameters = definition.signature.parameters.map { p =>
            let scheme = Scheme(True, False, Signature(p.at, p.name, [], [], [], p.valueType))
            Pair(p.name, scheme)
        }.getMap()
        let environment2 = environment.Environment(symbols = environment.symbols ++ parameters)
        let functionType = TConstructor(
            definition.at,
            "Function$" + parameters.getSize(),
            [...parameters.map { _.second.signature.returnType }, definition.signature.returnType]
        )
        definition.DFunction(body = self.inferLambda(environment2, functionType, definition.body))
    }

    inferLambda(environment: Environment, expected: Type, lambda: Lambda): Lambda {
        lambda.Lambda(
            cases = lambda.cases.map { self.inferMatchCase(environment, expected, _) }
        )
    }

    inferMatchCase(environment: Environment, expected: Type, case: MatchCase): MatchCase {
        let parameterTypes = case.patterns.map { self.unification.freshTypeVariable(_.at) }
        let returnType = self.unification.freshTypeVariable(case.at)
        let functionType = TConstructor(
            case.at,
            "Function$" + case.patterns.size,
            [...parameterTypes, returnType]
        )
        self.unification.unify(case.at, expected, functionType)
        let newEnvironment = (parameterTypes.zip(case.patterns).foldLeft(environment)) {| environment1, Pair(t, c) =>
            let symbols = self.inferPattern(environment, t, c).map {| Pair(name, type) =>
                Pair(name, Scheme(True, False, Signature(c.at, name, [], [], [], type)))
            }
            Environment(environment1.symbols ++ symbols)
        }
        let condition = case.condition.map { e =>
            self.inferTerm(newEnvironment, TConstructor(e.at, core("Bool"), []), e)
        }
        let body = self.inferTerm(newEnvironment, returnType, case.body)
        case.MatchCase(
            condition = condition
            body = body
        )
    }

    inferPattern(environment: Environment, expected: Type, pattern: MatchPattern): Map[String, Type] {
        pattern.{
            | PVariable(at, None) =>
                Map()
            | PVariable(at, Some(name)) =>
                Map(Pair(name, expected))
            | PAlias(at, pattern, variable) =>
                self.inferPattern(environment, expected, pattern) + Pair(variable, expected)
            | PList(at, t, items) =>
                let listType = TConstructor(at, core("List"), [t])
                self.unification.unify(at, expected, listType)
                (items.map {
                    | Pair(item, False) => self.inferPattern(environment, t, item)
                    | Pair(item, True) => self.inferPattern(environment, listType, item)
                }.foldLeft(Map[String, Type]())) { _ ++ _ }
            | PVariantAs(at, name, None) =>
                let scheme = environment.symbols.get(name).else {
                    fail(at, "No such variant: " + name)
                }
                Map()
            | PVariantAs(at, name, Some(variable)) =>
                let scheme = environment.symbols.get(name).else {
                    fail(at, "No such variant: " + name)
                }
                let instantiation = self.inferTypeArguments(at, name, scheme.signature.generics, [])
                let instantiated = self.instantiateSignature(scheme.signature, instantiation)
                self.unification.unify(at, expected, instantiated.returnType)
                let parameters = instantiated.parameters.sortBy { _.name }
                let recordType =
                    TConstructor(at, "Record$" + parameters.map { _.name }.join("$"), parameters.map { _.valueType })
                Map(Pair(variable, recordType))
            | PVariant(at, name, patterns) =>
                let scheme = environment.symbols.get(name).else {
                    fail(at, "No such variant: " + name)
                }
                let instantiation = self.inferTypeArguments(at, name, scheme.signature.generics, [])
                let instantiated = self.instantiateSignature(scheme.signature, instantiation)
                self.unification.unify(at, expected, instantiated.returnType)
                (patterns.zip(instantiated.parameters).map {| Pair(pattern, parameter) =>
                    self.inferPattern(environment, parameter.valueType, pattern)
                }.foldLeft(Map[String, Type]())) { _ ++ _ }
        }
    }

    inferTerm(environment: Environment, expected: Type, term: Term): Term {
        function literal(coreTypeName: String): Term {
            self.unification.unify(term.at, expected, TConstructor(term.at, core(coreTypeName), []))
            term
        }
        term.{
            | EString _ => literal("String")
            | EChar _ => literal("Char")
            | EInt _ => literal("Int")
            | EFloat _ => literal("Float")
            | EVariable e =>
                environment.symbols.get(e.name).map { scheme =>
                    if(scheme.isVariable) {
                        self.unification.unify(e.at, expected, scheme.signature.returnType)
                        term
                    } else {
                        let instantiation =
                            self.inferTypeArguments(e.at, e.name, scheme.signature.generics, e.generics)
                        let instantiated = self.instantiateSignature(scheme.signature, instantiation)
                        self.inferEtaExpansion(environment, expected, e.at, instantiated, term)
                    }
                } else {
                    fail(e.at, "Symbol not in scope: " + e.name)
                }
            | EField e =>
                let recordType = self.unification.freshTypeVariable(e.at)
                let record = self.inferTerm(environment, recordType, e.record)
                let e2 = e.EField(record = record)
                self.unification.substitute(recordType).{
                    | TConstructor(_, name, typeArguments)@t {name.startsWith("Record$")} =>
                        let fieldNames = name.split('$').toList.drop(1)
                        fieldNames.pairs().find { _.second == e.field }.map { _.first }.map { index =>
                            let t1 = typeArguments.expect(index)
                            self.unification.unify(e.at, expected, t1)
                            e2
                        }.else {
                            fail(e.at, "No such field " + e.field + " on type: " + t.show())
                        }
                    | TConstructor(_, name, typeArguments)@t =>
                        let methodName = name + "_" + e.field
                        environment.symbols.get(methodName).{
                            | Some(scheme) {!scheme.isVariable} =>
                                let instantiation =
                                    self.inferTypeArguments(e.at, e.field, scheme.signature.generics, typeArguments)
                                let instantiated = self.instantiateSignature(scheme.signature, instantiation)
                                let signature = instantiated.Signature(
                                    parameters = instantiated.parameters.drop(1) // Drop self for eta expansion
                                )
                                self.unification.unify(e.at, recordType, instantiated.parameters.expect(0).valueType)
                                self.inferEtaExpansion(environment, expected, e.at, signature, e2)
                            | Some(scheme) =>
                                self.unification.unify(e.at, expected, scheme.signature.returnType)
                                e.EField(record = record)
                            | None =>
                                fail(e.at, "No such field " + e.field + " on type: " + t.show())
                        }
                    | TVariable(_, index) =>
                        fail(e.at, "No such field " + e.field + " on unknown type: $" + index)
                }
            | EWildcard e =>
                environment.symbols.get("_w" + e.index).map { scheme =>
                    self.unification.unify(e.at, expected, scheme.signature.returnType)
                    term
                }.get
            | EList(at, t, items) =>
                let listType = TConstructor(term.at, core("List"), [t])
                self.unification.unify(at, expected, listType)
                EList(at, t, items.map { | Pair(item, spread) =>
                    Pair(self.inferTerm(environment, if(spread) { listType } else { t }, item), spread)
                })
            | ESequential(at, before, after) =>
                ESequential(
                    at = at
                    before = self.inferTerm(environment, self.unification.freshTypeVariable(at), before)
                    after = self.inferTerm(environment, expected, after)
                )
            | ELet e =>
                let scheme = Scheme(True, False, Signature(e.at, e.name, [], [], [], e.valueType))
                let environment2 = environment.Environment(symbols = environment.symbols + Pair(e.name, scheme))
                e.ELet(
                    value = self.inferTerm(environment, e.valueType, e.value)
                    body = self.inferTerm(environment2, expected, e.body)
                )
            | ELambda(at, l) =>
                let lambda = self.inferLambda(environment, expected, l)
                ELambda(at, lambda)
            | EVariant e =>
                let signature = environment.symbols.get(e.name).else {
                    fail(e.at, "Symbol not in scope: " + e.name)
                }.signature
                // TODO: Constrain the type arguments
                let instantiation = self.inferTypeArguments(e.at, e.name, signature.generics, e.typeArguments)
                let instantiated = self.instantiateSignature(signature, instantiation)
                self.unification.unify(e.at, expected, instantiated.returnType)
                let arguments = e.arguments.map {
                    self.inferArguments(e.at, environment, instantiated.parameters, _)
                }
                e.EVariant(
                    typeArguments = instantiation.map { _.second }
                    arguments = arguments
                )
            | EVariantIs e =>
                let signature = environment.symbols.get(e.name).else {
                    fail(e.at, "Symbol not in scope: " + e.name)
                }.signature
                let typeArguments = self.inferTypeArguments(e.at, e.name, signature.generics, e.typeArguments)
                e.EVariantIs(
                    typeArguments = typeArguments.map { _.second }
                )
            | ECopy e =>
                let signature = environment.symbols.get(e.name).else {
                    fail(e.at, "Symbol not in scope: " + e.name)
                }.signature
                let parameterNames = signature.parameters.map { _.name }
                e.arguments.find { a => !parameterNames.exists { _ == a.name } }.each {
                    | Field(at, name, value) => fail(at, "Unknown parameter: " + name)
                }
                let arguments = parameterNames.map { name =>
                    e.arguments.find { _.name == name }.map {
                        | Field(at, _, value) => Argument(at, Some(name), value)
                    }.else {
                        Argument(e.at, Some(name), EField(e.at, EVariable(e.at, "_c", [], []), name))
                    }
                }
                let body = EVariant(e.at, e.name, [], Some(arguments))
                let term = EPipe(e.at, e.record,
                    ELambda(e.at, Lambda(e.at, [MatchCase(e.at, [PVariable(e.at, Some("_c"))], None, body)]))
                )
                self.inferTerm(environment, expected, term)
            | EPipe e =>
                let valueType = self.unification.freshTypeVariable(e.at)
                let functionType = TConstructor(e.at, "Function$1", [valueType, expected])
                let value = self.inferTerm(environment, valueType, e.value)
                let function = self.inferTerm(environment, functionType, e.function)
                e.EPipe(
                    value = value
                    function = function
                )
            | ECall e =>
                e.function.{
                    | EVariable(variableAt, x, [], []) =>
                        if(x.headOption.exists { c => c != '_' && !c.isLetter }) {
                            self.inferOperator(environment, expected, x, e)
                        } else {
                            environment.symbols.get(x).{
                                | Some(scheme) =>
                                    if(scheme.isVariable) {
                                        self.inferLambdaCall(environment, expected, e)
                                    } else {
                                        self.inferFunctionCall(environment, expected, scheme.signature, e, x)
                                    }
                                | None =>
                                    fail(variableAt, "No such function: " + x)
                            }
                        }
                    | EField f =>
                        let recordType = self.unification.freshTypeVariable(f.at)
                        let record = self.inferTerm(environment, recordType, f.record)
                        let e2 = e.ECall(function = f.EField(record = record))
                        self.unification.substitute(recordType).{
                            | TConstructor(_, name, typeParameters) =>
                                let methodName = name + "_" + f.field
                                environment.symbols.get(methodName).{
                                    | Some(scheme) {!scheme.isVariable} =>
                                        self.inferMethodCall(
                                            environment,
                                            expected,
                                            scheme.signature,
                                            e2,
                                            record,
                                            methodName
                                        )
                                    | _ =>
                                        self.inferLambdaCall(environment, expected, e2)
                                }
                            | TVariable(_, index) =>
                                fail(f.at, "No such field " + f.field + " on unknown type: $" + index)
                        }
                    | _ =>
                        self.inferLambdaCall(environment, expected, e)
                }
            | _ => term
            /*
            | ERecord(at, fields) =>
                let recordType =
                    TConstructor(at, "Record$" + fields.map { _.name }.join("$"), fields.map { _.valueType })
                ERecord(
                    at = at
                    fields = fields.map { f => f.Field(value = self.resolveTerm(f.value)) }
                )
            | EFunctions(at, functions, body) =>
                let functionMap = functions.map { _.signature.name }.map { name => Pair(name, name) }.toMap
                let self2 = self.Resolver(variables = self.variables ++ functionMap)
                EFunctions(
                    at = at,
                    functions = functions.map { self2.resolveFunction(_) },
                    body = self2.resolveTerm(body)
                )
            | EAssign(at, operator, variable, value) =>
                EAssign(
                    at = at
                    operator = operator
                    variable = self.variables.get(variable).else { fail(at, "No such variable: " + variable) }
                    value = self.resolveTerm(value)
                )
            | EAssignField(at, operator, record, field, value) =>
                EAssignField(
                    at = at
                    operator = operator
                    record = self.resolveTerm(record)
                    field = field
                    value = self.resolveTerm(value)
                )
            */
        }
    }

    inferMethodCall(
        environment: Environment,
        expected: Type,
        signature: Signature,
        term: Term,
        record: Term,
        name: String
    ): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected") }
        let e2 = e.ECall(
            function = EVariable(e.at, name, [], [])
            arguments = [Argument(record.at, None, record), ...e.arguments]
        )
        self.inferFunctionCall(environment, expected, signature, e2, name)
    }

    inferFunctionCall(environment: Environment, expected: Type, signature: Signature, term: Term, name: String): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected") }
        // TODO: Constrain the type arguments
        let instantiation = self.inferTypeArguments(e.at, name, signature.generics, [])
        let instantiated = self.instantiateSignature(signature, instantiation)
        self.unification.unify(e.at, expected, instantiated.returnType)
        // TODO: Varargs
        let arguments = self.inferArguments(e.at, environment, instantiated.parameters, e.arguments)
        e.ECall(
            function = e.function, // It's always a function name - should we propagate that information?
            typeArguments = instantiation.map { _.second }
            arguments = arguments
        )
    }

    inferLambdaCall(environment: Environment, expected: Type, term: Term): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected") }
        let argumentTypes = e.arguments.map { self.unification.freshTypeVariable(_.at) }
        let arguments = e.arguments.zip(argumentTypes).map { | Pair(argument, t) =>
            argument.name.foreach { name =>
                fail(argument.at, "Named argument not allowed here: " + name)
            }
            argument.Argument(value = self.inferTerm(environment, t, argument.value))
        }
        let functionType = TConstructor(e.at, "Function$" + e.arguments.size, [...argumentTypes, expected])
        let function = self.inferTerm(environment, functionType, e.function)
        e.typeArguments.headOption.foreach { typeArgument =>
            fail(typeArgument.at, "Type arguments not allowed here")
        }
        e.ECall(
            function = function
            typeArguments = []
            arguments = arguments
        )
    }

    inferOperator(environment: Environment, expected: Type, operator: String, term: Term): Term {
        let e = term.{| ECall e => e | _ => fail(term.at, "Call expected") }
        e.arguments.{
            | [a1] {
                operator == "!"
            } =>
                let t = TConstructor(e.at, core("Bool"), [])
                let e1 = self.inferTerm(environment, t, a1.value)
                self.unification.unify(e.at, expected, t)
                e.ECall(arguments = [a1.Argument(value = e1)])
            | [a1] {
                operator == "-"
            } =>
                let t1 = self.unification.freshTypeVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                self.unification.substitute(t1).{
                    | TConstructor(_, name, []) {name == core("Float")} =>
                        self.unification.unify(e.at, expected, t1)
                    | TConstructor(_, name, []) {name == core("Int")} =>
                        self.unification.unify(e.at, expected, t1)
                    | _ =>
                        fail(e.at, "Operators on unknown types not currently supported")
                }
                e.ECall(arguments = [a1.Argument(value = e1)])
            | [a1, a2] {
                operator == "++"
            } =>
                let t = self.unification.freshTypeVariable(e.at)
                let e1 = self.inferTerm(environment, t, a1.value)
                let e2 = self.inferTerm(environment, t, a2.value)
                self.unification.unify(e.at, expected, t)
                let name = self.unification.substitute(t).{
                    | TConstructor(_, name, _) => name
                    | _ => fail(e.at, "Operators on unknown types not currently supported")
                }
                if(name != core("List") && name != core("Array") && name != core("Set") && name != core("Map")) {
                    fail(e.at, "Operator ++ not currently supported for " + name)
                }
                e.ECall(arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | [a1, a2] {
                operator == "||" || operator == "&&"
            } =>
                let t = TConstructor(e.at, core("Bool"), [])
                let e1 = self.inferTerm(environment, t, a1.value)
                let e2 = self.inferTerm(environment, t, a2.value)
                self.unification.unify(e.at, expected, t)
                e.ECall(arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | [a1, a2] {
                operator == "<" || operator == ">" ||
                operator == "<=" || operator == ">=" ||
                operator == "==" || operator == "!="
            } =>
                let t = TConstructor(e.at, core("Bool"), [])
                let t1 = self.unification.freshTypeVariable(e.at)
                let t2 = self.unification.freshTypeVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                let e2 = self.inferTerm(environment, t2, a2.value)
                let magic: Type => Option[String] = { t =>
                    self.unification.substitute(t).{
                        | TConstructor(_, name, []) {name == core("String")} => Some("String")
                        | TConstructor(_, name, []) {name == core("Float")} => Some("Float")
                        | TConstructor(_, name, []) {name == core("Int")} => Some("Int")
                        | _ => None
                    }
                }
                let chooseType: (Option[String], Option[String]) => Unit = {
                    | Some(_), _ =>
                        self.unification.unify(e.at, t1, t2)
                        self.unification.unify(e.at, expected, t)
                    | _, Some(_) =>
                        self.unification.unify(e.at, t2, t1)
                        self.unification.unify(e.at, expected, t)
                    | _, _ { operator == "==" || operator == "!=" } =>
                        // TODO: This case is cheating, remove it
                        self.unification.unify(e.at, t2, t1)
                        self.unification.unify(e.at, expected, t)
                    | None, None =>
                        fail(e.at, "Operators on unknown types not currently supported")
                }
                chooseType(magic(t1), magic(t2))
                e.ECall(arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | [a1, a2] {
                operator == "+" || operator == "-" ||
                operator == "*" || operator == "/" || operator == "%" ||
                operator == "^"
            } =>
                let t1 = self.unification.freshTypeVariable(e.at)
                let t2 = self.unification.freshTypeVariable(e.at)
                let e1 = self.inferTerm(environment, t1, a1.value)
                let e2 = self.inferTerm(environment, t2, a2.value)
                let magic: Type => Option[String] = { t =>
                    self.unification.substitute(t).{
                        | TConstructor(_, name, []) {name == core("Float")} => Some("Float")
                        | TConstructor(_, name, []) {name == core("Int")} => Some("Int")
                        | TConstructor(_, name, []) {operator == "+" && name == core("String")} => Some("String")
                        | _ => None
                    }
                }
                let chooseType: (Option[String], Option[String]) => Unit = {
                    | Some(n), Some(_) {n == "String"} => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some(n) {n == "String"} => self.unification.unify(e.at, expected, t2)
                    | Some(n), Some(_) {n == "Float"} => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some(n) {n == "Float"} => self.unification.unify(e.at, expected, t2)
                    | Some(n), Some(_) {n == "Int"} => self.unification.unify(e.at, expected, t1)
                    | Some(_), Some(n) {n == "Int"} => self.unification.unify(e.at, expected, t2)
                    | Some(_), None =>
                        self.unification.unify(e.at, t1, t2)
                        self.unification.unify(e.at, expected, t1)
                    | None, Some(_) =>
                        self.unification.unify(e.at, t2, t1)
                        self.unification.unify(e.at, expected, t2)
                    | None, None =>
                        fail(e.at, "Operators on unknown types not currently supported")
                }
                chooseType(magic(t1), magic(t2))
                e.ECall(arguments = [a1.Argument(value = e1), a2.Argument(value = e2)])
            | _ =>
                fail(e.at, "Unknown operator: " + operator)
        }
    }

    inferEtaExpansion(
        environment: Environment
        expected: Type
        at: Location
        signature: Signature
        term: Term
    ): Term {
        let parameters = signature.parameters.filter { _.default.getEmpty() }.map { p =>
            p.name
        }
        let body = ECall(at, term, [], parameters.map { x =>
            Argument(at, Some(x), EVariable(at, x, [], []))
        })
        let lambda = ELambda(at, Lambda(at, [MatchCase(
            at = at,
            patterns = parameters.map { PVariable(at, Some(_)) },
            condition = None,
            body = body
        )]))
        self.inferTerm(environment, expected, lambda)
    }

    instantiateSignature(
        signature: Signature,
        instantiation: List[Pair[String, Type]]
    ): Signature {
        let instantiationMap = instantiation.toMap
        let parameters = signature.parameters.map { p =>
            p.Parameter(valueType = self.unification.instantiate(instantiationMap, p.valueType))
        }
        let returnType = self.unification.instantiate(instantiationMap, signature.returnType)
        signature.Signature(
            generics = []
            constraints = [] // TODO: Emit the constraints
            parameters = parameters
            returnType = returnType
        )
    }

    inferTypeArguments(
        at: Location
        name: String
        generics: List[String],
        typeArguments: List[Type]
    ): List[Pair[String, Type]] {
        if(typeArguments.nonEmpty) {
            if(generics.size != typeArguments.size) {
                fail(at,
                    "Wrong number of type parameters for " + name +
                    ", expected " + generics.size +
                    ", got " + typeArguments.size
                )
            }
            generics.zip(typeArguments)
        } else {
            generics.map { name =>
                Pair(name, self.unification.freshTypeVariable(at))
            }
        }
    }

    inferArguments(
        at: Location
        environment: Environment
        parameters: List[Parameter]
        arguments: List[Argument]
    ): List[Argument] {
        mutable remainingArguments = arguments
        let newArguments = parameters.map { p =>
            let t = p.valueType
            remainingArguments.{
                | [] =>
                    p.default.map { e =>
                        let e2 = self.inferTerm(environment, t, e)
                        Argument(at, Some(p.name), e2)
                    }.else {
                        fail(at, "Missing argument: " + p.name)
                    }
                | [Argument(at, None, e), ...remaining] =>
                    remainingArguments = remaining.toList
                    let e2 = self.inferTerm(environment, t, e)
                    Argument(at, Some(p.name), e2)
                | remaining =>
                    remainingArguments.find { _.name.contains(p.name) }.map { | Argument(at, _, e) =>
                        remainingArguments = remainingArguments.filter { !_.name.contains(p.name) }
                        let e2 = self.inferTerm(environment, t, e)
                        Argument(at, Some(p.name), e2)
                    }.else {
                        fail(at, "Missing argument: " + p.name)
                    }
            }
        }
        remainingArguments.headOption.each {
            | Argument(at, None, _) => fail(at, "Too many arguments")
            | Argument(at, Some(name), _) => fail(at, "Unknown argument: " + name)
        }
        newArguments
    }

}
