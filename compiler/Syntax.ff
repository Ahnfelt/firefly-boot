type Location(file: String, line: Int, column: Int)
type CompileError(at: Location, message: String)

extend self: Location {
    show(): String {
        "in " + self.file + " " +
        "at line " + self.line +
        ", column " + self.column
    }
}

type Module(
    packagePair: Pair[String, String],
    file: String,
    dependencies: List[DDependency],
    imports: List[DImport],
    types: List[DType],
    traits: List[DTrait],
    instances: List[DInstance],
    extends: List[DExtend],
    lets: List[DLet],
    functions: List[DFunction],
)

type DDependency(
    at: Location,
    package: Pair[String, String],
    safety: Safety,
    goodVersions: List[Version],
    badVersions: List[Version]
)
type DImport(
    at: Location,
    alias: String,
    package: Pair[String, String],
    directory: List[String],
    file: String
)
type DFunction(
    at: Location,
    signature: Signature,
    body: Option[Target]
)
type DLet(
    at: Location,
    name: String,
    variableType: Type,
    value: Term
)
type DExtend(
    at: Location,
    name: String,
    generics: List[String],
    constraints: List[Constraint],
    type: Type,
    methods: List[DFunction],
)
type DType(
    at: Location
    newtype: Bool
    name: String
    generics: List[String]
    constraints: List[Constraint]
    commonFields: List[Parameter]
    variants: List[Variant]
)
type DTrait(
    at: Location,
    name: String,
    generics: List[String],
    constraints: List[Constraint],
    generatorParameters: List[Parameter],
    methods: List[Signature],
    methodDefaults: List[Pair[String, Lambda]],
    methodGenerators: List[Pair[String, Lambda]],
)
type DInstance(
    at: Location,
    generics: List[String],
    constraints: List[Constraint],
    traitName: String,
    typeArguments: List[Type],
    generatorArguments: List[Argument],
    methods: List[DFunction],
)

type Term(at: Location) {
    EString(value: String)
    EChar(value: String)
    EInt(value: String)
    EFloat(value: String)
    EVariable(name: String)
    ELambda(lambda: Lambda)
    EFunctions(functions: List[DFunction], body: Term)
    ELet(mutable: Bool, name: String, valueType: Type, value: Term, body: Term)
    ESequential(before: Term, after: Term)
    EAssign(operator: String, variable: String, value: Term)
    EAssignField(operator: String, record: Term, field: String, value: Term)
    EPipe(value: Term, function: Term)
    ECall(
        target: CallTarget
        effect: Type
        typeArguments: List[Type]
        arguments: List[Argument]
        dictionaries: List[Dictionary]
    )
    EList(elementType: Type, items: List[Pair[Term, Bool]])
    ECopy(name: String, record: Term, arguments: List[Field])
    EVariant(name: String, typeArguments: List[Type], arguments: Option[List[Argument]])
    EVariantIs(name: String, typeArguments: List[Type])
    ERecord(fields: List[Field])
    EField(newtype: Bool, record: Term, field: String)
    EWildcard(index: Int)
}

type CallTarget {
    DynamicCall(function: Term, tailCall: Bool)
    StaticCall(name: String, tailCall: Bool, instanceCall: Bool)
}

type MatchCase(
    at: Location,
    patterns: List[MatchPattern],
    guards : List[MatchGuard]
    body: Term
)

type MatchPattern(at: Location) {
    PString(value: String)
    PInt(value: String)
    PChar(value: String)
    PVariable(name: Option[String])
    PVariant(name: String, patterns: List[MatchPattern])
    PVariantAs(name: String, variable: Option[String])
    PAlias(pattern: MatchPattern, variable: String)
}

type MatchGuard(
    at: Location
    term: Term
    pattern: MatchPattern
)

type Dictionary(
    packageName: String
    moduleName: String
    traitName: String
    typeName: String
    dictionaries: List[Dictionary]
)

type Signature(
    at: Location
    name: String
    generics: List[String]
    constraints: List[Constraint]
    parameters: List[Parameter]
    returnType: Type
    effect: Type
)

type Lambda(at: Location, effect: Type, cases: List[MatchCase])

type Variant(at: Location, name: String, fields: List[Parameter])

type Parameter(at: Location, mutable: Bool, name: String, valueType: Type, default: Option[Term])

type Argument(at: Location, name: Option[String], value: Term)

type Field(at: Location, name: String, value: Term)

type Constraint(at: Location, name: String, generics: List[Type])

type Target {
    AnyTarget(code : TargetCode)
    SyncTarget(code : TargetCode)
    AsyncTarget(code : TargetCode)
    SyncAsyncTarget(sync : TargetCode, async : TargetCode)
}

type TargetCode {
    FireflyCode(code : Lambda)
    ForeignCode(code : String)
}

type Type(at: Location) {
    TConstructor(name: String, generics: List[Type])
    TVariable(index: Int)
}

type Safety {
    Safe
    Unsafe
    Trust
}

type Version(at: Location, major: Int, minor: Int, patch: Int)

extend self: Type {
    show(): String {
        self.{
            | TConstructor(at, name, generics) =>
                if(generics.isEmpty()) { name } else {
                    name + "[" + generics.map { _.show() }.join(", ") + "]"
                }
            | TVariable(at, index) =>
                "$" + index
        }
    }
}

extend self: Target {
    mapFirefly(f: Lambda => Lambda): Target {
        self.{
             | AnyTarget(code)  => AnyTarget(code.mapFirefly(f))
             | SyncTarget(code) => SyncTarget(code.mapFirefly(f))
             | AsyncTarget(code) => AsyncTarget(code.mapFirefly(f))
             | SyncAsyncTarget(sync, async) => SyncAsyncTarget(sync.mapFirefly(f), async.mapFirefly(f))
        }
    }
}

extend self: TargetCode {
    mapFirefly(f: Lambda => Lambda): TargetCode {
        self.{
            | FireflyCode(code) => FireflyCode(f(code))
            | foreignCode => foreignCode
        }
    }
}
