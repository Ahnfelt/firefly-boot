type Location(file: String, line: Int, column: Int)

Location_show(location: Location) {
    "in " + location.file + " " +
    "at line " + location.line +
    ", column " + location.column
}

type Module(
    file: String,
    imports: List[DImport],
    types: List[DType],
    traits: List[DTrait],
    instances: List[DInstance],
    lets: List[DLet],
    functions: List[DFunction],
)

type DImport(
    at: Location,
    alias: String,
    package: Option[Pair[String, String]],
    directory: List[String],
    file: String
)
type DFunction(
    at: Location,
    namespace: Option[String],
    signature: Signature,
    body: ELambda
)
type DLet(
    at: Location,
    namespace: Option[String],
    name: String,
    variableType: Type,
    value: Term
)
type DType(
    at: Location,
    name: String,
    generics: List[String],
    constraints: List[Constraint],
    commonFields: List[Parameter],
    variants: List[Variant]
)
type DTrait(
    at: Location,
    name: String,
    generics: List[String],
    constraints: List[Constraint],
    generatorParameters: List[Parameter],
    methods: List[Signature],
    methodDefaults: List[Pair[String, Term]],
    methodGenerators: List[Pair[String, Term]],
)
type DInstance(
    at: Location,
    generics: List[String],
    constraints: List[Constraint],
    traitType: Type,
    generatorArguments: List[Argument],
    methods: List[DFunction],
)

type Term(at: Location) {
    EString(value: String)
    EChar(value: String)
    EInt(value: String)
    EFloat(value: String)
    EVariable(name: String)
    ELambda(cases: List[MatchCase])
    EFunctions(functions: List[LocalFunction], body: Term)
    ELet(mutable: Boolean, name: String, valueType: Type, value: Term, body: Term)
    ESequential(before: Term, after: Term)
    EAssign(operator: String, variable: String, value: Term)
    EAssignField(operator: String, field: EField, value: Term)
    EPipe(value: Term, function: Term)
    ECall(function: Term, typeArguments: List[Type], arguments: List[Argument])
    EList(items: List[Term])
    ECopy(name: String, record: Term, arguments: List[Field])
    EVariant(name: String, typeArguments: List[Type], arguments: Option[List[Argument]])
    ERecord(fields: List[Field])
    EField(record: Term, field: String)
    EWildcard(index: Int)
}

type MatchCase(
    at: Location,
    patterns: List[MatchPattern],
    condition : Option[Term],
    body: Term
)

type MatchPattern(at: Location) {
    PVariable(name: Option[String])
    PVariant(name: String, patterns: List[MatchPattern])
    PVariantAs(name: String, variable: Option[String])
    PAlias(pattern: MatchPattern, variable: String)
}

type Signature(
    at: Location,
    name: String,
    generics: List[String],
    constraints: List[Constraint],
    parameters: List[Parameter],
    returnType: Type
)

type LocalFunction(signature: Signature, body: ELambda)

type Variant(at: Location, name: String, fields: List[Parameter])

type Parameter(at: Location, mutable: Boolean, name: String, valueType: Type, default: Option[Term])

type Argument(at: Location, name: Option[String], value: Term)

type Field(at: Location, name: String, value: Term)

type Constraint(representation: Type)

type Type(at: Location, name: String, generics: List[Type])
