import Syntax

type Substitution(mutable substitution: Map[Int, Type])

core(name: String): String {
    "ff:core/" + name + "." + name
}

extend self: Substitution {

    substituteModule(module: Module): Module {
        let lets = module.lets.map { self.substituteLetDefinition(_) }
        let functions = module.functions.map { self.substituteFunctionDefinition(_) }
        let extends = module.extends.map { self.substituteExtendDefinition(_) }
        //let traits = module.traits.map { self.substituteTraitDefinition(_) }
        let instances = module.instances.map { self.substituteInstanceDefinition(_) }
        Module(...module,
            //traits = traits,
            instances = instances,
            extends = extends,
            lets = lets,
            functions = functions,
        )
    }

    substituteLetDefinition(definition: DLet): DLet {
        DLet(...definition,
            variableType = self.substituteType(definition.variableType)
            value = self.substituteTerm(definition.value)
        )
    }

    substituteExtendDefinition(definition: DExtend): DExtend {
        DExtend(...definition,
            methods = definition.methods.map { self.substituteFunctionDefinition(_) }
        )
    }

    substituteFunctionDefinition(definition: DFunction): DFunction {
        DFunction(...definition,
            body = self.substituteLambda(definition.body)
        )
    }

    substituteInstanceDefinition(definition: DInstance): DInstance {
        DInstance(...definition,
            methods = definition.methods.map { self.substituteFunctionDefinition(_) }
        )
    }

    substituteLambda(definition: Lambda): Lambda {
        Lambda(...definition,
            cases = definition.cases.map { case =>
                MatchCase(...case,
                    condition = case.condition.map(self.substituteTerm)
                    body = self.substituteTerm(case.body)
                )
            }
        )
    }

    substituteTerm(term: Term): Term {
        term.{
            | EString _ => term
            | EChar _ => term
            | EInt _ => term
            | EFloat _ => term
            | EVariable _ => term
            | EField e => EField(...e, record = self.substituteTerm(e.record))
            | EWildcard e => term
            | EList e => EList(...e,
                elementType = self.substituteType(e.elementType)
                items = e.items.map {| Pair(item, b) => Pair(self.substituteTerm(item), b) }
            )
            | ESequential e => ESequential(...e,
                before = self.substituteTerm(e.before)
                after = self.substituteTerm(e.after)
            )
            | ELet e => ELet(...e,
                valueType = self.substituteType(e.valueType)
                value = self.substituteTerm(e.value)
                body = self.substituteTerm(e.body)
            )
            | ELambda e => ELambda(...e, lambda = self.substituteLambda(e.lambda))
            | EVariant e => EVariant(...e,
                typeArguments = e.typeArguments.map(self.substituteType)
                arguments = e.arguments.map { _.map(self.substituteArgument) }
            )
            | EVariantIs e => EVariantIs(...e,
                typeArguments = e.typeArguments.map(self.substituteType)
            )
            | ECopy e => ECopy(...e,
                record = self.substituteTerm(e.record)
                arguments = e.arguments.map(self.substituteField)
            )
            | EPipe e => EPipe(...e,
                value = self.substituteTerm(e.value)
                function = self.substituteTerm(e.function)
            )
            | ECall e => ECall(...e,
                function = self.substituteTerm(e.function)
                typeArguments = e.typeArguments.map(self.substituteType)
                arguments = e.arguments.map(self.substituteArgument)
            )
            | ERecord e => ERecord(...e, fields = e.fields.map(self.substituteField))
            | EFunctions e => EFunctions(...e,
                functions = e.functions.map(self.substituteFunctionDefinition)
                body = self.substituteTerm(e.body)
            )
            | EAssign e => EAssign(...e, value = self.substituteTerm(e.value))
            | EAssignField e => EAssignField(...e,
                record = self.substituteTerm(e.record)
                value = self.substituteTerm(e.value)
            )
        }
    }

    substituteArgument(argument: Argument): Argument {
        Argument(...argument, value = self.substituteTerm(argument.value))
    }

    substituteField(field: Field): Field {
        Field(...field, value = self.substituteTerm(field.value))
    }

    substituteType(type: Type): Type {
        | TVariable(at, i) =>
            if(self.has(i)) { self.substituteType(self.get(i)) } else { TConstructor(at, core("Nothing"), []) }
        | TConstructor t =>
            TConstructor(...t, generics = t.generics.map { t => self.substituteType(t) })
    }

    get(index: Int): Type {
        self.substitution.expect(index).{
            | TVariable(_, i) { self.has(i) } =>
                let t = self.get(i)
                self.substitution = self.substitution.add(index, t)
                t
            | TVariable(at, _) =>
                TConstructor(at, core("Nothing"), [])
            | t => t
        }
    }

    has(index: Int): Bool {
        self.substitution.contains(index)
    }

}
