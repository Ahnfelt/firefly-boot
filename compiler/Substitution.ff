import Syntax

type Substitution(mutable substitution: Map[Int, Type])

extend self: Substitution {

    substituteModule(module: Module): Module {
        let lets = module.lets.map { self.substituteLetDefinition(_) }
        let functions = module.functions.map { self.substituteFunctionDefinition(_) }
        let extends = module.extends.map { self.substituteExtendDefinition(_) }
        //let traits = module.traits.map { self.substituteTraitDefinition(_) }
        //let instances = module.instances.map { self.substituteInstanceDefinition(_) }
        module.Module(
            //traits = traits,
            //instances = instances,
            extends = extends,
            lets = lets,
            functions = functions,
        )
    }

    substituteLetDefinition(definition: DLet): DLet {
        definition.DLet(
            variableType = self.substituteType(definition.variableType)
            value = self.substituteTerm(definition.value)
        )
    }

    substituteExtendDefinition(definition: DExtend): DExtend {
        definition.DExtend(
            methods = definition.methods.map { self.substituteFunctionDefinition(_) }
        )
    }

    substituteFunctionDefinition(definition: DFunction): DFunction {
        definition.DFunction(
            body = self.substituteLambda(definition.body)
        )
    }

    substituteLambda(definition: Lambda): Lambda {
        definition.Lambda(
            cases = definition.cases.map { case =>
                case.MatchCase(
                    condition = case.condition.map(self.substituteTerm)
                    body = self.substituteTerm(case.body)
                )
            }
        )
    }

    substituteTerm(term: Term): Term {
        term.{
            | EString _ => term
            | EChar _ => term
            | EInt _ => term
            | EFloat _ => term
            | EVariable e => term // TODO
            | EField e => term // TODO
            | EWildcard e => term // TODO
            | EList e => term // TODO
            | ESequential e => term // TODO
            | ELet e => term // TODO
            | ELambda e => term // TODO
            | EVariant e => term // TODO
            | EVariantIs e => term // TODO
            | ECopy e => term // TODO
            | EPipe e => term // TODO
            | ECall e => term // TODO
            | ERecord e => term // TODO
            | EFunctions e => term // TODO
            | EAssign e => term // TODO
            | EAssignField e => term // TODO
        }
    }

    substituteType(type: Type): Type {
        | TVariable(_, i) => if(self.has(i)) { self.substituteType(self.get(i)) } else { type }
        | TConstructor t => t.TConstructor(generics = t.generics.map { t => self.substituteType(t) })
    }

    get(index: Int): Type {
        self.substitution.expect(index).{
            | TVariable(_, i) { self.has(i) } =>
                let t = self.get(i)
                self.substitution = self.substitution.add(index, t)
                t
            | t => t
        }
    }

    has(index: Int): Bool {
        self.substitution.contains(index)
    }

}
