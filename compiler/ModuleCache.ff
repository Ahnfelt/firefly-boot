import Syntax

class ModuleCache(
    mutable parsedModules: Map[String, Module]
    mutable resolvedModules: Map[String, Module]
    mutable derivedModules: Map[String, Module]
    mutable inferredModules: Map[String, Module]
    mutable emittedModules: Set[String]
)

empty(): ModuleCache {
    ModuleCache(
        parsedModules = Map.empty()
        resolvedModules = Map.empty()
        derivedModules = Map.empty()
        inferredModules = Map.empty()
        emittedModules = Set.empty()
    )
}

extend self: ModuleCache {
    
    without[R](path: Path, when: Bool, body: ModuleCache => R): R {
        if(when) {
            let key = path.absolute()
            let newCache = if(path.isFile()) {
                self.ModuleCache(
                    parsedModules = self.parsedModules.remove(key)
                    resolvedModules = self.resolvedModules.remove(key)
                    derivedModules = self.derivedModules.remove(key)
                    inferredModules = self.inferredModules.remove(key)
                    emittedModules = self.emittedModules.remove(key)
                )
            } else {
                function invalidated(p: String): Bool {
                    p.startsWith(key) && !p.contains(".firefly/dependencies") && !p.contains(".firefly\\dependencies")
                }
                self.ModuleCache(
                    parsedModules = self.parsedModules.toList().filter {| Pair(p, _) => !invalidated(p)}.toMap()
                    resolvedModules = self.resolvedModules.toList().filter {| Pair(p, _) => !invalidated(p)}.toMap()
                    derivedModules = self.derivedModules.toList().filter {| Pair(p, _) => !invalidated(p)}.toMap()
                    inferredModules = self.inferredModules.toList().filter {| Pair(p, _) => !invalidated(p)}.toMap()
                    emittedModules = self.emittedModules.toList().filter {p => !invalidated(p)}.toSet()
                )
            }
            body(newCache)
        } else {
            body(self)
        }
    }
    
    cacheParsedModule(
        packagePaths: Map[PackagePair, Path]
        packagePair: PackagePair
        moduleName: String
        body: Path => Module
    ): Module {
        let path = modulePath(packagePaths, packagePair, moduleName)
        self.parsedModules.get(path.absolute()).else:
        let result = body(path)
        self.parsedModules = self.parsedModules.add(path.absolute(), result)
        result
    }
    
    cacheResolvedModule(
        packagePaths: Map[PackagePair, Path]
        packagePair: PackagePair
        moduleName: String
        body: Path => Module
    ): Module {
        let path = modulePath(packagePaths, packagePair, moduleName)
        self.resolvedModules.get(path.absolute()).else:
        let result = body(path)
        self.resolvedModules = self.resolvedModules.add(path.absolute(), result)
        result
    }
        
    cacheDerivedModule(
        packagePaths: Map[PackagePair, Path]
        packagePair: PackagePair
        moduleName: String
        body: Path => Module
    ): Module {
        let path = modulePath(packagePaths, packagePair, moduleName)
        self.derivedModules.get(path.absolute()).else:
        let result = body(path)
        self.derivedModules = self.derivedModules.add(path.absolute(), result)
        result
    }
        
    cacheInferredModule(
        packagePaths: Map[PackagePair, Path]
        packagePair: PackagePair
        moduleName: String
        body: Path => Module
    ): Module {
        let path = modulePath(packagePaths, packagePair, moduleName)
        self.inferredModules.get(path.absolute()).else:
        let result = body(path)
        self.inferredModules = self.inferredModules.add(path.absolute(), result)
        result
    }
 
    cacheEmittedModule(
        packagePaths: Map[PackagePair, Path]
        packagePair: PackagePair
        moduleName: String
        body: Path => Unit
    ): Unit {
        let path = modulePath(packagePaths, packagePair, moduleName)
        if(!self.emittedModules.contains(path.absolute())):
        self.emittedModules = self.emittedModules.add(path.absolute())
        try {
            body(path)
        } catchAny {error =>
            self.emittedModules = self.emittedModules.remove(path.absolute())
            error.rethrow()
        } grab()
    }
    
}

modulePath(
    packagePaths: Map[PackagePair, Path]
    packagePair: PackagePair
    moduleName: String
): Path {
    let packagePath = packagePaths.get(packagePair).else {
        panic("Internal error - package path missing: " + packagePair.groupName())
    }
    let file = moduleName + ".ff"
    packagePath.slash(file)
}