import Syntax
import JsEmitter from ff:compiler

class ModuleCache(
    version: Int
    mutable parsedModules: Map[String, Pair[Module, Int]]
    mutable resolvedModules: Map[String, Pair[Module, Int]]
    mutable derivedModules: Map[String, Pair[Module, Int]]
    mutable inferredModules: Map[String, Pair[Module, Int]]
    mutable emittedModules: Map[EmitTarget, Map[String, Int]]
)

new(version: Int): ModuleCache {
    ModuleCache(
        version = version
        parsedModules = Map.new()
        resolvedModules = Map.new()
        derivedModules = Map.new()
        inferredModules = Map.new()
        emittedModules = Map.new()
    )
}

extend self: ModuleCache {
    
    remove(keys: List[String], removeParsed: Bool = True) {
        if(!keys.isEmpty()):
        if(removeParsed) {
            self.parsedModules = self.parsedModules.removeList(keys)
        }
        self.resolvedModules = self.resolvedModules.removeList(keys)
        self.derivedModules = self.derivedModules.removeList(keys)
        self.inferredModules = self.inferredModules.removeList(keys)
        self.emittedModules = self.emittedModules.mapValues {_, v => v.removeList(keys)}
    }
    
    invalidate(key: String) {
        self.parsedModules.get(key).each: | Pair(module, _) =>
        self.remove([key])
        self.parsedModules.each {| k, Pair(m, _) =>
            if(m.imports.any {i => i.moduleKey == module.moduleKey}) {
                self.remove([k], removeParsed = False)
            }
        }
    }
    
    filesNotImporting(moduleKey: ModuleKey): List[String] {
        self.parsedModules.toList().collect {| Pair(k, Pair(m, _)) =>
            if(!m.imports.any {i => i.moduleKey == moduleKey}): k
        }
    }
    
    without(newVersion: Int, path: Path): ModuleCache {
        let key = path.absolute()
        if(path.isFile()) {
            self.ModuleCache(
                version = newVersion
                parsedModules = self.parsedModules.remove(key)
                resolvedModules = self.resolvedModules.remove(key)
                derivedModules = self.derivedModules.remove(key)
                inferredModules = self.inferredModules.remove(key)
                emittedModules = self.emittedModules.mapValues {_, v => v.remove(key)}
            )
        } else {
            function invalidated(p: String): Bool {
                p.startsWith(key) && !p.contains(".firefly/dependencies") && !p.contains(".firefly\\dependencies")
            }
            self.ModuleCache(
                version = newVersion
                parsedModules = self.parsedModules.toList().filter {| Pair(p, _) => !invalidated(p)}.toMap()
                resolvedModules = self.resolvedModules.toList().filter {| Pair(p, _) => !invalidated(p)}.toMap()
                derivedModules = self.derivedModules.toList().filter {| Pair(p, _) => !invalidated(p)}.toMap()
                inferredModules = self.inferredModules.toList().filter {| Pair(p, _) => !invalidated(p)}.toMap()
                emittedModules = self.emittedModules.mapValues {_, v => 
                    v.toList().filter {| Pair(p, _) => !invalidated(p)}.toMap()
                }
            )
        }
    }
    
    mergeVersions(cache: ModuleCache): Unit {
        self.parsedModules = mergeVersionedMap(self.parsedModules, cache.parsedModules) {_.second}
        self.resolvedModules = mergeVersionedMap(self.resolvedModules, cache.resolvedModules) {_.second}
        self.derivedModules = mergeVersionedMap(self.derivedModules, cache.derivedModules) {_.second}
        self.inferredModules = mergeVersionedMap(self.inferredModules, cache.inferredModules) {_.second}
        let targets = self.emittedModules.keys().addAll(cache.emittedModules.keys()).toList()
        self.emittedModules = targets.map {target =>
            let emittedModules = Pair(self.emittedModules.get(target), cache.emittedModules.get(target)).{
                | Pair(Some(a), Some(b)) => mergeVersionedMap(a, b) {_}
                | Pair(Some(a), None) => a
                | Pair(None, Some(b)) => b
                | Pair(None, None) => Map.new()
            }
            Pair(target, emittedModules)
        }.toMap()
    }
    
    cacheParsedModule(
        packagePaths: Map[PackagePair, Path]
        moduleKey: ModuleKey
        body: Path => Module
    ): Module {
        let path = modulePath(packagePaths, moduleKey)
        self.parsedModules.get(path.absolute()).map {_.first}.else:
        let result = body(path)
        self.parsedModules = self.parsedModules.add(path.absolute(), Pair(result, self.version))
        result
    }
    
    cacheResolvedModule(
        packagePaths: Map[PackagePair, Path]
        moduleKey: ModuleKey
        body: Path => Module
    ): Module {
        let path = modulePath(packagePaths, moduleKey)
        self.resolvedModules.get(path.absolute()).map {_.first}.else:
        let result = body(path)
        self.resolvedModules = self.resolvedModules.add(path.absolute(), Pair(result, self.version))
        result
    }

    cacheDerivedModule(
        packagePaths: Map[PackagePair, Path]
        moduleKey: ModuleKey
        body: Path => Module
    ): Module {
        let path = modulePath(packagePaths, moduleKey)
        self.derivedModules.get(path.absolute()).map {_.first}.else:
        let result = body(path)
        self.derivedModules = self.derivedModules.add(path.absolute(), Pair(result, self.version))
        result
    }
        
    cacheInferredModule(
        packagePaths: Map[PackagePair, Path]
        moduleKey: ModuleKey
        body: Path => Module
    ): Module {
        let path = modulePath(packagePaths, moduleKey)
        self.inferredModules.get(path.absolute()).map {_.first}.else:
        let result = body(path)
        self.inferredModules = self.inferredModules.add(path.absolute(), Pair(result, self.version))
        result
    }
 
    cacheEmittedModule(
        packagePaths: Map[PackagePair, Path]
        moduleKey: ModuleKey
        emitTarget: EmitTarget
        isMainModule: Bool
        body: Path => Unit
    ): Unit {
        let path = modulePath(packagePaths, moduleKey)
        mutable targetEmittedModules = self.emittedModules.get(emitTarget).else {Map.new()}
        if(isMainModule || !targetEmittedModules.contains(path.absolute())):
        // Log.debug("cacheEmittedModule " + Show.show(emitTarget) + " " + Show.show(moduleKey))
        targetEmittedModules = targetEmittedModules.add(path.absolute(), self.version)
        self.emittedModules = self.emittedModules.add(emitTarget, targetEmittedModules)
        try {
            body(path)
        } catchAny {error =>
            mutable targetEmittedModules2 = self.emittedModules.get(emitTarget).else {Map.new()}
            targetEmittedModules2 = targetEmittedModules2.remove(path.absolute())
            self.emittedModules = self.emittedModules.add(emitTarget, targetEmittedModules2)
            error.rethrow()
        }
    }
    
}

mergeVersionedMap[T](oldMap: Map[String, T], newMap: Map[String, T], getVersion: T => Int): Map[String, T] {
    mutable result = newMap
    oldMap.each {k, v =>
        if(!newMap.get(k).any {getVersion(_) >= getVersion(v)}) {
            result = result.add(k, v)
        }
    }
    result
}

modulePath(
    packagePaths: Map[PackagePair, Path]
    moduleKey: ModuleKey
): Path {
    let packagePath = packagePaths.get(moduleKey.packagePair).else {
        panic("Internal error - package path missing: " + moduleKey.packagePair.groupName())
    }
    moduleKey.path(packagePath)
}
