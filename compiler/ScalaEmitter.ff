import Syntax

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

emitModule(packagePair: Pair[String, String], module: Module): String {
    let moduleNamespace =
        module.file.replace("\\", "/").getReverse().takeWhile { _ != '/' }.getReverse().takeWhile { _ != '.' }
    let modulePrefix =
        module.packagePair.first + ":" + module.packagePair.second + "/" +
        module.file.dropLast(3) + "."
    let package = packagePair.first + "." + packagePair.second
    let parts = [
        ["package " + package]
        module.imports.sortBy{i => i.package.first + "." + i.package.second + "." + i.file}.map { i =>
            "import " + i.package.first + "." + i.package.second + "." + i.file + "_._"
        }
        ["object " + moduleNamespace + "_ {"]
        if(module.functions.any { _.signature.name == "main" }) { [emitMain()] } else { [] }
        module.types.map(emitTypeDefinition)
        module.lets.map { emitLetDefinition(_) }
        module.functions.map { emitFunctionDefinition(_) }
        module.extends.map { emitExtendsDefinition(_) }
        module.traits.map(emitTraitDefinition)
        module.instances.map(emitInstanceDefinition)
        ["}"]
    ]
    module.extends.map { _.type }.getCollect(TConstructor?).find { t =>
        !module.types.any { (modulePrefix + _.name) == t.name }
    }.each { t =>
        fail(t.at, "Type not defined in this file: " + t.name)
    }
    parts.map { _.join("\n\n") }.join("\n") + "\n"
}

emitMain(): String {
    "def main(arguments : scala.Array[String]) : Unit = main_(ff.core.System_.SystemArguments(List_getArray(arguments.toList)))"
}

emitTypeMembers(name: String, lets: List[DLet], functions: List[DFunction]): String {
    let strings =
        lets.map { emitLetDefinition(_) } ++
        functions.map { emitFunctionDefinition(_) }
    "object " + name + " {\n\n" + strings.join("\n\n") + "\n\n}"
}

emitTypeDefinition(definition: DType): String {
    let generics = emitTypeParameters(definition.generics)
    if(
        definition.targets.scala.getEmpty() &&
        definition.variants.getSize() == 1 &&
        definition.variants.expectFirst().name == definition.name
    ) {
        let fields = "(" + definition.commonFields.map(emitParameter).join(", ") + ")"
        "case class " + definition.name + generics + fields
    } else {
        let variants = definition.variants.map { emitVariantDefinition(definition, _) }
        let head = definition.targets.scala.map { code =>
            if(code.startsWith("#")) {
                code.dropFirst() + ";\n"
            } else {
                "type " + definition.name + generics + " = " + code + ";\n"
            }
        }.else {
            let commonFields = if(definition.commonFields.getEmpty()) {""} else {
                " {\n" + definition.commonFields.map(emitParameter).map { "    val " + _ + "\n" }.join() + "}"
            }
            "sealed abstract class " + definition.name + generics + " extends Product with Serializable" + commonFields
        }
        head + variants.map { "\n" + _ }.join()
    }
}

emitLetDefinition(definition: DLet, mutable: Bool = False): String {
    let typeAnnotation = emitTypeAnnotation(definition.variableType)
    let mutability = if(mutable) {"var"} else {"val"}
    let valueCode = definition.targets.scala.else { emitTerm(definition.value) }
    mutability + " " + escapeKeyword(definition.name) + typeAnnotation + " = " + valueCode
}

emitFunctionDefinition(definition: DFunction, suffix: String = ""): String {
    let signature = emitSignature(definition.signature, suffix)
    definition.targets.scala.map { code =>
        if(code.startsWith("#")) {
            code.dropFirst()
        } else {
            signature + " = {\n" + code + "\n}"
        }
    }.else:
    definition.body.{
        | Lambda(_, [matchCase]) {
            matchCase.patterns.all {| PVariable(_, None) => True | _ => False }
        } =>
            let body = emitStatements(matchCase.body)
            signature + " = {\n" + body + "\n}"
        | _ =>
            let tuple = "(" + definition.signature.parameters.map { escapeKeyword(_.name) }.join(", ") + ")"
            let cases = definition.body.cases.map(emitCase).join("\n")
            signature + " = " + tuple + " match {\n" + cases + "\n}"
    }
}

emitExtendsDefinition(definition: DExtend): String {
    let typeName = extractTypeName(definition.type).getReverse().takeWhile { _ != '.' }.getReverse()
    let methods = definition.methods.map { method =>
        method.DFunction(
            signature = method.signature.Signature(
                name = typeName + "_" + method.signature.name
            )
        )
    }
    methods.map { emitFunctionDefinition(_) }.join("\n\n")
}

emitTraitDefinition(definition: DTrait): String {
    let generics = emitTypeParameters(definition.generics)
    let implicits = emitConstraints(definition.constraints)
    let parameters = if(definition.generatorParameters.getEmpty()) {""} else {
        "(" + definition.generatorParameters.map(emitParameter).join(", ") + ")"
    }
    let methods = if(definition.methods.getEmpty()) {""} else {
        " {\n\nimport " + definition.name + "._\n\n" +
        definition.methods.map { signature =>
            let body = definition.methodDefaults.find { _.first == signature.name }.map {| Pair(_, lambda) =>
                " {\n" + emitStatements(ELambda(lambda.at, lambda)) + "\n}"
            }.getElse {definition.methodGenerators.find { _.first == signature.name }.map {| Pair(_, e) =>
                " {\n// TODO: Generate\n}"
            }}.else {
                ""
            }
            emitSignature(signature, "_m") + body
        }.join("\n\n") + "\n\n}"
    }
    let methodWrappers = if(definition.methods.getEmpty()) {""} else {
        " \n\n" + definition.methods.map { signature =>
            let t = TConstructor(definition.at, definition.name, definition.generics.map {
                TConstructor(definition.at, _, [])
            })
            emitSignature(signature.Signature(
                generics = definition.generics ++ signature.generics,
                constraints = [Constraint(t), ...definition.constraints, ...signature.constraints]
            )) + " =\n    scala.Predef.implicitly[" + emitType(t) + "]." + escapeKeyword(signature.name) +
            "_m(" + signature.parameters.map { _.name }.map(escapeKeyword).join(", ") + ")"
        }.join("\n\n") + "\n\n"
    }
    "abstract class " + definition.name + generics + parameters + implicits + methods + "\n" +
    "object " + definition.name + " {" + methodWrappers + "}"
}

emitInstanceDefinition(definition: DInstance): String {
    let signature = emitSignature(Signature(
        definition.at,
        extractTypeName(definition.traitType) + "_" + magicHashCode(definition).abs(),
        definition.generics,
        definition.constraints,
        [],
        definition.traitType
    ))
    let methods = " {\n\nimport " + extractTypeName(definition.traitType) + "._\n\n" +
        definition.methods.map { emitFunctionDefinition(_, "_m") }.join("\n\n") + "\n\n}"
    let value = "new " + emitType(definition.traitType) + methods
    "implicit " + signature + " =\n    " + value
}

emitVariantDefinition(typeDefinition: DType, definition: Variant): String {
    let generics = emitTypeParameters(typeDefinition.generics)
    let allFields = typeDefinition.commonFields ++ definition.fields
    let fields = "(" + allFields.map(emitParameter).join(", ") + ")"
    definition.targets.scala.map { originalCode =>
        let code = if(originalCode == "scala.Unit") {"{}"} else {originalCode}
        "object " + definition.name + " {\n" +
        "def apply" + generics + fields + " = " +
        code + (if(fields != "()") { fields } else { "" }) + ";\n" +
        "def unapply" + generics + "(value : " + typeDefinition.name + generics + ") = " +
        (if(fields != "()") {
            "scala.Some(value).collectFirst { case " + code + fields + " => " + fields + " };\n"
        } else {
            "value == " + code + ";\n"
        }) +
        "}"
    }.else {
        "case class " + definition.name + generics + fields + " extends " + typeDefinition.name + generics
    }
}

emitSignature(signature: Signature, suffix: String = ""): String {
    let generics = emitTypeParameters(signature.generics)
    let parameters = "(" + signature.parameters.map(emitParameter).join(", ") + ")"
    let implicits = if(signature.constraints.getEmpty()) {""} else {
        "(implicit " + signature.constraints.pairs().map {| Pair(i, c) =>
            "i_" + i + " : " + emitType(c.representation)
        }.join(", ") + ")"
    }
    let returnType = emitTypeAnnotation(signature.returnType)
    "def " + escapeKeyword(signature.name) + suffix + generics + parameters + implicits + returnType
}

emitParameter(parameter: Parameter): String {
    let mutability = if(parameter.mutable) {"var "} else {""}
    let defaultValue = parameter.default.map { " = " + emitTerm(_) }.else{""}
    mutability + escapeKeyword(parameter.name) + emitTypeAnnotation(parameter.valueType) + defaultValue
}

emitConstraints(constraints: List[Constraint]): String {
    if(constraints.getEmpty()) {""} else:
    let pairs = constraints.map { _.representation }.map(emitType).pairs()
    "(implicit " + pairs.map {| Pair(k, v) => "i_" + k + " : " + v }.join(", ") + ")"
}

emitTypeParameters(generics: List[String]): String {
    if(generics.getEmpty()) {""} else {"[" + generics.join(", ") + "]"}
}

emitTypeAnnotation(t: Type): String {
    | TVariable _ => ""
    | TConstructor _ => " : " + emitType(t)
}

emitType(type: Type): String {
    | TVariable(_, index) =>
        "$" + index
    | TConstructor t =>
        if(t.name.startsWith("Function$")) {
            emitType(t.TConstructor(name = t.name.replace("$", "")))
        } elseIf {t.name.startsWith("Record$")} {
            "{" + t.name.split('$').dropFirst(1).getList().zip(t.generics).map {| Pair(field, fieldType) =>
                "val " + escapeKeyword(field) + " : " + emitType(fieldType)
            }.join("; ") + "}"
        } else {
            let generics = if(t.generics.getEmpty()) {""} else {"[" + t.generics.map(emitType).join(", ") + "]"}
            escapeResolved(t.name) + generics
        }
}

emitStatements(term: Term): String {
    | EFunctions(at, functions, body) =>
        let functionStrings = functions.map { f =>
            emitFunctionDefinition(DFunction(at, f.signature, f.body, Targets(None, None)))
        }
        functionStrings.join("\n") + "\n" + emitStatements(body)
    | ELet(at, mutable, name, valueType, value, body) =>
        emitLetDefinition(DLet(at, name, valueType, value, Targets(None, None)), mutable) + ";\n" + emitStatements(body)
    | ESequential(at, before, after) =>
        emitStatements(before) + ";\n" + emitStatements(after)
    | EAssign(at, operator, name, value) =>
        escapeKeyword(name) + " " + operator + "= " + emitTerm(value)
    | EAssignField(at, operator, record, field, value) =>
        emitTerm(record) + "." + escapeKeyword(field) + " " + operator + "= " + emitTerm(value)
    | _ => emitTerm(term)
}

emitTerm(term: Term): String {
    | EString(at, value) => value
    | EChar(at, value) => value
    | EInt(at, value) => value
    | EFloat(at, value) => value
    | EVariable(at, name, _, _) => escapeResolved(name)
    | EList(at, _, items) { items.all { !_.second } } =>
        "List(" + items.map { emitTerm(_.first) }.join(", ") + ")"
    | EList(at, _, items) =>
        "(List(" + items.map {
            | Pair(item, False) => "List(" + emitTerm(item) + ")"
            | Pair(item, True) => emitTerm(item)
        }.join(", ") + ").flatten)"
    | EVariant(at, name, typeArguments, arguments) =>
        let generics = if(typeArguments.getEmpty()) {""} else {"[" + typeArguments.map(emitType).join(", ") + "]"}
        escapeResolved(name) + generics + "(" + arguments.getList().getFlatten().map(emitArgument).join(", ") + ")"
    | EVariantIs(at, name, typeArguments) =>
        let generics = if(typeArguments.getEmpty()) {""} else {"[" + typeArguments.map(emitType).join(", ") + "]"}
        "({ case _w : " + escapeResolved(name) + generics + " => Some(_w); case _ => None() })"
    | ECopy(at, name, record, fields) =>
        let fieldCode = fields.map { f => escapeKeyword(f.name) + " = " + emitTerm(f.value) }.join(", ")
        emitTerm(record) + ".copy(" + fieldCode + ")"
    | EField(at, record, field) =>
        emitTerm(record) + "." + escapeKeyword(field)
    | ELambda(at, Lambda(_, [MatchCase(_, patterns, None, body)])) {
        patterns.all {| PVariable _ => True | _ => False }
    } =>
        let parameters =
            patterns.map {| PVariable p => p.name.map(escapeKeyword).else{"_"} | _ => panic("!") }.join(", ")
        "{(" + parameters + ") =>\n" + emitStatements(body) + "\n}"
    | ELambda(at, Lambda(_, cases)) =>
        let casesString = cases.map(emitCase).join("\n")
        "{\n" + casesString + "\n}"
    | EPipe(at, value, function) =>
        "pipe_dot(" + emitTerm(value) + ")(" + emitTerm(function) + ")"
    | ECall(at, _, EVariable(_, operator, _, _), [], [value]) {!operator.expectFirst().isAsciiLetter()} =>
        "(" + operator + emitArgument(value) + ")"
    | ECall(at, _, EVariable(_, operator, _, _), [], [left, right]) {!operator.expectFirst().isAsciiLetter()} =>
        "(" + emitArgument(left) + " " + operator + " " + emitArgument(right) + ")"
    | ECall(at, _, EVariable(_, name, _, _)@function, _, arguments) {
        // Hack to support funky Scala FFI for options
        name == "ff:core/Option.Option_else" ||
        name == "ff:core/Option.Option_elseIf" ||
        name == "ff:core/Option.Option_getElse"
    } =>
        emitTerm(function) + "(" + arguments.map(emitArgument).join(", ") + ")"
    | ECall(at, _, function, typeArguments, arguments) =>
        let generics = if(typeArguments.getEmpty()) {""} else {"[" + typeArguments.map(emitType).join(", ") + "]"}
        emitTerm(function) + generics + "(" + arguments.map(emitArgument).join(", ") + ")"
    | ERecord(at, fields) =>
        if(fields.getEmpty()) {"{}"} else {
            let list = fields.map { f => "val " + escapeKeyword(f.name) + " = " + emitTerm(f.value) }
            "new {\n" + list.join(";\n") + ";\n}"
        }
    | EWildcard(at, index) =>
        if(index == 0) {fail(at, "Unbound wildcard")}
        "_w" + index
    | _ =>
        "{\n" + emitStatements(term) + "\n}"
}

emitArgument(argument: Argument): String {
    argument.name.map { name => escapeKeyword(name) + " = " }.else{""} + emitTerm(argument.value)
}

emitCase(matchCase: MatchCase): String {
    let pair = matchCase.patterns.map(emitPattern).getUnzip()
    let patterns = pair.first.join(", ")
    let condition = matchCase.condition.map { "if " + emitTerm(_) + " " }.else{""}
    let toLists = pair.second.getFlatten().join()
    "case (" + patterns + ") " + condition + "=>\n" + toLists + emitStatements(matchCase.body)
}

emitPattern(pattern: MatchPattern): Pair[String, List[String]] {
    | PVariable(at, name) =>
        Pair(name.map(escapeKeyword).else{"_"}, [])
    | PVariant(at, name, patterns) =>
        let pairs = patterns.map(emitPattern)
        Pair(escapeResolved(name) + "(" + pairs.map{_.first}.join(", ") + ")", pairs.flatMap{_.second})
    | PVariantAs(at, name, variable) =>
        Pair(variable.map(escapeKeyword).else{"_"} + " : " + escapeResolved(name), [])
    | PAlias(at, p, variable) =>
        let pair = emitPattern(p)
        Pair(escapeKeyword(variable) + " @ (" + pair.first + ")", pair.second)
    | PList(at, _, items) =>
        let pair = items.map {
            | Pair(item, False) =>
                emitPattern(item)
            | Pair(item, True) =>
                let pair = emitPattern(item)
                Pair(
                    pair.first + "_seq @ _*",
                    ["val " + pair.first + " = " + pair.first + "_seq.toList;\n", ...pair.second]
                )
        }.getUnzip()
        Pair("List(" + pair.first.join(", ") + ")", pair.second.getFlatten())
}

extractTypeName(type: Type): String {
    | TVariable(at, index) =>
        fail(at, "Unexpected type variable: $" + index)
    | TConstructor t =>
        t.name
}

escapeResolved(word: String): String {
    let parts = word.replace(":", ".").replace("/", ".").split('.').getList()
    let initialParts = parts.dropLast()
    if(initialParts.getEmpty()) {
        escapeKeyword(parts.expectLast())
    } else {
        initialParts.join(".") + "_." + escapeKeyword(parts.expectLast())
    }
}

escapeKeyword(word: String): String {
    if(keywords.contains(word) || word.expectFirst().isAsciiLower()) {word + "_"} else {word}
}

keywords = [
    "abstract"
    "case"
    "catch"
    "class"
    "def"
    "do"
    "else"
    "extends"
    "false"
    "final"
    "finally"
    "for"
    "forSome"
    "if"
    "implicit"
    "import"
    "lazy"
    "match"
    "new"
    "null"
    "object"
    "override"
    "package"
    "private"
    "protected"
    "return"
    "sealed"
    "super"
    "this"
    "throw"
    "trait"
    "true"
    "try"
    "type"
    "val"
    "var"
    "while"
    "with"
    "yield"
    "scala"
    "java"
].getSet()
