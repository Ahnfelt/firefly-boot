import Syntax
import Patterns
import JsImporter
import SourceMap from ff:compiler

class JsEmitter(
    otherModules: Map[String, Module]
    jsImporter: JsImporter
    emitTarget: EmitTarget
    isMainModule: Bool
    compilerModuleFileUrl: Option[String]
    moduleKey: ModuleKey
    mutable emittingAsync: Bool
    mutable tailCallUsed: Bool
    mutable writtenColumn: Int
    writtenStrings: Array[Array[String]]
    writtenSegments: Array[Array[List[Int]]]
    writtenAnchors: IntMap[List[String]]
    writtenNames: StringMap[Int]
)

data EmitTarget {
    EmitNode
    EmitBrowser
    EmitBuild
    EmitExecutable
}

new(
    otherModules: List[Module]
    emitTarget: EmitTarget
    isMainModule: Bool
    compilerModuleFileUrl: Option[String]
    moduleKey: ModuleKey
): JsEmitter {
    JsEmitter(
        otherModules = otherModules.map {m =>
            Pair(m.moduleKey.qualifiedName(), m)
        }.toMap()
        jsImporter = JsImporter.new()
        emitTarget = emitTarget
        isMainModule = isMainModule
        compilerModuleFileUrl = compilerModuleFileUrl
        moduleKey = moduleKey
        emittingAsync = False
        tailCallUsed = False
        writtenColumn = 0
        writtenStrings = [[].toArray()].toArray()
        writtenSegments = [[].toArray()].toArray()
        writtenAnchors = IntMap.new()
        writtenNames = StringMap.new()
    )
}

fail[T](at: Location, message: String): T {
    throw(CompileError(at, message))
}

extend self: JsEmitter {
    
    writeUnmapped(text: String) {
        self.writtenStrings.grabLast().push(text)
        self.writtenSegments.grabLast().push(
            [self.writtenColumn]
        )
        self.writtenColumn += text.size()
    }

    writeMapped(at: Location, text: String) {
        self.writtenStrings.grabLast().push(text)
        self.writtenSegments.grabLast().push(
            [self.writtenColumn, 0, at.line - 1, at.column - 1]
        )
        self.writtenColumn += text.size()
    }

    writeNamed(name: String, at: Location, text: String) {
        let unqualified = name.reverse().takeWhile {c => c != '.' && c != '_'}.reverse()
        let nameIndex = self.writtenNames.getOrSet(unqualified) {self.writtenNames.size()}
        self.writtenStrings.grabLast().push(text)
        self.writtenSegments.grabLast().push(
            [self.writtenColumn, 0, at.line - 1, at.column - 1, nameIndex]
        )
        self.writtenColumn += text.size()
    }
    
    writeLine() {
        self.writtenStrings.push(Array.new())
        self.writtenSegments.push(Array.new())
        self.writtenColumn = 0
    }
    
    writeAnchor(): Int {
        self.writtenStrings.size() - 1
    }
    
    writeAnchorLines(anchor: Int, lines: List[String]) {
        if(self.writtenAnchors.has(anchor)) {
            self.writtenAnchors.set(anchor, [...self.writtenAnchors.grab(anchor), ...lines])
        } else {
            self.writtenAnchors.set(anchor, lines)
        }
    }
    
    makeOutput(): String {
        SourceMap.makeOutput(
            self.writtenStrings, self.writtenAnchors
        )
    }
    
    makeOutputAndSourceMap(fireflyFile: String, fireflySource: Option[String]): Pair[String, Json] {
        SourceMap.makeOutputAndSourceMap(
            fireflyFile
            fireflySource
            self.writtenStrings
            self.writtenSegments
            self.writtenAnchors
            self.writtenNames
        )
    }
    
    emitModule(module: Module) {
        let selfImport = self.emitImport(self.moduleKey)
        let imports = [
            self.compilerModuleFileUrl.map {"import * as $firefly_compiler from '" + _ + "'"}.toList()
            module.imports.sortBy {_.moduleKey}.map {self.emitImport(_.moduleKey)}
        ].flatten()
        let liner = Liner(self, True)
        if(!imports.any {_ == selfImport}) {
            liner.writeLines()
            self.writeUnmapped(selfImport)
        }
        imports.each {import =>
            liner.writeLines()
            self.writeUnmapped(import)
        }
        let anchor = self.writeAnchor()
        module.types.each {
            liner.writeLines()
            self.emitTypeDefinition(_)
        }
        module.lets.each {
            liner.writeLines()
            self.writeUnmapped("export ")
            self.emitLetDefinition(_, False, False)
        }
        module.functions.each {
            liner.writeLines()
            self.writeUnmapped("export ")
            self.emitFunctionDefinition(_, False)
        }
        self.withEmittingAsync {
            module.functions.each {
                liner.writeLines()
                self.writeUnmapped("export ")
                self.emitFunctionDefinition(_, True)
            }
        }
        module.extends.each {
            liner.writeLines()
            self.emitExtendsDefinition(_)
        }
        module.instances.each {
            liner.writeLines()
            self.emitInstanceDefinition(_)
        }
        let ignoreJsImports = if(self.emitTarget == EmitExecutable && self.moduleKey.packagePair.isCore()) {
            ["esbuild"]
        } else {
            []
        }
        let jsImports = self.jsImporter.generateImports(ignoreJsImports.toSet())
        if(!jsImports.isEmpty()) {
            self.writeAnchorLines(anchor, jsImports)
        }
    }

    emitImport(moduleKey: ModuleKey): String {
        let dots = "../".repeat(self.moduleKey.folders.size() + 2)
        let jsImportName = moduleKey.packagePair.groupName("_") + "_" + 
            moduleKey.folders.map {_ + "_"}.join() + moduleKey.name
        let jsImportFrom = dots + moduleKey.packagePair.groupName("/") + "/" + 
            moduleKey.folders.map {_ + "/"}.join() + moduleKey.name + ".mjs"
        "import * as " + jsImportName + " from \"" + jsImportFrom + "\""
    }
    
    withEmittingAsync[T](body: () => T): T {
        try {
            self.emittingAsync = True
            body()
        } finally {
            self.emittingAsync = False
        }
    }

    makeRun(moduleName: String, functions: List[DFunction], mainPackagePair: PackagePair, bootstrapping: Bool): List[String] {
        let buildMainFunction = functions.find {_.signature.name == "buildMain"}.filter {_ =>
            self.emitTarget != EmitBrowser && self.emitTarget != EmitExecutable
        }
        let willRunOnNode = self.emitTarget != EmitBrowser
        let targetMain = if(willRunOnNode) {"nodeMain"} else {"browserMain"}
        let mainFunction =
            functions.find {_.signature.name == targetMain}.orElse {functions.find {_.signature.name == "main"}}
        mainFunction.map {_.signature.name}.map {mainName => [[
            ...buildMainFunction.map {buildMain =>
                "import {" + escapeKeyword(buildMain.signature.name) + "$} from './" + moduleName + ".mjs'"
            }.toList()
            "import {" + escapeKeyword(mainName) + "$} from './" + moduleName + ".mjs'"
            "export async function $run$(fireflyPath_, arguments_) {"
            "Error.stackTraceLimit = 50"
            "const $task = {controller_: new AbortController(), subtasks_: new Set(), promise_: new Promise(() => {}), started_: performance.now() * 0.001}"
            ...if(self.emitTarget != EmitBrowser) {[
                "let interval = setInterval(() => {}, 24 * 60 * 60 * 1000)" // To prevent deadlocks from exiting node
            ]} else {[]}
            "let system = {"
            "task_: $task,"
            "array_: arguments_,"
            "fireflyPath_: fireflyPath_,"
            "mainPackagePair_: {group_: \"" + mainPackagePair.group + "\", name_: \"" + mainPackagePair.name + "\"},"
            "executableMode_: " + if(self.emitTarget == EmitExecutable) {"true"} else {"false"} + ","
            "buildMode_: " + if(self.emitTarget == EmitBuild) {"true"} else {"false"}
            "}"
            "try {"
            ...if(!buildMainFunction.isEmpty()) {[
                "await buildMain_$(system, $task)"]
            } else {[]}
            ...if(self.emitTarget != EmitBuild) {[
                "await " + mainName + "_$(system, $task)"
            ]} else {[]}
            ...if(self.emitTarget == EmitBuild) {[
                "await $firefly_compiler.internalCreateExecutable_$(system, '.firefly/output/executable/Main.bundle.js', '.firefly/output', ['host'], system.assets_, $task)"
            ]} else {[]}
            "} finally {"
            ...if(self.emitTarget != EmitBrowser) {[
                "$task.controller_.abort()"
                "clearInterval(interval)"
            ]} else {[]}
            "}"
            "}"
            ...self.emitTarget.{
                | EmitBrowser => [
                    "queueMicrotask(async () => {"
                    "await $run$(null, [])"
                    "})"
                ]
                | EmitNode {bootstrapping} => [
                    "import * as path from 'node:path'"
                    "queueMicrotask(async () => {"
                    "let fireflyPath_ = path.dirname(path.dirname(path.dirname(path.dirname(path.dirname(process.argv[1])))))"
                    "await $run$(fireflyPath_, process.argv.slice(2))"
                    "})"
                ]
                | EmitExecutable => [
                    "queueMicrotask(async () => {"
                    "await $run$(null, process.argv.slice(2))"
                    "})"
                ]
                | _ => []
            }
        ].join("\n")]}.else {[]}
    }

    emitLetDefinition(definition: DLet, mutable: Bool, async: Bool) {
        self.writeMapped(definition.at, if(mutable) {"let "} else {"const "})
        self.writeNamed(definition.name, definition.at, escapeKeyword(definition.name))
        self.writeMapped(definition.at, " = ") // TODO: No = value when the right hand side would be (void 0)
        self.emitTerm(definition.value, async)
        self.writeMapped(definition.at, ";")
    }

    emitExtendsDefinition(definition: DExtend) {
        let typeName = extractTypeName(definition.type).reverse().takeWhile {_ != '.'}.reverse()
        let methods = definition.methods.map {method =>
            method.DFunction(
                signature = method.signature.Signature(
                    name = typeName + "_" + method.signature.name
                )
            )
        }
        let liner = Liner(self, True)
        methods.each {
            liner.writeLines()
            self.writeMapped(definition.at, "export ")
            self.emitFunctionDefinition(_, False)
        }
        self.withEmittingAsync {methods.each {
            liner.writeLines()
            self.writeMapped(definition.at, "export ")
            self.emitFunctionDefinition(_, True)
        }}
    }

    emitInstanceDefinition(definition: DInstance) {
        let name = makeDictionaryName(definition.traitName, firstTypeName(definition.typeArguments))
        definition.constraints.{
            | [] =>
                self.writeMapped(definition.at, "export const ")
                self.writeNamed(name, definition.at, name)
                self.writeMapped(definition.at, " = ")
            | constraints =>
                let dictionaries = constraints.map {c =>
                    makeDictionaryName(c.name, firstTypeName(c.generics))
                }
                self.writeMapped(definition.at, "export function ")
                self.writeNamed(name, definition.at, name)
                self.writeMapped(definition.at, "(" + dictionaries.join(", ") + ") { return ")
        }
        self.writeMapped(definition.at, "{")
        self.writeLine()
        definition.methods.each {
            self.emitFunctionDefinition(_, False, asMethod = True)
            self.writeMapped(definition.at, ",")
            self.writeLine()
        }
        self.withEmittingAsync {
            definition.methods.map {
                self.emitFunctionDefinition(_, True, asMethod = True)
                self.writeMapped(definition.at, ",")
                self.writeLine()
            }
        }
        self.writeMapped(definition.at, "}")
        definition.constraints.{
            | [] => self.writeMapped(definition.at, ";")
            | _ => self.writeMapped(definition.at, "}")
        }
    }

    emitFunctionDefinition(definition: DFunction, async: Bool, suffix: String = "", asMethod: Bool = False): Unit {
        self.emitSignature(definition.signature, async, suffix, asMethod)
        self.writeMapped(definition.at, " {")
        self.writeLine()
        definition.body.{
            | Lambda(_, effect, [matchCase]) {
                matchCase.patterns.all {
                    | PVariable(_, None) => True
                    | _ => False
                }
            } =>
                self.emitTailCall {self.emitStatements(matchCase.body, True, False, async)}
            | Lambda(_, effect, cases) =>
                Patterns.convertAndCheck(self.otherModules, cases) // TODO no type errors in emitter
                self.emitTailCall {
                    let liner = Liner(self, False)
                    definition.signature.parameters.each {p =>
                        liner.writeLines()
                        self.writeMapped(p.at, "const ")
                        self.writeNamed(p.name, p.at, p.name + "_a")
                        self.writeMapped(p.at, " = ")
                        self.writeNamed(p.name, p.at, escapeKeyword(p.name))
                        self.writeMapped(p.at, ";")
                    }
                    let argumentTerms = definition.signature.parameters.map {p => 
                        {self.writeNamed(p.name, p.at, p.name + "_a")}
                    }
                    cases.pairs().each {| Pair(i, c) =>
                        liner.writeLines()
                        let lastCase = i == cases.size() - 1
                        self.emitCase(argumentTerms, c, [], [], True, True, False, lastCase, async)
                    }
                }
        }
        self.writeLine()
        self.writeMapped(definition.at, "}")
    }

    emitTailCall(body: () => Unit) {
        let outerTailCallUsed = self.tailCallUsed
        self.tailCallUsed = False
        let anchor = self.writeAnchor()
        body()
        let tailCallUsed = self.tailCallUsed
        self.tailCallUsed = outerTailCallUsed
        if(tailCallUsed) {
            self.writeAnchorLines(anchor, ["_tailcall: for(;;) {"])
            self.writeLine()
            self.writeUnmapped("return")
            self.writeLine()
            self.writeUnmapped("}")
        }
    }

    emitSignature(signature: Signature, async: Bool, suffix: String = "", asMethod: Bool = False): Unit {
        let prefix = if(async) {"async "} else {""}
        let asyncSuffix = if(async) {"$"} else {""}
        let fullPrefix = prefix + if(asMethod) {""} else {"function "}
        self.writeMapped(signature.at, fullPrefix)
        self.writeNamed(signature.name, signature.at, escapeKeyword(signature.name) + suffix + asyncSuffix)

        self.writeMapped(signature.at, "(")
        let comma = Comma(self)
        
        signature.parameters.each {
            comma.writeComma()
            self.emitParameter(_, async)
        }
        signature.constraints.each {c =>
            comma.writeComma()
            self.writeMapped(c.at, makeDictionaryName(c.name, firstTypeName(c.generics)))
        }
        if(async) {
            comma.writeComma()
            self.writeMapped(signature.at, "$task")
        }

        self.writeMapped(signature.at, ")")
    }

    emitParameter(parameter: Parameter, async: Bool) {
        self.writeNamed(parameter.name, parameter.at, escapeKeyword(parameter.name))
        parameter.default.each {e => 
            self.writeMapped(e.at, " = ")
            self.emitTerm(e, async) 
        }
    }

    emitTypeDefinition(definition: DType) {
        if(definition.newtype) {
            self.writeMapped(definition.at, "// newtype " + definition.name)
        } else {
            self.writeMapped(definition.at, "// type " + definition.name)
            self.writeLine()
            let liner = Liner(self, double = False)
            definition.variants.each {
                liner.writeLines()
                self.emitVariantDefinition(definition, _)
            }
        }
    }

    emitVariantDefinition(typeDefinition: DType, definition: Variant) {
        let allFields = [...typeDefinition.commonFields, ...definition.fields]
        function emitFields() {
            let comma = Comma(self)
            allFields.each {f => 
                comma.writeComma()
                self.writeNamed(f.name, f.at, escapeKeyword(f.name))
            }
        }
        function emitConstructor() {
            self.writeMapped(definition.at, "export function ")
            self.writeNamed(definition.name, definition.at, definition.name)
            self.writeMapped(definition.at, "(")
            emitFields()
            self.writeMapped(definition.at, ") {")
            self.writeLine()
        }
        if(allFields.isEmpty()) {
            self.writeMapped(definition.at, "const ")
            self.writeNamed(definition.name, definition.at, definition.name + "$")
            self.writeMapped(definition.at, " = {")
            self.writeNamed(definition.name, definition.at, definition.name)
            self.writeMapped(definition.at, ": true};")
            self.writeLine()
            emitConstructor()
            self.writeMapped(definition.at, "return ")
            self.writeNamed(definition.name, definition.at, definition.name + "$")
            self.writeMapped(definition.at, ";")
            self.writeLine()
            self.writeMapped(definition.at, "}")
        } elseIf {typeDefinition.variants.size() == 1} {
            emitConstructor()
            self.writeMapped(definition.at, "return {")
            emitFields()
            self.writeMapped(definition.at, "};")
            self.writeLine()
            self.writeMapped(definition.at, "}")
        } else {
            emitConstructor()
            self.writeMapped(definition.at, "return {")
            self.writeNamed(definition.name, definition.at, definition.name)
            self.writeMapped(definition.at, ": true, ")
            emitFields()
            self.writeMapped(definition.at, "};")
            self.writeLine()
            self.writeMapped(definition.at, "}")
        }
    }

    emitTerm(term: Term, async: Bool, ignored: Bool = False) {term.{
        | EString(at, value) {value.startsWith("\"\"\"")} =>
            self.writeMapped(at, "\"" + 
                value.dropFirst(3).dropLast(3).replace("\r", "\\r").replace("\n", "\\n").replace("\"", "\\\"") + 
            "\"")
        | EString(at, value) => 
            self.writeMapped(at, value)
        | EChar(at, value) => 
            self.writeMapped(at, charLiteralToNumber(value))
        | EInt(at, value) => 
            self.writeMapped(at, value)
        | EFloat(at, value) =>
            self.writeMapped(at, value)
        | EVariable(at, name) => 
            self.writeNamed(name, at, escapeResolved(name))
        | EList(at, _, items) =>
            self.emitList(at, items, async)
        | EVariant(at, "ff:core/Bool.False", _, _) =>
            self.writeMapped(at, "false")
        | EVariant(at, "ff:core/Bool.True", _, _) =>
            self.writeMapped(at, "true")
        | EVariant(at, "ff:core/Unit.Unit", _, _) =>
            self.writeMapped(at, "(void 0)")
        | EVariant(at, name, _, arguments) =>
            let newtype = self.processVariant(name)
            if(newtype) {
                self.emitArgument(at, arguments.grab().grabFirst(), async)
            } else {
                self.writeNamed(name, at, escapeResolved(name))
                self.writeMapped(term.at, "(")
                let comma = Comma(self)
                arguments.toList().flatten().each {
                    comma.writeComma()
                    self.emitArgument(at, _, async)
                }
                self.writeMapped(term.at, ")")
            }
        | EVariantIs(at, "ff:core/Bool.False", _) =>
            self.writeMapped(at, "function(_v) { return !_v ? ff_core_Option.Some(_v) : ff_core_Option.None(); }")
        | EVariantIs(at, "ff:core/Bool.True", _) =>
            self.writeMapped(at, "function(_v) { return _v ? ff_core_Option.Some(_v) : ff_core_Option.None(); }")
        | EVariantIs(at, "ff:core/Unit.Unit", _) =>
            self.writeMapped(at, "function(_v) { return ff_core_Option.Some(_v); }")
        | EVariantIs(at, name, _) =>
            let n = name.reverse().takeWhile {_ != '.'}.reverse()
            self.writeMapped(at, "(function(_v) { return _v.")
            self.writeNamed(n, at, escapeResolved(n))
            self.writeMapped(at, " ? ff_core_Option.Some(_v) : ff_core_Option.None();})")
        | ECopy(at, name, record, fields) =>
            self.writeMapped(at, "{...")
            let comma = Comma(self)
            comma.writeComma()
            self.emitTerm(record, async)
            fields.each {f => 
                comma.writeComma()
                self.writeNamed(f.name, at, escapeKeyword(f.name))
                self.writeMapped(at, " = ")
                self.emitTerm(f.value, async)
            }
            self.writeMapped(at, "}")
        | EField(at, newtype, record, field) =>
            if(newtype) {self.emitTerm(record, async)} else:
            self.emitTerm(record, async)
            self.writeMapped(at, ".")
            self.writeNamed(field, at, escapeKeyword(field))
        | ELambda(at, Lambda(_, effect, [MatchCase(_, patterns, [], body)])) {
            patterns.all {| PVariable _ => True | _ => False }
        } =>
            let newAsync = self.emittingAsync && effectTypeIsAsync(effect)
            self.writeMapped(term.at, "(")
            if(newAsync) {self.writeMapped(term.at, "async ")}
            self.writeMapped(term.at, "(")
            let comma = Comma(self)
            patterns.each {
                | PVariable(patternAt, Some(name)) => 
                    comma.writeComma()
                    self.writeNamed(name, patternAt, escapeKeyword(name))
                | PVariable(patternAt, None) => 
                    comma.writeComma()
                    self.writeMapped(patternAt, "_")
                | _ => 
                    throw(CompileError(at, "Internal compiler error"))
            }
            if(newAsync) {
                comma.writeComma()
                self.writeMapped(term.at, "$task")
            }
            self.writeMapped(term.at, ") => {")
            self.writeLine()
            self.emitStatements(body, True, False, newAsync)
            self.writeLine()
            self.writeMapped(term.at, "})")
        | ELambda(at, Lambda(_, effect, cases)) =>
            Patterns.convertAndCheck(self.otherModules, cases)
            let arguments = cases.grab(0).patterns.pairs().map {| Pair(i, p) => Pair(p.at, "_" + (i + 1))}
            let newAsync = self.emittingAsync && effectTypeIsAsync(effect)

            self.writeMapped(term.at, "(")
            if(newAsync) {self.writeMapped(term.at, "async ")}
            self.writeMapped(term.at, "(")
            let comma = Comma(self)
            arguments.each {a => 
                comma.writeComma()
                self.writeMapped(a.first, a.second)
            }
            let argumentTerms = arguments.map {| Pair(at, n) => {self.writeMapped(at, n)}}
            if(newAsync) {
                comma.writeComma()
                self.writeMapped(term.at, "$task")
            }
            self.writeMapped(term.at, ") => {")
            self.writeLine()
            let liner = Liner(self, double = False)
            cases.pairs().each {| Pair(i, c) =>
                liner.writeLines()
                let lastCase = i == cases.size() - 1
                self.emitCase(argumentTerms, c, [], [], True, True, False, lastCase, newAsync)
            }
            self.writeLine()
            self.writeMapped(term.at, "})")
        | EPipe(at, value, effect, function) =>
            let await = async && effectTypeIsAsync(effect)
            if(await) {self.writeMapped(term.at, "(await ")}
            self.writeMapped(term.at, "(")
            self.emitTerm(function, async)
            self.writeMapped(term.at, ")")
            self.writeMapped(term.at, "(")
            self.emitTerm(value, async)
            if(await) {self.writeMapped(term.at, ", $task")}
            self.writeMapped(term.at, ")")
            if(await) {self.writeMapped(term.at, ")")}
        | _ {self.emitAssignment(term, async, ignored)} =>
        | ECall(at, StaticCall(name, _, _), _, _, arguments, dictionaries) {
            self.emitSpecialCall(term, async, name, arguments.map {_.value}, dictionaries)
        } =>
        | ECall(at, StaticCall(name, _, True), effect, typeArguments, arguments, dictionaries) =>
            let await = async && effectTypeIsAsync(effect)
            let dictionaryStrings = dictionaries.map {self.makeDictionary(_)}
            let ds = dictionaryStrings.dropFirst()
            let d = dictionaryStrings.grabFirst()
            let asyncSuffix = if(await) {"$"} else {""}
            if(await) {self.writeMapped(term.at, "(await ")}
            self.writeMapped(term.at, d)
            self.writeMapped(term.at, ".")
            self.writeNamed(name, at, escapeKeyword(name.reverse().takeWhile {_ != '.'}.reverse()) + asyncSuffix)
            self.writeMapped(term.at, "(")
            let comma = Comma(self)
            arguments.each {
                comma.writeComma()
                self.emitArgument(at, _, async)
            }
            ds.each {
                comma.writeComma()
                self.writeMapped(term.at, _)
            }
            if(await) {
                comma.writeComma()
                self.writeMapped(term.at, "$task")
            }
            self.writeMapped(term.at, ")")
            if(await) {self.writeMapped(term.at, ")")}
        | ECall(at, StaticCall(name, _, _), effect, typeArguments, arguments, dictionaries) =>
            detectIfElse(term).{
                | [] =>
                    let await = async && effectTypeIsAsync(effect)
                    let dictionaryStrings = dictionaries.map {self.makeDictionary(_)}
                    let asyncSuffix = if(await) {"$"} else {""}
                    if(await) {self.writeMapped(term.at, "(await ")}
                    self.writeNamed(name, at, escapeResolved(name) + asyncSuffix)
                    self.writeMapped(term.at, "(")
                    let comma = Comma(self)
                    arguments.each {
                        comma.writeComma()
                        self.emitArgument(at, _, async)
                    }
                    dictionaryStrings.each {
                        comma.writeComma()
                        self.writeMapped(term.at, _)
                    }
                    if(await) {
                        comma.writeComma()
                        self.writeMapped(term.at, "$task")
                    }
                    self.writeMapped(term.at, ")")
                    if(await) {self.writeMapped(term.at, ")")}
                | [Pair(EVariant(_, "ff:core/Bool.True", _, _), elseBody), ...list] =>
                    self.writeMapped(term.at, "(")
                    list.reverse().each {| Pair(condition, body) =>
                        self.emitTerm(condition, async)
                        self.writeLine()
                        self.writeMapped(condition.at, "? ")
                        self.emitTerm(body, async)
                        self.writeLine()
                        self.writeMapped(condition.at, ": ")
                    }
                    self.emitTerm(elseBody, async)
                    self.writeMapped(term.at, ")")
                | list =>
                    self.writeMapped(term.at, "(")
                    list.reverse().each {| Pair(condition, body) =>
                        self.emitTerm(condition, async)
                        self.writeLine()
                        self.writeMapped(term.at, "? ff_core_Option.Some(")
                        self.emitTerm(body, async)
                        self.writeMapped(term.at, ")")
                        self.writeLine()
                        self.writeMapped(term.at, ": ")
                    }
                    self.writeMapped(term.at, "ff_core_Option.None())")
            }
        | ECall(at, DynamicCall(function, _), effect, typeArguments, arguments, dictionaries) =>
            let await = async && effectTypeIsAsync(effect)
            if(!dictionaries.isEmpty()) {fail(at, "Internal error: Dictionaries in lambda call")}
            if(await) {self.writeMapped(term.at, "(await ")}
            self.emitTerm(function, async)
            self.writeMapped(term.at, "(")
            let comma = Comma(self)
            arguments.each {
                comma.writeComma()
                self.emitArgument(at, _, async)
            }
            if(await) {
                comma.writeComma()
                self.writeMapped(term.at, "$task")
            }
            self.writeMapped(term.at, ")")
            if(await) {self.writeMapped(term.at, ")")}
        | ERecord(at, fields) =>
            if(fields.isEmpty()) {
                self.writeMapped(term.at, "{}")
            } else {
                self.writeMapped(term.at, "{")
                self.writeLine()
                let comma = Comma(self)
                let liner = Liner(self, double = False)
                fields.each {f => 
                    comma.writeComma()
                    liner.writeLines()
                    self.writeNamed(f.name, f.at, escapeKeyword(f.name))
                    self.writeMapped(f.at, ": ")
                    self.emitTerm(f.value, async)
                }
                self.writeLine()
                self.writeMapped(term.at, "}")
            }
        | EWildcard(at, index) =>
            if(index == 0) {fail(at, "Unbound wildcard")}
            self.writeMapped(at, "_w" + index)
        | ESequential(_, ESequential(_, ESequential(_, before1, before2), before3), after) {
            safeCommable(before1) && safeCommable(before2) && safeCommable(before3) && safeCommable(after)
        } =>
            self.writeMapped(term.at, "(")
            self.emitTerm(before1, async, ignored = True)
            self.writeMapped(term.at, ", ")
            self.emitTerm(before2, async, ignored = True)
            self.writeMapped(term.at, ", ")
            self.emitTerm(before3, async, ignored = True)
            self.writeMapped(term.at, ", ")
            self.emitTerm(after, async, ignored)
            self.writeMapped(term.at, ")")
        | ESequential(_, ESequential(_, before1, before2), after) {
            safeCommable(before1) && safeCommable(before2) && safeCommable(after)
        } =>
            self.writeMapped(term.at, "(")
            self.emitTerm(before1, async, ignored = True)
            self.writeMapped(term.at, ", ")
            self.emitTerm(before2, async, ignored = True)
            self.writeMapped(term.at, ", ")
            self.emitTerm(after, async, ignored)
            self.writeMapped(term.at, ")")
        | ESequential(_, before, after) {
            safeCommable(before) && safeCommable(after)
        } =>
            self.writeMapped(term.at, "(")
            self.emitTerm(before, async, ignored = True)
            self.writeMapped(term.at, ", ")
            self.emitTerm(after, async, ignored)
            self.writeMapped(term.at, ")")
        | _ {async} =>
            self.writeMapped(term.at, "(await (async function() {")
            self.writeLine()
            self.emitStatements(term, True, False, async)
            self.writeLine()
            self.writeMapped(term.at, "})())")
        | _ =>
            self.writeMapped(term.at, "(function() {")
            self.writeLine()
            self.emitStatements(term, True, False, async)
            self.writeLine()
            self.writeMapped(term.at, "})()")
    }}
    
    emitField(term: Term, async: Bool, dot: String = ".") {
        term.{
            | EString(at, q) {safeBare(q) | Some(s)} => 
                self.writeMapped(term.at, dot)
                self.writeNamed(s, at, s)
            | _ => 
                self.writeMapped(term.at, "[")
                self.emitTerm(term, async)
                self.writeMapped(term.at, "]")
        }
    }

    makeDictionary(d: Dictionary): String {
        let m = if(d.moduleKey.name != "") {
            d.moduleKey.packagePair.groupName("_") + "_" + 
            d.moduleKey.folders.map {_ + "_"}.join() + 
            d.moduleKey.name + "."
        } else {""}
        let c = m + makeDictionaryName(d.traitName, d.typeName)
        if(d.dictionaries.isEmpty()) {
            c
        } else {
            c + "(" + d.dictionaries.map {self.makeDictionary(_)}.join(", ") + ")"
        }
    }

    emitStatements(term: Term, last: Bool, break: Bool, async: Bool) {
        term.{
            | EFunctions(at, functions, body) =>
                let liner = Liner(self, double = False)
                functions.each {f =>
                    liner.writeLines()
                    let newAsync = self.emittingAsync && effectTypeIsAsync(f.signature.effect)
                    self.emitFunctionDefinition(f, newAsync)
                }
                liner.writeLines()
                self.emitStatements(body, last, break, async)
            | ELet(at, mutable, name, valueType, value, body) =>
                self.emitLetDefinition(DLet(at, name, valueType, value), mutable, async)
                self.writeLine()
                self.emitStatements(body, last, break, async)
            | EVariant(at, "ff:core/Unit.Unit", _, _) =>
            | ESequential(_, EVariant(_, "ff:core/Unit.Unit", _, _), after) =>
                self.emitStatements(after, last, break, async)
            | ESequential(_, before, EVariant(_, "ff:core/Unit.Unit", _, _)) =>
                self.emitStatements(before, False, break, async)
            | ESequential(at, before, after) =>
                self.emitStatements(before, False, False, async)
                self.writeMapped(term.at, ";")
                self.writeLine()
                self.emitStatements(after, last, break, async)
            | ECall(at, StaticCall(name, True, instanceCall), effect, _, arguments, _) =>
                if(instanceCall) {throw(CompileError(at, "Not yet implemented: Tail calls on trait methods."))}
                self.tailCallUsed = True
                self.writeMapped(term.at, "{")
                arguments.each {a =>
                    self.writeLine()
                    self.writeMapped(a.at, "const ")
                    self.writeNamed(a.name.grab(), a.at, escapeKeyword(a.name.grab() + "_r"))
                    self.writeMapped(a.at, " = ")
                    self.emitTerm(a.value, async)
                    self.writeMapped(a.at, ";")
                }
                arguments.each {a =>
                    self.writeLine()
                    self.writeNamed(a.name.grab(), a.at, escapeKeyword(a.name.grab()))
                    self.writeMapped(term.at, " = ")
                    self.writeNamed(a.name.grab(), a.at, escapeKeyword(a.name.grab() + "_r"))
                }
                self.writeLine()
                self.writeMapped(term.at, "continue _tailcall")
                self.writeLine()
                self.writeMapped(term.at, "}")
            | ECall(at, StaticCall(name, _, _), _, _, arguments, dictionaries) {
                self.emitSpecialStatement(term, last, async, name, arguments.map {_.value}, dictionaries)
            } =>
            | EPipe(at, value, _, ELambda(_, Lambda(_, _, cases))) =>
                Patterns.convertAndCheck(self.otherModules, cases)
                if(!last && !break) {self.writeMapped(term.at, "do ")}
                self.writeMapped(term.at, "{")
                self.writeLine()
                self.writeMapped(term.at, "const _1 = ")
                self.emitTerm(value, async)
                self.writeMapped(term.at, ";")
                cases.pairs().each {| Pair(i, c) => 
                    self.writeLine()
                    let lastCase = i == cases.size() - 1
                    self.emitCase([{self.writeMapped(c.at, "_1")}], c, [], [], True, last, break, lastCase, async)
                }
                self.writeLine()
                self.writeMapped(term.at, "}")
                if(!last && !break) {self.writeMapped(term.at, " while(false)")}
            | _ {self.emitAssignment(term, async, True)} =>
            | _ =>
                detectIfElse(term).{
                    | [] =>
                        if(break) {
                            self.writeMapped(term.at, "if(!")
                            self.emitTerm(term, async)
                            self.writeMapped(term.at, ") break")
                        } elseIf {last} {
                            self.writeMapped(term.at, "return ")
                            self.emitTerm(term, async)
                        } else {
                            self.emitTerm(term, async, ignored = True)
                        }
                    | [Pair(EVariant(_, "ff:core/Bool.True", _, _), elseBody), ...list] =>
                        list.reverse().each {| Pair(condition, body) =>
                            self.writeMapped(condition.at, "if(")
                            self.emitTerm(condition, async)
                            self.writeMapped(condition.at, ") {")
                            self.writeLine()
                            self.emitStatements(body, last, break, async)
                            self.writeLine()
                            self.writeMapped(condition.at, "} else ")
                        }
                        self.writeMapped(term.at, "{")
                        self.writeLine()
                        self.emitStatements(elseBody, last, break, async)
                        self.writeLine()
                        self.writeMapped(term.at, "}")
                    | list {!last} =>
                        list.reverse().each {| Pair(condition, body) =>
                            self.writeMapped(condition.at, "if(")
                            self.emitTerm(condition, async)
                            self.writeMapped(condition.at, ") {")
                            self.writeLine()
                            self.emitStatements(body, last, break, async)
                            self.writeLine()
                            self.writeMapped(condition.at, "} else ")
                        }
                        self.writeMapped(term.at, "{}")
                    | list =>
                        list.reverse().each {| Pair(condition, body) =>
                            self.writeMapped(condition.at, "if(")
                            self.emitTerm(condition, async)
                            self.writeMapped(condition.at, ") {")
                            self.writeLine()
                            self.writeMapped(condition.at, "return ff_core_Option.Some(")
                            self.emitTerm(body, async)
                            self.writeMapped(condition.at, ")")
                            self.writeLine()
                            self.writeMapped(condition.at, "} else ")
                        }
                        self.writeMapped(term.at, "return ff_core_Option.None()")
                        
                }
        }
    }
    
    emitAssignment(
        term: Term
        async: Bool
        ignored: Bool
    ): Bool {
        let anchor = self.writeAnchor()
        let emitted = term.{
            | ECall(at, StaticCall(name, _, _), _, _, arguments, dictionaries) =>
                name.{
                    | "ff:core/JsValue.JsValue_set" {arguments.map {_.value} | [e1, e2, e3]} =>
                        self.emitTerm(e1, async)
                        self.emitField(e2, async)
                        self.writeMapped(term.at, " = ")
                        self.emitTerm(e3, async)
                        True
                    | "ff:core/JsValue.JsValue_increment" {arguments.map {_.value} | [e1, e2, e3]} =>
                        self.emitTerm(e1, async)
                        self.emitField(e2, async)
                        self.writeMapped(term.at, " += ")
                        self.emitTerm(e3, async)
                        True
                    | "ff:core/JsValue.JsValue_decrement" {arguments.map {_.value} | [e1, e2, e3]} =>
                        self.emitTerm(e1, async)
                        self.emitField(e2, async)
                        self.writeMapped(term.at, " -= ")
                        self.emitTerm(e3, async)
                        True
                    | "ff:core/JsSystem.JsSystem_set" {arguments.map {_.value} | [e1, EString(at, q), e3]} {
                        noSideEffects(e1)} {safeBare(q) | Some(s)
                    } =>
                        self.writeNamed(s, at, s)
                        self.writeMapped(term.at, " = ")
                        self.emitTerm(e3, async)
                        True
                    | "ff:core/JsSystem.JsSystem_increment" {arguments.map {_.value} | [e1, EString(at, q), e3]} {
                        noSideEffects(e1)} {safeBare(q) | Some(s)
                    } =>
                        self.writeNamed(s, at, s)
                        self.writeMapped(term.at, " += ")
                        self.emitTerm(e3, async)
                        True
                    | "ff:core/JsSystem.JsSystem_decrement" {arguments.map {_.value} | [e1, EString(at, q), e3]} {
                        noSideEffects(e1)} {safeBare(q) | Some(s)
                    } =>
                        self.writeNamed(s, at, s)
                        self.writeMapped(term.at, " -= ")
                        self.emitTerm(e3, async)
                        True
                    | "ff:core/Js.set" {arguments.map {_.value} | [EString(at, q), e2]} {safeBare(q) | Some(s)} =>
                        self.writeNamed(s, at, s)
                        self.writeMapped(term.at, " = ")
                        self.emitTerm(e2, async)
                        True
                    | "ff:core/Js.increment" {arguments.map {_.value} | [EString(at, q), e2]} {safeBare(q) | Some(s)} =>
                        self.writeNamed(s, at, s)
                        self.writeMapped(term.at, " += ")
                        self.emitTerm(e2, async)
                        True
                    | "ff:core/Js.decrement" {arguments.map {_.value} | [EString(at, q), e2]} {safeBare(q) | Some(s)} =>
                        self.writeNamed(s, at, s)
                        self.writeMapped(term.at, " -= ")
                        self.emitTerm(e2, async)
                        True
                    | _ => 
                        False
                }
            | EAssign(at, operator, name, value) =>
                self.writeNamed(name, at, escapeKeyword(name))
                self.writeMapped(term.at, " " + operator + "= ")
                self.emitTerm(value, async)
                True
            | EAssignField(at, operator, record, field, value) =>
                self.emitTerm(record, async)
                self.writeMapped(term.at, ".")
                self.writeNamed(field, at, escapeKeyword(field))
                self.writeMapped(term.at, " " + operator + "= ")
                self.emitTerm(value, async)
                True
            | _ =>
                False
        }
        if(!ignored && emitted) {
            self.writeAnchorLines(anchor, ["("])
            self.writeMapped(term.at, ", void 0)")
        }
        emitted
    }
    
    emitSpecialCall(
        term: Term
        async: Bool
        name: String
        arguments: List[Term]
        dictionaries: List[Dictionary]
    ): Bool {
        name.{
            | operator {!operator.grabFirst().isAsciiLetter()} {arguments | [value]} =>
                self.writeMapped(term.at, "(")
                self.writeMapped(term.at, operator)
                self.emitTerm(value, async)
                self.writeMapped(term.at, ")")
                True
            | operator {!operator.grabFirst().isAsciiLetter()} {arguments | [left, right]}  =>
                self.writeMapped(term.at, "(")
                self.emitTerm(left, async) 
                self.writeMapped(term.at, " ")
                self.writeMapped(term.at, operator)
                self.writeMapped(term.at, " ")
                self.emitTerm(right, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/List.List_grab" {arguments | [e1, e2]} {noSideEffects(e1) && noSideEffects(e2)} =>
                self.writeMapped(term.at, "(")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, "[")
                self.emitTerm(e2, async)
                self.writeMapped(term.at, "] ?? ff_core_List.List_grab(")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, ", ")
                self.emitTerm(e2, async)
                self.writeMapped(term.at, "))")
                True
            | "ff:core/Array.Array_grab" {arguments | [e1, e2]} {noSideEffects(e1) && noSideEffects(e2)} =>
                self.writeMapped(term.at, "(")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, ".array[")
                self.emitTerm(e2, async)
                self.writeMapped(term.at, "] ?? ff_core_Array.Array_grab(")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, ", ")
                self.emitTerm(e2, async)
                self.writeMapped(term.at, "))")
                True
            | "ff:core/List.List_size" {arguments | [e]} =>
                self.emitTerm(e, async)
                self.writeMapped(term.at, ".length")
                True
            | "ff:core/Array.Array_size" {arguments | [e]} =>
                self.emitTerm(e, async)
                self.writeMapped(term.at, ".array.length")
                True
            | "ff:core/String.String_size" {arguments | [e]} =>
                self.emitTerm(e, async)
                self.writeMapped(term.at, ".length")
                True
            | "ff:core/Equal.equals" {arguments | [left, right]} {dictionaries | [Dictionary(_, _, typeName, [])]} {
                primitiveTypes.contains(typeName) || typeName == "ff:core/Ordering.Ordering"
            } =>
                self.writeMapped(term.at, "(")
                self.emitTerm(left, async)
                self.writeMapped(term.at, " === ")
                self.emitTerm(right, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/Equal.notEquals" {arguments | [left, right]} {dictionaries | [Dictionary(_, _, typeName, [])]} {
                primitiveTypes.contains(typeName) || typeName == "ff:core/Ordering.Ordering"
            } =>
                self.writeMapped(term.at, "(")
                self.emitTerm(left, async)
                self.writeMapped(term.at, " !== ")
                self.emitTerm(right, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/Ordering.before" {arguments | [left, right]} {dictionaries | [Dictionary(_, _, typeName, [])]} {
                primitiveTypes.contains(typeName)
            } =>
                self.writeMapped(term.at, "(")
                self.emitTerm(left, async)
                self.writeMapped(term.at, " < ")
                self.emitTerm(right, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/Ordering.notBefore" {arguments | [left, right]} {dictionaries | [Dictionary(_, _, typeName, [])]} {
                primitiveTypes.contains(typeName)
            } =>
                self.writeMapped(term.at, "(")
                self.emitTerm(left, async)
                self.writeMapped(term.at, " >= ")
                self.emitTerm(right, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/Ordering.after" {arguments | [left, right]} {dictionaries | [Dictionary(_, _, typeName, [])]} {
                primitiveTypes.contains(typeName)
            } =>
                self.writeMapped(term.at, "(")
                self.emitTerm(left, async)
                self.writeMapped(term.at, " > ")
                self.emitTerm(right, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/Ordering.notAfter" {arguments | [left, right]} {dictionaries | [Dictionary(_, _, typeName, [])]} {
                primitiveTypes.contains(typeName)
            } =>
                self.writeMapped(term.at, "(")
                self.emitTerm(left, async)
                self.writeMapped(term.at, " <= ")
                self.emitTerm(right, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/List.fillBy" {term | ECall call} {arguments | [size, ELambda(at,
                Lambda(_, _, [MatchCase(_, [PVariable(variableAt, name)], [], body)@c])@l
            )]} {
                !effectTypeIsAsync(call.effect)
            } =>
                let n = name.map {escapeResolved(_)}.else {"i"}
                let newAsync = self.emittingAsync && effectTypeIsAsync(call.effect)
                if(newAsync) {self.writeMapped(term.at, "await ")}
                self.writeMapped(term.at, "((() => {")
                self.writeLine()
                self.writeMapped(term.at, "const size = ")
                self.emitTerm(size, async) // Not correct if async and body isn't
                self.writeMapped(term.at, ";")
                self.writeLine()
                self.writeMapped(term.at, "const result = [];")
                self.writeMapped(term.at, "for(let ")
                self.writeNamed(name.else {"_"}, variableAt, n)
                self.writeMapped(term.at, " = 0; ")
                self.writeNamed(name.else {"_"}, variableAt, n)
                self.writeMapped(term.at, " < size; ")
                self.writeNamed(name.else {"_"}, variableAt, n)
                self.writeMapped(term.at, "++) {")
                self.writeLine()
                self.writeMapped(term.at, "result.push(")
                self.emitTerm(body, newAsync)
                self.writeMapped(term.at, ");")
                self.writeLine()
                self.writeMapped(term.at, "}")
                self.writeLine()
                self.writeMapped(term.at, "return result;")
                self.writeLine()
                self.writeMapped(term.at, "})())")
                True
            | "ff:core/Js.import" {arguments | [EString(at, url)]} =>
                self.emitTarget.{
                    | EmitBrowser => 
                        self.writeMapped(at, "(() => {throw new Error('Node.js imports are not supported in the browser')})()")
                    | _ => 
                        self.writeMapped(at, self.jsImporter.add(url.replace("\"", "")))
                }
                True
            | "ff:core/Js.browserImport" {arguments | [EString(at, url)]} =>
                self.emitTarget.{
                    | EmitBrowser => 
                        self.writeMapped(at, self.jsImporter.add(url.replace("\"", "")))
                    | _ => 
                        self.writeMapped(at, "(() => {throw new Error('Browser imports are not supported in Node.js')})()")
                }
                True
            | "ff:core/Js.dynamicImport" {arguments | [url]} =>
                self.writeMapped(term.at, "import(")
                self.emitTerm(url, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/Js.await" {arguments | [body]} =>
                if(async) {
                    self.writeMapped(term.at, "(await ")
                    self.emitTerm(body, async)
                    self.writeMapped(term.at, ")")
                } else {
                    self.emitTerm(body, async)
                }
                True
            | name {name.removeFirst("ff:core/Js.async") | Some(n)} {n.all {_.isAsciiDigit()}} {
                arguments | [ELambda(at, Lambda(_, effect, [MatchCase(_, patterns, [], body)]))]
            } {
                patterns.all {| PVariable _ => True | _ => False }
            } =>
                let patternParameters = patterns.map {
                    | PVariable p => p.name.map(escapeKeyword).else {"_"}
                    | _ => panic("!")
                }
                self.writeMapped(term.at, "async (" + patternParameters.join(", ") + ") => {")
                self.writeLine()
                self.emitStatements(body, True, False, False)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | name {name.startsWith("ff:core/Js.async")} =>
                throw(CompileError(term.at, "JS async functions must take a simple parameter list"))
            | "ff:core/Js.cancelled" =>
                self.writeMapped(term.at, if(async) {"$task.controller_.signal.aborted"} else {"false"})
                True
            | "ff:core/Js.throwIfCancelled" =>
                if(async) {self.writeMapped(term.at, "((() => ff_core_Task.Task_throwIfAborted($task))())")}
                True
            | "ff:core/Js.currentTask" =>
                self.writeMapped(term.at, "$task")
                True
            | "ff:core/Js.controller" =>
                self.writeMapped(term.at, "$task.controller_")
                True
            | "ff:core/Js.setController" {arguments | [a]} =>
                self.writeMapped(term.at, "($task.controller_ = ")
                self.emitTerm(a, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/Js.inAsync" =>
                self.writeMapped(term.at, if(self.emittingAsync) {"true"} else {"false"})
                True
            | "ff:core/Js.inBrowser" =>
                self.writeMapped(term.at, if(self.emitTarget == EmitBrowser) {"true"} else {"false"})
                True
            | "ff:core/Js.inNode" =>
                self.writeMapped(term.at, if(self.emitTarget == EmitNode) {"true"} else {"false"})
                True
            | "ff:core/Js.inBuild" =>
                self.writeMapped(term.at, if(self.emitTarget == EmitBuild) {"true"} else {"false"})
                True
            | "ff:core/Js.value" {arguments | [e]} =>
                self.emitTerm(e, async)
                True
            | "ff:core/Js.fromValue" {arguments | [e]} =>
                self.emitTerm(e, async)
                True
            | "ff:core/Js.rawIdentifier" {arguments | [EString(at, op)]} =>
                self.writeMapped(at, op.replace("\"", ""))
                True
            | "ff:core/Js.unaryOperator" {arguments | [EString(at, op), a1]} =>
                self.writeMapped(term.at, "(")
                self.writeMapped(at, op.replace("\"", ""))
                self.emitTerm(a1, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/Js.binaryOperator" {arguments | [EString(at, op), a1, a2]} =>
                self.writeMapped(term.at, "(")
                self.emitTerm(a1, async)
                self.writeMapped(term.at, " ")
                self.writeMapped(at, op.replace("\"", ""))
                self.writeMapped(term.at, " ")
                self.emitTerm(a2, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/Js.shortCircuitingOperator" {arguments | [EString(at, op), a1, a2]} =>
                self.writeMapped(term.at, "(")
                self.emitTerm(a1, async)
                self.writeMapped(term.at, " ")
                self.writeMapped(at, op.replace("\"", ""))
                self.writeMapped(term.at, " ")
                self.emitTerm(invokeImmediately(a2), async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/JsValue.JsValue_spreadToArray" {arguments | [e1]} =>
                self.writeMapped(term.at, "[...")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, "]")
                True
            | "ff:core/JsValue.JsValue_typeof" {arguments | [e]} =>
                self.writeMapped(term.at, "(typeof ")
                self.emitTerm(e, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/JsValue.JsValue_instanceof" {arguments | [e1, e2]} =>
                self.writeMapped(term.at, "(")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, " instanceof ")
                self.emitTerm(e2, async)
                self.writeMapped(term.at, ")")
                True
            | "ff:core/JsValue.JsValue_get" {arguments | [e1, e2]} =>
                self.emitTerm(e1, async)
                self.emitField(e2, async)
                True
            | "ff:core/JsValue.JsValue_equals" {arguments | [e1, e2]} =>
                self.writeMapped(term.at, "(")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, " === ")
                self.emitTerm(e2, async)
                self.writeMapped(term.at, ")")
                True                
            | "ff:core/JsValue.JsValue_notEquals" {arguments | [e1, e2]} =>
                self.writeMapped(term.at, "(")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, " !== ")
                self.emitTerm(e2, async)
                self.writeMapped(term.at, ")")
                True                
            | "ff:core/Int.Int_bitAnd" {arguments | [e1, e2]} =>
                self.writeMapped(term.at, "(")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, " & ")
                self.emitTerm(e2, async)
                self.writeMapped(term.at, ")")
                True                
            | "ff:core/Int.Int_bitRightUnsigned" {arguments | [e1, e2]} =>
                self.writeMapped(term.at, "(")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, " >>> ")
                self.emitTerm(e2, async)
                self.writeMapped(term.at, ")")
                True                
            | "ff:core/Int.Int_bitRight" {arguments | [e1, e2]} =>
                self.writeMapped(term.at, "(")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, " >> ")
                self.emitTerm(e2, async)
                self.writeMapped(term.at, ")")
                True                
            | name {name.removeFirst("ff:core/JsValue.JsValue_call") | Some(n)} {n.all {_.isAsciiDigit()}} {
                arguments | [e1, e2, ...es]
            } =>
                self.emitTerm(e1, async)
                self.emitField(e2, async)
                self.writeMapped(term.at, "(")
                let comma = Comma(self)
                es.each {
                    comma.writeComma()
                    self.emitTerm(_, async)
                }
                self.writeMapped(term.at, ")")
                True
            | name {name.removeFirst("ff:core/JsValue.JsValue_callValue") | Some(n)} {n.all {_.isAsciiDigit()}} {
                arguments | [e1, ...es]
            } =>
                self.emitTerm(e1, async)
                self.writeMapped(term.at, "(")
                let comma = Comma(self)
                es.each {
                    comma.writeComma()
                    self.emitTerm(_, async)
                }
                self.writeMapped(term.at, ")")
                True
            | name {name.removeFirst("ff:core/JsValue.JsValue_new") | Some(n)} {n.all {_.isAsciiDigit()}} {
                arguments | [e1, ...es]
            } =>
                self.writeMapped(term.at, "(new ")
                self.emitTerm(e1, async)
                self.writeMapped(term.at, "(")
                let comma = Comma(self)
                es.each {
                    comma.writeComma()
                    self.emitTerm(_, async)
                }
                self.writeMapped(term.at, "))")
                True
            | name {name == "ff:core/JsValue.JsValue_with" || name == "ff:core/Json.Json_with"} =>
                function go(e: Term, fields: List[Pair[Term, Term]]) {
                    e.{
                        | ECall(_, StaticCall(n, _, _), _, _, [a1, a2, a3], _) {n == name} =>
                            go(a1.value, [Pair(a2.value, a3.value), ...fields])
                        | ECall(_, StaticCall(n, _, _), _, _, as, _) {
                            n == "ff:core/JsSystem.JsSystem_object" || 
                            n == "ff:core/JsSystem.JsSystem_new0" ||
                            n == "ff:core/Js.object" || 
                            n == "ff:core/Js.new0" ||
                            n == "ff:core/Json.Json_object" ||
                            n == "ff:core/Json.Json_new0"
                        } {
                            as.all {noSideEffects(_.value)}
                        } =>
                            self.writeMapped(e.at, "{")
                            let comma = Comma(self)
                            fields.each {p =>
                                comma.writeComma()
                                self.emitField(p.first, async, dot = "")
                                self.writeMapped(e.at, ": ")
                                self.emitTerm(p.second, async)
                            }
                            self.writeMapped(e.at, "}")
                        | _ =>
                            self.writeMapped(e.at, "{...")
                            self.emitTerm(e, async)
                            fields.each {p =>
                                self.writeMapped(e.at, ", ")
                                self.emitField(p.first, async, dot = "")
                                self.writeMapped(e.at, ": ")
                                self.emitTerm(p.second, async)
                            }
                            self.writeMapped(e.at, "}")
                    }
                }
                go(term, [])
                True
            | name {name.removeFirst("ff:core/JsSystem.JsSystem_call") | Some(n)} {n.all {_.isAsciiDigit()}} {
                arguments | [e1, EString(at, q)@e2, ...es]
            } {noSideEffects(e1)} =>
                safeBare(q).{
                    | Some(bare) => self.writeNamed(q, at, bare)
                    | None => 
                        self.writeMapped(term.at, "globalThis[")
                        self.emitTerm(e2, async)
                        self.writeMapped(term.at, "]")
                }
                self.writeMapped(term.at, "(")
                let comma = Comma(self)
                es.each {
                    comma.writeComma()
                    self.emitTerm(_, async)
                }
                self.writeMapped(term.at, ")")
                True
            | name {name.removeFirst("ff:core/JsSystem.JsSystem_function") | Some(n)} {n.all {_.isAsciiDigit()}} {
                arguments | [e1, e2]
            } {noSideEffects(e1)} {term | ECall call} {!effectTypeIsAsync(call.effect)} =>
                self.emitTerm(e2, async)
                True
            | "ff:core/JsSystem.JsSystem_get" {arguments | [e1, EString(at, q)@e2]} {noSideEffects(e1)} =>
                safeBare(q).{
                    | Some(bare) => self.writeNamed(q, at, bare)
                    | None => 
                        self.writeMapped(term.at, "globalThis[")
                        self.emitTerm(e2, async)
                        self.writeMapped(term.at, "]")
                }
                True
            | "ff:core/JsSystem.JsSystem_object" {arguments | [e]} {noSideEffects(e)} =>
                self.writeMapped(term.at, "{}")
                True
            | "ff:core/JsSystem.JsSystem_new0" {arguments | [e]} {noSideEffects(e)} =>
                self.writeMapped(term.at, "{}")
                True
            | "ff:core/JsSystem.JsSystem_null" {arguments | [e]} {noSideEffects(e)} =>
                self.writeMapped(term.at, "null")
                True
            | "ff:core/JsSystem.JsSystem_undefined" {arguments | [e]} {noSideEffects(e)} =>
                self.writeMapped(term.at, "(void 0)")
                True
            | name {name.removeFirst("ff:core/Js.call") | Some(n)} {n.all {_.isAsciiDigit()}} {
                arguments | [EString(at, q)@e1, ...es]
            } =>
                safeBare(q).{
                    | Some(bare) => self.writeNamed(q, at, bare)
                    | None => 
                        self.writeMapped(term.at, "globalThis[")
                        self.emitTerm(e1, async)
                        self.writeMapped(term.at, "]")
                }
                self.writeMapped(term.at, "(")
                let comma = Comma(self)
                es.each {
                    comma.writeComma()
                    self.emitTerm(_, async)
                }
                self.writeMapped(term.at, ")")
                True
            | name {name.removeFirst("ff:core/Js.function") | Some(n)} {n.all {_.isAsciiDigit()}} {
                arguments | [e1]
            } {term | ECall call} =>
                if(self.emittingAsync && effectTypeIsAsync(call.effect)) {
                    let argumentCode = 1.to(n.grabInt()).map {"a_" + _}.join(", ")
                    let taskCode = if(argumentCode == "") {"$task"} else {", $task"}
                    self.writeMapped(term.at, "(async (" + argumentCode + ") => await ")
                    self.emitTerm(e1, async)
                    self.writeMapped(term.at, "(" + argumentCode + taskCode + "))")
                } else {
                    self.emitTerm(e1, async)
                }
                True
            | "ff:core/Js.get" {arguments | [EString(at, q)@e1]} =>
                safeBare(q).{
                    | Some(bare) => self.writeNamed(q, at, bare)
                    | None => 
                        self.writeMapped(term.at, "globalThis[")
                        self.emitTerm(e1, async)
                        self.writeMapped(term.at, "]")
                }
                True
            | "ff:core/Js.object" =>
                self.writeMapped(term.at, "{}")
                True
            | "ff:core/Js.new0" =>
                self.writeMapped(term.at, "{}")
                True
            | "ff:core/Js.null" =>
                self.writeMapped(term.at, "null")
                True
            | "ff:core/Js.undefined" =>
                self.writeMapped(term.at, "(void 0)")
                True
            | "ff:core/Js.globalThis" =>
                self.writeMapped(term.at, "globalThis")
                True
            | "ff:core/BrowserSystem.BrowserSystem_js" {arguments | [e]} {noSideEffects(e)} => 
                self.writeMapped(term.at, "globalThis")
                True
            | "ff:core/BuildSystem.BuildSystem_js" {arguments | [e]} {noSideEffects(e)} => 
                self.writeMapped(term.at, "globalThis")
                True
            | "ff:core/NodeSystem.NodeSystem_js" {arguments | [e]} {noSideEffects(e)} => 
                self.writeMapped(term.at, "globalThis")
                True
            | "ff:core/Js.jsSystem" =>
                self.writeMapped(term.at, "globalThis")
                True
            | "ff:core/Json.string" {arguments | [e]} =>
                self.emitTerm(e, async)
                True
            | "ff:core/Json.int" {arguments | [e]} =>
                self.emitTerm(e, async)
                True
            | "ff:core/Json.float" {arguments | [e]} =>
                self.emitTerm(e, async)
                True
            | "ff:core/Json.bool" {arguments | [e]} =>
                self.emitTerm(e, async)
                True
            | "ff:core/Json.array" {arguments | [e]} =>
                self.emitTerm(e, async)
                True
            | "ff:core/Json.null" {arguments | [e]} =>
                self.writeMapped(term.at, "null")
                True
            | "ff:core/Json.object" {arguments | [e]} =>
                self.writeMapped(term.at, "{}")
                True
            | _ =>
                False
        }
    }
    
    emitSpecialStatement(
        term: Term 
        last: Bool 
        async: Bool 
        name: String
        arguments: List[Term]
        dictionaries: List[Dictionary]
    ): Bool {
        name.{
            | "ff:core/Core.while" {arguments | [condition, body]} =>
                self.writeMapped(term.at, "while")
                self.writeMapped(term.at, "(")
                self.emitTerm(invokeImmediately(condition), async)
                self.writeMapped(term.at, ") {")
                self.writeLine()
                self.emitStatements(invokeImmediately(body), False, False, async)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | "ff:core/Core.doWhile" {arguments | [doWhileBody]} {
                invokeImmediately(doWhileBody) | body
            } =>
                self.writeMapped(term.at, "while")
                self.writeMapped(term.at, "(true) {")
                self.writeLine()
                self.emitStatements(body, False, True, async)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | "ff:core/Option.Option_each" {arguments | [list, ELambda(_, Lambda(_, _, [
                MatchCase(_, [PVariable(nameAt, name)], [], body)
            ]))]} =>
                self.writeMapped(term.at, "{")
                self.writeLine()
                self.writeMapped(term.at, "const if_o = ")
                self.emitTerm(list, async)
                self.writeLine()
                self.writeMapped(term.at, "if(if_o.Some) {")
                self.writeLine()
                name.each {n => 
                    self.writeMapped(term.at, "const ")
                    self.writeNamed(n, nameAt, escapeKeyword(n))
                    self.writeMapped(term.at, " = if_o.value_;")
                    self.writeLine()
                }
                self.emitStatements(body, last, False, async)
                self.writeLine()
                self.writeMapped(term.at, "}")
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | n {n == "ff:core/List.List_each" || n == "ff:core/List.List_eachWhile"} {arguments | [
                ECall(_, StaticCall(r, _, _), _, _, [start, end], _)
                ELambda(_, Lambda(_, _, [MatchCase(_, [PVariable(nameAt, name)], [], body)]))
            ]} {r == "ff:core/Int.Int_until" || r == "ff:core/Int.Int_to"} =>
                self.writeMapped(term.at, "for")
                self.writeMapped(term.at, "(let for_i = ")
                self.emitTerm(start.value, async)
                self.writeMapped(term.at, ", for_e = ")
                self.emitTerm(end.value, async)
                let op = if(r == "ff:core/Int.Int_until") {"<"} else {"<="}
                self.writeMapped(term.at, "; for_i " + op + " for_e; for_i++) {")
                self.writeLine()
                name.each {n => 
                    self.writeMapped(term.at, "const ")
                    self.writeNamed(n, nameAt, escapeKeyword(n))
                    self.writeMapped(term.at, " = for_i;")
                    self.writeLine()
                }
                self.emitStatements(body, last, n.endsWith("eachWhile"), async)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | n {n == "ff:core/List.List_each" || n == "ff:core/List.List_eachWhile"} {arguments | [
                ECall(_, StaticCall("ff:core/List.List_reverse", _, _), _, _, [
                    Argument(_, _, ECall(_, StaticCall(r, _, _), _, _, [start, end], _))
                ], _)
                ELambda(_, Lambda(_, _, [MatchCase(_, [PVariable(nameAt, name)], [], body)]))
            ]} {r == "ff:core/Int.Int_until" || r == "ff:core/Int.Int_to"} =>
                self.writeMapped(term.at, "for")
                self.writeMapped(term.at, "(let for_e = ")
                self.emitTerm(start.value, async)
                self.writeMapped(term.at, ", for_i = ")
                self.emitTerm(end.value, async)
                if(r == "ff:core/Int.Int_until") {self.writeMapped(term.at, " - 1")}
                self.writeMapped(term.at, "; for_i >= for_e; for_i--) {")
                self.writeLine()
                name.each {n => 
                    self.writeMapped(term.at, "const ")
                    self.writeNamed(n, nameAt, escapeKeyword(n))
                    self.writeMapped(term.at, " = for_i;")
                    self.writeLine()
                }
                self.emitStatements(body, last, n.endsWith("eachWhile"), async)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | n {n == "ff:core/List.List_each" || n == "ff:core/List.List_eachWhile"} {arguments | [
                ECall(_, StaticCall("ff:core/List.List_zip", _, _), _, _, [list1, list2], _)
                ELambda(_, Lambda(_, _, [MatchCase(_, [
                    PVariant(_, "ff:core/Pair.Pair", [PVariable(at1, name1), PVariable(at2, name2)])
                ], [], body)]))
            ]} =>
                self.writeMapped(term.at, "for(let ")
                self.emitLightFusion("", list1.value, n.startsWith("ff:core/Array."), async)
                self.writeMapped(term.at, ", ")
                self.emitLightFusion("2", list2.value, n.startsWith("ff:core/Array."), async)
                self.writeMapped(term.at, "; for_i < for_l && for_i2 < for_l2; for_i++, for_i2++) {")
                self.writeLine()
                name1.each {
                    self.writeMapped(at1, "const " + escapeKeyword(_) + " = for_a[for_i];")
                    self.writeLine()
                }
                name2.each {
                    self.writeMapped(at2, "const " + escapeKeyword(_) + " = for_a2[for_i2];")
                    self.writeLine()
                }
                self.emitStatements(body, last, n.endsWith("eachWhile"), async)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | n {n == "ff:core/List.List_each" || n == "ff:core/List.List_eachWhile"} {arguments | [
                ECall(_, StaticCall("ff:core/List.List_pairs", _, _), _, _, [list1], _)
                ELambda(_, Lambda(_, _, [MatchCase(_, [
                    PVariant(_, "ff:core/Pair.Pair", [PVariable(at1, name1), PVariable(at2, name2)])
                ], [], body)]))
            ]} =>
                self.writeMapped(term.at, "for(let ")
                self.emitLightFusion("", list1.value, n.startsWith("ff:core/Array."), async)
                self.writeMapped(term.at, "; for_i < for_l; for_i++) {")
                self.writeLine()
                name1.each {
                    self.writeMapped(at1, "const " + escapeKeyword(_) + " = for_i;")
                    self.writeLine()
                }
                name2.each {
                    self.writeMapped(at2, "const " + escapeKeyword(_) + " = for_a[for_i];")
                    self.writeLine()
                }
                self.emitStatements(body, last, n.endsWith("eachWhile"), async)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | n {
                n == "ff:core/List.List_each" || n == "ff:core/List.List_eachWhile" || 
                n == "ff:core/Array.Array_each" || n == "ff:core/Array.Array_eachWhile"
            } {
                arguments | [list1, ELambda(_, Lambda(_, _, [MatchCase(_, [PVariable(at1, name1)], [], body)]))]
            } =>
                self.writeMapped(term.at, "for(let ")
                self.emitLightFusion("", list1, n.startsWith("ff:core/Array."), async)
                self.writeMapped(term.at, "; for_i < for_l; for_i++) {")
                self.writeLine()
                name1.each {
                    self.writeMapped(at1, "const " + escapeKeyword(_) + " = for_a[for_i];")
                    self.writeLine()
                }
                self.emitStatements(body, last, n.endsWith("eachWhile"), async)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | "ff:core/Array.Array_push" {arguments | [array, value]} =>
                self.emitTerm(array, async)
                self.writeMapped(array.at, ".array.push(")
                self.emitTerm(value, async)
                self.writeMapped(array.at, ")")
                True
            | "ff:core/Core.if" {arguments | [condition, body]} =>
                self.writeMapped(condition.at, "if(")
                self.emitTerm(condition, async)
                self.writeMapped(condition.at, ") {")
                self.writeLine()
                if(last) {
                    self.writeMapped(term.at, "return ff_core_Option.Some(")
                    self.emitTerm(invokeImmediately(body), async)
                    self.writeMapped(term.at, ")")
                } else {
                    self.emitStatements(invokeImmediately(body), False, False, async)
                }
                self.writeLine()
                self.writeMapped(term.at, "}")
                if(last) {self.writeMapped(term.at, " else return ff_core_Option.None()")}
                True
            | "ff:core/Core.throw" {term | ECall c} {c.arguments | [argument]} {dictionaries | [dictionary]} =>
                self.writeMapped(term.at, "throw Object.assign(new Error(), {ffException: ff_core_Any.toAny_(")
                self.writeMapped(term.at, self.makeDictionary(dictionary))
                self.writeMapped(term.at, ", ")
                self.emitArgument(term.at, argument, async)
                self.writeMapped(term.at, ")})")
                True
            | "ff:core/Try.Try_catch" {self.emitTryCatchFinally(term, last, async)} =>
                True
            | "ff:core/Try.Try_catchAny" {self.emitTryCatchFinally(term, last, async)} =>
                True
            | "ff:core/Try.Try_finally" {self.emitTryCatchFinally(term, last, async)} =>
                True
            | "ff:core/Js.throwIfCancelled" =>
                if(async) {self.writeMapped(term.at, "ff_core_Task.Task_throwIfAborted($task)")}
                True
            | "ff:core/Js.throw" {term | ECall c} {c.arguments | [argument]} =>
                self.writeMapped(term.at, "throw ")
                self.emitTerm(argument.value, async)
                True
            | _ =>
                False
        }
    }
    
    emitLightFusion(
        suffix: String
        list: Term
        isArray: Bool
        async: Bool
    ) {
        function wrapUnlessInt(term: Term, before: String, after: String) {
            | EInt _, _, _ =>
                self.emitTerm(term, async)
            | _, _, _ =>
                if(before != "") {self.writeMapped(term.at, before)}
                self.emitTerm(term, async)
                if(after != "") {self.writeMapped(term.at, after)}
        }
        list.{
            | ECall(_, StaticCall("ff:core/List.List_dropFirst", _, _), _, _, [a1, a2], _) =>
                self.writeMapped(list.at, "for_a" + suffix + " = ")
                self.emitTerm(a1.value, async)
                if(isArray) {self.writeMapped(list.at, ".array")}
                self.writeMapped(list.at, ", for_i" + suffix + " = ")
                wrapUnlessInt(a2.value, "Math.max(", ", 0)")
                self.writeMapped(list.at, ", for_l" + suffix + " = ")
                self.writeMapped(list.at, "for_a" + suffix + ".length")
            | ECall(_, StaticCall("ff:core/List.List_dropLast", _, _), _, _, [a1, a2], _) =>
                self.writeMapped(list.at, "for_a" + suffix + " = ")
                self.emitTerm(a1.value, async)
                if(isArray) {self.writeMapped(list.at, ".array")}
                self.writeMapped(list.at, ", for_i" + suffix + " = 0")
                self.writeMapped(list.at, ", for_l" + suffix + " = ")
                self.writeMapped(list.at, "for_a" + suffix + ".length - ")
                wrapUnlessInt(a2.value, "Math.max(", ", 0)")
            | ECall(_, StaticCall("ff:core/List.List_takeFirst", _, _), _, _, [a1, a2], _) =>
                self.writeMapped(list.at, "for_a" + suffix + " = ")
                self.emitTerm(a1.value, async)
                if(isArray) {self.writeMapped(list.at, ".array")}
                self.writeMapped(list.at, ", for_i" + suffix + " = 0")
                self.writeMapped(list.at, ", for_l" + suffix + " = ")
                self.writeMapped(list.at, "Math.min(")
                wrapUnlessInt(a2.value, "Math.max(", ", 0)")
                self.writeMapped(list.at, ", for_a" + suffix + ".length)")
            | ECall(_, StaticCall("ff:core/List.List_takeLast", _, _), _, _, [a1, a2], _) =>
                self.writeMapped(list.at, "for_a" + suffix + " = ")
                self.emitTerm(a1.value, async)
                if(isArray) {self.writeMapped(list.at, ".array")}
                self.writeMapped(list.at, ", for_i" + suffix + " = ")
                self.writeMapped(list.at, "Math.max(for_a" + suffix + ".length - ")
                wrapUnlessInt(a2.value, "Math.max(", ", 0)")
                self.writeMapped(list.at, ", 0), for_l" + suffix + " = ")
                self.writeMapped(list.at, "for_a" + suffix + ".length")
            | _ => 
                self.writeMapped(list.at, "for_a" + suffix + " = ")
                self.emitTerm(list, async)
                if(isArray) {self.writeMapped(list.at, ".array")}
                self.writeMapped(list.at, ", for_i" + suffix + " = 0")
                self.writeMapped(list.at, ", for_l" + suffix + " = ")
                self.writeMapped(list.at, "for_a" + suffix + ".length")
        } 
    }

    emitTryCatchFinally(term: Term, last: Bool, async: Bool): Bool {
        function emitCatch(catchEffect: Type, cases: List[MatchCase]) {
            let catchAsync = self.emittingAsync && effectTypeIsAsync(catchEffect)
            Patterns.convertAndCheck(self.otherModules, cases)
            let arguments = [
                {self.writeMapped(term.at, "_exception.value_")}
                {self.writeMapped(term.at, "_error")}
            ]
            cases.{
                | [case] =>
                    self.emitCase(arguments, case, [], [], False, last, False, True, catchAsync)
                | cs =>
                    if(last) {
                        self.writeMapped(term.at, "do {")
                        self.writeLine()
                    }
                    let liner = Liner(self, double = False)
                    cases.pairs().each {| Pair(i, c) =>
                        liner.writeLines()
                        let lastCase = i == cases.size() - 1
                        self.emitCase(arguments, c, [], [], True, last, False, lastCase, catchAsync)
                    }
                    if(last) {
                        self.writeLine()
                        self.writeMapped(term.at, "} while(false)")
                    } else {}
            }
        }
        term.{
            | ECall(_, StaticCall("ff:core/Try.Try_finally", _, _), _, _, [
                Argument(_, _, ECall(_, StaticCall("ff:core/Core.try", _, _), _, _, [
                    Argument(_, _, ELambda(_, Lambda(_, tryEffect, [MatchCase(_, [], [], tryBody)])))
                ], _))
                Argument(_, _, ELambda(_, Lambda(_, finallyEffect, [MatchCase(_, [], [], finallyBody)])))
            ], _) =>
                let tryAsync = self.emittingAsync && effectTypeIsAsync(tryEffect)
                let finallyAsync = self.emittingAsync && effectTypeIsAsync(finallyEffect)
                self.writeMapped(term.at, "try {")
                self.writeLine()
                self.emitStatements(tryBody, last, False, tryAsync)
                self.writeLine()
                self.writeMapped(term.at, "} finally {")
                self.writeLine()
                self.emitStatements(finallyBody, last, False, finallyAsync)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | ECall(_, StaticCall("ff:core/Try.Try_catchAny", _, _), _, _, [
                Argument(_, _, ECall(_, StaticCall("ff:core/Core.try", _, _), _, _, [
                    Argument(_, _, ELambda(_, Lambda(_, tryEffect, [MatchCase(_, [], [], tryBody)])))
                ], _))
                Argument(_, _, ELambda(_, Lambda(_, catchEffect, [
                    MatchCase(_, [PVariable(nameAt, name)], [], catchBody)
                ])))
            ], _) =>
                let tryAsync = self.emittingAsync && effectTypeIsAsync(tryEffect)
                self.writeMapped(term.at, "try {")
                self.writeLine()
                self.emitStatements(tryBody, last, False, tryAsync)
                self.writeLine()
                self.writeMapped(term.at, "} catch")
                name.each {n =>
                    self.writeMapped(nameAt, "(")
                    self.writeNamed(n, nameAt, escapeKeyword(n))
                    self.writeMapped(nameAt, ")")
                }
                self.writeMapped(term.at, " {")
                self.writeLine()
                self.emitStatements(catchBody, last, False, tryAsync)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | ECall(_, StaticCall("ff:core/Try.Try_catch", _, _), _, _, [
                Argument(_, _, ECall(_, StaticCall("ff:core/Core.try", _, _), _, _, [
                    Argument(_, _, ELambda(_, Lambda(_, tryEffect, [MatchCase(_, [], [], tryBody)])))
                ], _))
                Argument(_, _, ELambda(_, Lambda(_, catchEffect, cases)))
            ], [dictionary]) =>
                let tryAsync = self.emittingAsync && effectTypeIsAsync(tryEffect)
                let d = self.makeDictionary(dictionary)
                self.writeMapped(term.at, "try {")
                self.writeLine()
                self.emitStatements(tryBody, last, False, tryAsync)
                self.writeLine()
                self.writeMapped(term.at, "} catch(_error) {")
                self.writeLine()
                self.writeMapped(term.at, "if(!_error.ffException) throw _error")
                self.writeLine()
                self.writeMapped(term.at, "const _exception = ff_core_Any.fromAny_(_error.ffException, ")
                self.writeMapped(term.at, d)
                self.writeMapped(term.at, ")")
                self.writeLine()
                self.writeMapped(term.at, "if(!_exception.Some) throw _error")
                self.writeLine()
                emitCatch(catchEffect, cases)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | ECall(_, StaticCall("ff:core/Try.Try_finally", _, _), _, _, [
                Argument(_, _, ECall(_, StaticCall("ff:core/Try.Try_catch", _, _), _, _, [
                    Argument(_, _, ECall(_, StaticCall("ff:core/Core.try", _, _), _, _, [
                        Argument(_, _, ELambda(_, Lambda(_, tryEffect, [MatchCase(_, [], [], tryBody)])))
                    ], _))
                    Argument(_, _, ELambda(_, Lambda(_, catchEffect, cases)))
                ], [dictionary]))
                Argument(_, _, ELambda(_, Lambda(_, finallyEffect, [MatchCase(_, [], [], finallyBody)])))
            ], _) =>
                let tryAsync = self.emittingAsync && effectTypeIsAsync(tryEffect)
                let finallyAsync = self.emittingAsync && effectTypeIsAsync(finallyEffect)
                let d = self.makeDictionary(dictionary)
                self.writeMapped(term.at, "try {")
                self.writeLine()
                self.emitStatements(tryBody, last, False, tryAsync)
                self.writeLine()
                self.writeMapped(term.at, "} catch(_error) {")
                self.writeLine()
                self.writeMapped(term.at, "if(!_error.ffException) throw _error")
                self.writeLine()
                self.writeMapped(term.at, "const _exception = ff_core_Any.fromAny_(_error.ffException, ")
                self.writeMapped(term.at, d)
                self.writeMapped(term.at, ")")
                self.writeLine()
                self.writeMapped(term.at, "if(!_exception.Some) throw _error")
                self.writeLine()
                emitCatch(catchEffect, cases)
                self.writeLine()
                self.writeMapped(term.at, "} finally {")
                self.writeLine()
                self.emitStatements(finallyBody, last, False, finallyAsync)
                self.writeLine()
                self.writeMapped(term.at, "}")
                True
            | _ =>
                False
        }
    }

    emitCase(
        arguments: List[() => Unit]
        matchCase: MatchCase
        conditions: List[() => Unit]
        variables: List[() => Unit]
        jump: Bool
        last: Bool
        break: Bool
        lastCase: Bool
        async: Bool
    ) {
        function emitWrapperStart() {
            if(conditions.isEmpty()) {
                self.writeMapped(matchCase.at, "{")
            } else {
                self.writeMapped(matchCase.at, "if(")
                conditions.pairs().each {| Pair(i, c) => 
                    c()
                    if(i < conditions.size() - 1) {
                        self.writeMapped(matchCase.at, " && ")
                    }
                }
                self.writeMapped(matchCase.at, ") {")
            }
            self.writeLine()
            variables.each {_()}
        }

        function emitWrapperEnd() {
            self.writeLine()
            self.writeMapped(matchCase.at, "}")
        }

        Pair(matchCase.patterns, matchCase.guards).{
            | Pair([p, ...ps], _) =>
                self.emitPattern(
                    arguments.grab(0)
                    p
                    arguments.dropFirst()
                    matchCase.MatchCase(patterns = ps)
                    conditions
                    variables
                    jump
                    last
                    break
                    lastCase
                    async
                )
            | Pair([], [MatchGuard(_, e, PVariant(_, "ff:core/Bool.True", _))]) {variables.isEmpty()} =>
                let newCase = matchCase.MatchCase(patterns = [], guards = [])
                self.emitCase([], newCase, [...conditions, {self.emitTerm(e, async)}], [], jump, last, break, lastCase, async)
            | Pair([], [MatchGuard(_, e, PVariant(_, "ff:core/Bool.True", _))]) =>
                let newCase = matchCase.MatchCase(patterns = [], guards = [])
                emitWrapperStart()
                self.emitCase([], newCase, [{self.emitTerm(e, async)}], [], jump, last, break, lastCase, async)
                emitWrapperEnd()
            | Pair([], [guard, ...guards]) =>
                let guardName = "_guard" + (guards.size() + 1)
                let newCase = matchCase.MatchCase(patterns = [guard.pattern], guards = guards)
                emitWrapperStart()
                self.writeMapped(guard.at, "const " + guardName + " = ")
                self.emitTerm(guard.term, async)
                self.writeMapped(guard.at, ";")
                self.writeLine()
                self.emitCase([{self.writeMapped(guard.at, guardName)}], newCase, [], [], jump, last, break, lastCase, async)
                emitWrapperEnd()
            | Pair([], []) =>
                emitWrapperStart()
                self.emitStatements(matchCase.body, last, break, async)
                let returns = self.writtenStrings.last().any {line => 
                    line.first().any {part => 
                        part.startsWith("return ") || 
                        part.startsWith("break ") ||
                        part.startsWith("continue ") ||
                        part.startsWith("return;") || 
                        part.startsWith("break;") ||
                        part.startsWith("continue;") ||
                        part.startsWith("throw ")
                    }
                }
                if(jump && last && !returns) {
                    self.writeLine()
                    self.writeMapped(matchCase.at, "return")
                } elseIf {jump && !returns && !lastCase} {
                    self.writeLine()
                    self.writeMapped(matchCase.at, if(break) {"continue"} else {"break"})
                }
                emitWrapperEnd()
        }
    }

    emitPattern(
        argument: () => Unit
        pattern: MatchPattern
        arguments: List[() => Unit]
        matchCase: MatchCase
        conditions: List[() => Unit]
        variables: List[() => Unit]
        jump: Bool
        last: Bool
        break: Bool
        lastCase: Bool
        async: Bool
    ) {
        function addUnaryCondition(at: Location, operator: String, right: () => Unit): List[() => Unit] {
            addCondition {
                self.writeMapped(at, operator)
                right()
            }
        }
        function addBinaryCondition(at: Location, operator: String, left: () => Unit, right: () => Unit): List[() => Unit] {
            addCondition {
                left()
                self.writeMapped(at, " " + operator + " ")
                right()
            }
        }
        function addCondition(condition: () => Unit): List[() => Unit] {
            if(lastCase) {conditions} else {[...conditions, condition]}
        }
        pattern.{
            | PString(_, value) =>
                let newConditions = addBinaryCondition(pattern.at, "===", argument, {self.writeMapped(pattern.at, value)})
                self.emitCase(arguments, matchCase, newConditions, variables, jump, last, break, lastCase, async)
            | PInt(_, value) =>
                let newConditions = addBinaryCondition(pattern.at, "===", argument, {self.writeMapped(pattern.at, value)})
                self.emitCase(arguments, matchCase, newConditions, variables, jump, last, break, lastCase, async)
            | PChar(_, value) =>
                let newConditions = addBinaryCondition(pattern.at, "===", argument, {self.writeMapped(pattern.at, charLiteralToNumber(value))})
                self.emitCase(arguments, matchCase, newConditions, variables, jump, last, break, lastCase, async)
            | PVariable(_, None) =>
                self.emitCase(arguments, matchCase, conditions, variables, jump, last, break, lastCase, async)
            | PVariable(at, Some(name)) =>
                let newVariables = [...variables, {
                    self.writeMapped(at, "const ")
                    self.writeNamed(name, at, escapeKeyword(name))
                    self.writeMapped(at, " = ")
                    argument()
                    self.writeMapped(at, ";")
                    self.writeLine()
                }]
                self.emitCase(arguments, matchCase, conditions, newVariables, jump, last, break, lastCase, async)
            | PVariant(at, "ff:core/Bool.False", []) =>
                self.emitCase(arguments, matchCase, addUnaryCondition(at, "!", argument), variables, jump, last, break, lastCase, async)
            | PVariant(_, "ff:core/Bool.True", []) =>
                self.emitCase(arguments, matchCase, addCondition(argument), variables, jump, last, break, lastCase, async)
            | PVariant(at, emptyOrLink, _) {emptyOrLink == "List$Empty" || emptyOrLink == "List$Link"} =>
                mutable restPattern = None
                function listPatterns(matchPattern: MatchPattern): List[MatchPattern] {
                    | PVariant(_, "List$Empty", []) => 
                        []
                    | PVariant(_, "List$Link", [head, tail]) =>
                        [head, ...listPatterns(tail)]
                    | p =>
                        restPattern = Some(p)
                        []
                }
                let patterns = listPatterns(pattern)
                let itemArguments = patterns.pairs().map {| Pair(i, _) => {
                    argument()
                    self.writeMapped(at, "[" + i + "]")
                }}
                let restArgument = restPattern.map {_ => {
                    argument()
                    self.writeMapped(at, ".slice(" + patterns.size() + ")")
                }}
                let newArguments = [...itemArguments, ...restArgument.toList(), ...arguments]
                let newMatchCase = matchCase.MatchCase(
                    patterns = [...patterns, ...restPattern.toList(), ...matchCase.patterns]
                )
                let operator = restPattern.map {_ => ">="}.else {"==="}
                let newConditions = addBinaryCondition(at, operator
                    {
                        argument()
                        self.writeMapped(at, ".length")
                    }
                    {
                        self.writeMapped(at, "" + patterns.size())
                    }
                )
                self.emitCase(newArguments, newMatchCase, newConditions, variables, jump, last, break, lastCase, async)
            | PVariant(at, name, patterns) =>
                let processed = self.processVariantCase(at, name, argument)
                let newMatchCase = matchCase.MatchCase(patterns = [...patterns, ...matchCase.patterns])
                let newConditions = if(processed.loneVariant || lastCase) {conditions} else {
                    [...conditions, {
                        argument()
                        self.writeMapped(at, ".")
                        self.writeNamed(processed.variantName, at, processed.variantName)
                    }]
                }
                let newArguments = [...processed.arguments, ...arguments]
                self.emitCase(newArguments, newMatchCase, newConditions, variables, jump, last, break, lastCase, async)
            | PVariantAs(at, name, variableAt, variable) =>
                let processed = self.processVariantCase(at, name, argument)
                let newConditions = if(processed.loneVariant || lastCase) {conditions} else {
                    [...conditions, {
                        argument()
                        self.writeMapped(at, ".")
                        self.writeNamed(processed.variantName, at, processed.variantName)
                    }]
                }
                let newVariables = variable.map {x =>
                    [...variables, {
                        self.writeMapped(at, "const ")
                        self.writeNamed(x, at, escapeKeyword(x))
                        self.writeMapped(at, " = ")
                        argument()
                        self.writeMapped(at, ";")
                        self.writeLine()
                    }]
                }.else {variables}
                self.emitCase(arguments, matchCase, newConditions, newVariables, jump, last, break, lastCase, async)
            | PAlias(at, pattern, variable) =>
                let newVariables = [...variables, {
                    self.writeMapped(at, "const ")
                    self.writeNamed(variable, at, escapeKeyword(variable))
                    self.writeMapped(at, " = ")
                    argument()
                    self.writeMapped(at, ";")
                    self.writeLine()                    
                }]
                self.emitPattern(argument, pattern, arguments, matchCase, conditions, newVariables, jump, last, break, lastCase, async)
        }
    }

    emitList(at: Location, items: List[Pair[Term, Bool]], async: Bool) {
        self.writeMapped(at, "[")
        let comma = Comma(self)
        items.each {
            | Pair(item, False) => 
                comma.writeComma()
                self.emitTerm(item, async)
            | Pair(item, True) => 
                comma.writeComma()
                self.writeMapped(item.at, "...")
                self.emitTerm(item, async)
        }
        self.writeMapped(at, "]")
    }

    processVariantCase(at: Location, name: String, argument: () => Unit): ProcessedVariantCase {
        let variantNameUnqualified = name.reverse().takeWhile {_ != '.'}.reverse()
        let variantName = escapeKeyword(variantNameUnqualified)
        let moduleName = name.dropLast(variantNameUnqualified.size() + 1)
        let variantModule = self.otherModules.grab(moduleName)
        mutable newtype = False
        mutable loneVariant = False
        let newArguments = variantModule.types.collectFirst {definition =>
            definition.variants.find {_.name == variantName }.map {variant =>
                newtype = definition.newtype
                loneVariant = definition.variants.size() == 1
                [...definition.commonFields.map {_.name}, ...variant.fields.map {_.name}]
            }
        }.grab().map {field => if(newtype) {argument} else {{
            argument()
            self.writeMapped(at, "." + escapeKeyword(field))
        }}}
        ProcessedVariantCase(variantName, newtype, loneVariant, newArguments)
    }

    processVariant(name: String): Bool {
        if(name.startsWith("List$")) {False} else:
        let variantNameUnqualified = name.reverse().takeWhile {_ != '.'}.reverse()
        let variantName = escapeKeyword(variantNameUnqualified)
        let moduleName = name.dropLast(variantNameUnqualified.size() + 1)
        let variantModule = self.otherModules.grab(moduleName)
        mutable newtype = False
        variantModule.types.collectFirst {definition =>
            definition.variants.find {_.name == variantName}.map {variant =>
                newtype = definition.newtype
            }
        }.grab()
        newtype
    }

    emitArgument(callAt: Location, argument: Argument, async: Bool) {
        argument.value.{
            | ECall(at, StaticCall("ff:core/SourceLocation.callSite", _, _), _, _, _, _) => 
                self.writeMapped(at, "\"")
                self.moduleKey.folders.each {
                    self.writeMapped(at, _ + "/")
                }
                self.writeMapped(at, self.moduleKey.name)
                self.writeMapped(at, ":" + callAt.line + ":" + callAt.column)
                self.writeMapped(at, "," + self.moduleKey.packagePair.group + "," + self.moduleKey.packagePair.name)
                self.writeMapped(at, "\"")
            | value =>
                self.emitTerm(value, async)
        }
    }
    
}

capability ProcessedVariantCase(
    variantName: String
    newtype: Bool
    loneVariant: Bool
    arguments: List[() => Unit]
)

rawJs(at: Location, rawIdentifier: String): Term {
    let noEffect = TConstructor(at, "ff:core/Nothing.Nothing", [])
    ECall(at, StaticCall("ff:core/Js.rawIdentifier", False, False), noEffect, [], [
        Argument(at, None, EString(at, rawIdentifier))
    ], [])
}

detectIfElse(term: Term): List[Pair[Term, Term]] {
    | ECall(at, StaticCall("ff:core/Core.if", _, _), _, _, [condition, body], _) =>
        [Pair(condition.value, invokeImmediately(body.value))]
    | ECall(at, StaticCall("ff:core/Option.Option_elseIf", _, _), _, _, [option, condition, body], _) =>
        let list = detectIfElse(option.value)
        if(list.isEmpty()) {[]} else:
        [Pair(invokeImmediately(condition.value), invokeImmediately(body.value)), ...list]
    | ECall(at, StaticCall("ff:core/Option.Option_else", _, _), _, _, [option, body], _) =>
        let list = detectIfElse(option.value)
        if(list.isEmpty()) {[]} else:
        [Pair(EVariant(at, "ff:core/Bool.True", [], None), invokeImmediately(body.value)), ...list]
    | _ =>
        []
}

invokeImmediately(function: Term): Term {
    | ELambda(_, Lambda(_, effect, [MatchCase(_, [], [], body)])) =>
        body
    | _ =>
        let effect = TConstructor(function.at, "Q$", []) // Awaits more often than required in async context
        ECall(function.at, DynamicCall(function, False), effect, [], [], [])
}

safeCommable(term: Term): Bool {
    term.{
        | EField _ => True
        | EVariable _ => True
        | EAssign _ => True
        | EAssignField _ => True
        | ECall _ => True
        | ECopy _ => True
        | EVariant _ => True
        | EString(_, _) => True
        | EInt(_, _) => True
        | EChar(_, _) => True
        | EFloat(_, _) => True
        | EList _ => True
        | EPipe _ => True
        | ERecord _ => True
        | EWildcard _ => True 
        | _ => False
    }
}

extractTypeName(type: Type): String {
    | TVariable(at, index) =>
        fail(at, "Unexpected type variable: $" + index)
    | TConstructor t =>
        t.name
}

firstTypeName(types: List[Type]): String {
    types.grabFirst().{
        | TConstructor t => t.name
        | TVariable t => fail(t.at, " is still a unification variable")
    }
}

makeDictionaryName(traitName: String, typeName: String): String {
    traitName.replace(".", "_").replace(":", "_").replace("/", "_") + "$" +
    typeName.replace(".", "_").replace(":", "_").replace("/", "_")
}

charLiteralToNumber(charLiteral: String): String {
    | "'\\t'" => "9"
    | "'\\n'" => "10"
    | "'\\r'" => "13"
    | "'\\\"'" => "34"
    | "'\\''" => "39"
    | value => "" + value.grab(1).codeUnit
}

escapeResolved(word: String): String {
    let parts = word.replace(":", ".").replace("/", ".").split('.')
    let initialParts = parts.dropLast()
    if(initialParts.isEmpty()) {
        escapeKeyword(parts.grabLast())
    } else {
        initialParts.join("_") + "." + escapeKeyword(parts.grabLast())
    }
}

escapeKeyword(word: String): String {
    if(word.grabFirst().isAsciiLower()) {word + "_"} else {word}
}

effectTypeIsAsync(effect: Type): Bool {
    | TConstructor(_, "Q$", _) => True
    | _ => False
}

safeBare(quotedString: String): Option[String] {
    // TODO: And not a reserved word in JS
    quotedString.removeFirst("\"").flatMap {_.removeLast("\"")}.filter {s => 
        s.first().any {_.isAsciiLetter()} && s.all {_.isAsciiLetterOrDigit()}
    }
}

noSideEffects(term: Term): Bool {
    term.{
        | EField(_, _, e, _) => noSideEffects(e)
        | EVariable(_, _) => True
        | ECall(_, StaticCall("ff:core/BrowserSystem.BrowserSystem_js", _, _), _, _, [a], _) => noSideEffects(a.value)
        | ECall(_, StaticCall("ff:core/BuildSystem.BuildSystem_js", _, _), _, _, [a], _) => noSideEffects(a.value)
        | ECall(_, StaticCall("ff:core/NodeSystem.NodeSystem_js", _, _), _, _, [a], _) => noSideEffects(a.value)
        | ECall(_, StaticCall("ff:core/Js.jsSystem", _, _), _, _, _, _) => True
        | EString(_, _) => True
        | EInt(_, _) => True
        | EChar(_, _) => True
        | EFloat(_, _) => True
        | _ => False
    }
}

primitiveTypes = [
    "ff:core/Bool.Bool"
    "ff:core/Char.Char"
    "ff:core/Int.Int"
    "ff:core/Float.Float"
    "ff:core/String.String"
].toSet()

class Liner(emitter: JsEmitter, double: Bool, mutable first: Bool = True)

extend self: Liner {
    writeLines() {
        if(self.first) {
            self.first = False
        } else {
            self.emitter.writeLine()
            if(self.double) {self.emitter.writeLine()}
        }
    }
}

class Comma(emitter: JsEmitter, mutable first: Bool = True, delimiter: String = ", ")

extend self: Comma {
    writeComma() {
        if(self.first) {
            self.first = False
        } else {
            self.emitter.writeUnmapped(self.delimiter)
        }
    }
}
