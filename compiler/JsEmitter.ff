import Syntax
import Patterns

type JsEmitter(
    otherModules: Map[String, Module]
    mutable tailCallUsed: Bool
)

make(otherModules: List[Module]): JsEmitter {
    JsEmitter(
        otherModules = otherModules.map { m =>
            let moduleName = m.packagePair.first + ":" + m.packagePair.second + "/" + m.file.dropLast(3)
            Pair(moduleName, m)
        }.toMap()
        tailCallUsed = False
    )
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

extend self: JsEmitter {

    emitModule(packagePair: Pair[String, String], module: Module): String {
        let selfImport =
            "import * as " + packagePair.first + "_" + packagePair.second + "_" + module.file.dropLast(3) + " " +
            "from \"../../" + packagePair.first + "/" + packagePair.second + "/" + module.file.dropLast(3) + ".mjs\""
        let imports =
            module.imports.sortBy { i => Pair(i.package, i.file) }.map { self.emitImportDefinition(_) }
        let parts = [
            if(imports.any { _ == selfImport }) { imports } else { [selfImport, ...imports] }
            module.types.map { self.emitTypeDefinition(_) }
            module.lets.map { "export " + self.emitLetDefinition(_) }
            module.functions.map { "export " + self.emitFunctionDefinition(_) }
            module.extends.map { self.emitExtendsDefinition(_) }
            module.instances.map { self.emitInstanceDefinition(_) }
            if(module.functions.any { _.signature.name == "main" }) {
                [self.emitMain()]
            } else { [] }
        ]
        parts.map { _.join("\n\n") }.join("\n\n") + "\n"
    }

    emitMain(): String {
        "queueMicrotask(() => main_({array_: process.argv.slice(2)}))"
    }

    emitImportDefinition(definition: DImport): String {
        "import * as " + definition.package.first + "_" + definition.package.second + "_" + definition.file + " " +
        "from \"../../" + definition.package.first + "/" + definition.package.second + "/" + definition.file + ".mjs\""
    }

    emitLetDefinition(definition: DLet, mutable: Bool = False): String {
        let mutability = if(mutable) {"let"} else {"const"}
        let valueCode = definition.targets.javaScript.else { self.emitTerm(definition.value) }
        mutability + " " + escapeKeyword(definition.name) + " = " + valueCode
    }

    emitExtendsDefinition(definition: DExtend): String {
        let typeName = extractTypeName(definition.type).reverse().takeWhile { _ != '.' }.reverse()
        let methods = definition.methods.map { method =>
            method.DFunction(
                signature = method.signature.Signature(
                    name = typeName + "_" + method.signature.name
                )
            )
        }
        methods.map { "export " + self.emitFunctionDefinition(_) }.join("\n\n")
    }

    emitInstanceDefinition(definition: DInstance): String {
        let name = makeDictionaryName(definition.traitName, firstTypeName(definition.typeArguments))
        let methods = definition.methods.map(self.emitFunctionDefinition).map { _.dropFirst("function ".size()) } // TODO
        let body = "{\n" + methods.join("\n") + "\n}"
        definition.constraints.{
            | [] =>
                "export const " + name + " = " + body + ";"
            | constraints =>
                let dictionaries = constraints.map { c =>
                    makeDictionaryName(c.name, firstTypeName(c.generics))
                }
                "export function " + name + "(" + dictionaries.join(", ") + ") { return " + body + "}"
        }
    }

    emitFunctionDefinition(definition: DFunction, suffix: String = ""): String {
        let signature = self.emitSignature(definition.signature, suffix)
        definition.targets.javaScript.map { code =>
            if(code.startsWith("#")) {
                code.dropFirst()
            } else {
                signature + " {\n" + code + "\n}"
            }
        }.else:
        definition.body.{
            | Lambda(_, [matchCase]) {
                matchCase.patterns.all {
                    | PVariable(_, None) => True
                    | PVariable(_, Some(x)) {True /* TODO */} => True
                    | _ => False
                }
            } =>
                let body = self.emitTailCall { self.emitStatements(matchCase.body, True) }
                signature + " {\n" + body + "\n}"
            | Lambda(_, cases) =>
                Patterns.convertAndCheck(self.otherModules, cases)
                let escapedArguments = definition.signature.parameters.map { _.name + "_a" }
                let shadowingWorkaround = definition.signature.parameters.map { p =>
                    "const " + p.name + "_a = " + escapeKeyword(p.name)
                }.join("\n")
                let body = self.emitTailCall {
                    let casesString = cases.map { "{\n" + self.emitCase(escapedArguments, _, True) + "\n}" }.join("\n")
                    "{\n" + shadowingWorkaround + "\n" + casesString + "\n}"
                }
                signature + " {\n" + body + "\n}"
        }
    }

    emitTailCall(body: () => String): String {
        let outerTailCallUsed = self.tailCallUsed
        self.tailCallUsed = False
        let result = body()
        let tailCallUsed = self.tailCallUsed
        self.tailCallUsed = outerTailCallUsed
        if(tailCallUsed) {
            "_tailcall: for(;;) {\n" + result + "\nreturn\n}"
        } else {
            result
        }
    }

    emitSignature(signature: Signature, suffix: String = ""): String {
        let parameterStrings = signature.parameters.map(self.emitParameter)
        let dictionaryStrings = signature.constraints.map { c =>
            makeDictionaryName(c.name, firstTypeName(c.generics))
        }
        let parameters = "(" + [...parameterStrings, ...dictionaryStrings].join(", ") + ")"
        "function " + escapeKeyword(signature.name) + suffix + parameters
    }

    emitParameter(parameter: Parameter): String {
        let defaultValue = parameter.default.map { " = " + self.emitTerm(_) }.else{""}
        escapeKeyword(parameter.name) + defaultValue
    }

    emitTypeDefinition(definition: DType): String {
        if(definition.newtype) { "// newtype " + definition.name } else:
        "// type " + definition.name + "\n" +
        definition.variants.map { self.emitVariantDefinition(definition, _) }.join("\n")
    }

    emitVariantDefinition(typeDefinition: DType, definition: Variant): String {
        let allFields = [...typeDefinition.commonFields, ...definition.fields]
        let fields = allFields.map { escapeKeyword(_.name) }.join(", ")
        definition.targets.javaScript.else {
            if(allFields.isEmpty()) {
                "const " + definition.name + "$ = {" + definition.name + ": true};\n" +
                "export function " + definition.name + "(" + fields + ") {\n" +
                "return " + definition.name + "$;\n" +
                "}"
            } elseIf { typeDefinition.variants.size() == 1 } {
                "export function " + definition.name + "(" + fields + ") {\n" +
                "return {" + fields + "};\n" +
                "}"
            } else {
                "export function " + definition.name + "(" + fields + ") {\n" +
                "return {" + definition.name + ": true, " + fields + "};\n" +
                "}"
            }
        }
    }

    emitTerm(term: Term): String {
        | EString(at, value) => value
        | EChar(at, value) => charLiteralToNumber(value)
        | EInt(at, value) => value
        | EFloat(at, value) => value
        | EVariable(at, name) => escapeResolved(name)
        | EList(at, _, items) =>
            self.emitList(items)
        | EVariant(at, name, _, _) { name == "ff:core/Bool.False" } =>
            "false"
        | EVariant(at, name, _, _) { name == "ff:core/Bool.True" } =>
            "true"
        | EVariant(at, name, _, _) { name == "ff:core/Unit.Unit" } =>
            "(void 0)"
        | EVariant(at, name, _, arguments) =>
            let argumentsString = arguments.toList().flatten().map(self.emitArgument).join(", ")
            let newtype = self.processVariant(name)
            if(newtype) { argumentsString } else:
            escapeResolved(name) + "(" + argumentsString + ")"
        | EVariantIs(at, name, _) { name == "ff:core/Bool.False" } =>
            "function(_v) { return !_v ? ff_core_Option.Some(_v) : ff_core_Option.None(); }"
        | EVariantIs(at, name, _) { name == "ff:core/Bool.True" } =>
            "function(_v) { return _v ? ff_core_Option.Some(_v) : ff_core_Option.None(); }"
        | EVariantIs(at, name, _) { name == "ff:core/Unit.Unit" } =>
            "function(_v) { return ff_core_Option.Some(_v); }"
        | EVariantIs(at, name, _) =>
            let n = name.reverse().takeWhile { _ != '.' }.reverse()
            "(function(_v) { " +
            "return _v." + escapeResolved(n) + " ? ff_core_Option.Some(_v) : ff_core_Option.None();" +
            "})"
        | ECopy(at, name, record, fields) =>
            let fieldCode = fields.map { f => escapeKeyword(f.name) + " = " + self.emitTerm(f.value) }.join(", ")
            "{..." + self.emitTerm(record) + ", " + fieldCode + "}"
        | EField(at, newtype, record, field) =>
            if(newtype) { self.emitTerm(record) } else:
            self.emitTerm(record) + "." + escapeKeyword(field)
        | ELambda(at, Lambda(_, [MatchCase(_, patterns, None, body)])) {
            patterns.all {| PVariable _ => True | _ => False }
        } =>
            let parameters =
                patterns.map {| PVariable p => p.name.map(escapeKeyword).else{"_"} | _ => panic("!") }.join(", ")
            "((" + parameters + ") => {\n" + self.emitStatements(body, True) + "\n})"
        | ELambda(at, Lambda(_, cases)) =>
            Patterns.convertAndCheck(self.otherModules, cases)
            let arguments = cases.expect(0).patterns.pairs().map { "_" + (_.first + 1) }
            let escapedArguments = arguments.map(escapeKeyword) // emitCase arguments must be preescaped
            let casesString = cases.map { "{\n" + self.emitCase(escapedArguments, _, True) + "\n}" }.join("\n")
            "((" + escapedArguments.join(", ") + ") => " +
            "{\n" + casesString + "\n})"
        | EPipe(at, value, function) =>
            "(" + self.emitTerm(function) + ")(" + self.emitTerm(value) + ")"
        | ECall(at, _, _, EVariable(_, operator), [], [value], _) {!operator.expectFirst().isAsciiLetter()} =>
            "(" + operator + self.emitArgument(value) + ")"
        | ECall(at, _, _, EVariable(_, operator), [], [left, right], _) {!operator.expectFirst().isAsciiLetter()} =>
            "(" + self.emitArgument(left) + " " + operator + " " + self.emitArgument(right) + ")"
        | ECall(at, True, _, EVariable(_, name), typeArguments, arguments, dictionaries) =>
            let dictionaryStrings = dictionaries.map(self.emitDictionary)
            let ds = if(dictionaries.size() <= 1) {""} else {
                if(arguments.isEmpty()) {""} else {", "} +
                dictionaryStrings.dropFirst().join(", ")
            }
            let d = dictionaryStrings.expectFirst()
            let n = escapeKeyword(name.reverse().takeWhile { _ != '.' }.reverse())
            d + "." + n + "(" + arguments.map(self.emitArgument).join(", ") + ds + ")"
        | ECall(at, _, _, function, typeArguments, arguments, dictionaries) =>
            detectIfElse(term).{
                | [] =>
                    let ds = if(dictionaries.isEmpty()) {""} else {
                        if(arguments.isEmpty()) {""} else {", "} +
                        dictionaries.map(self.emitDictionary).join(", ")
                    }
                    self.emitTerm(function) + "(" + arguments.map(self.emitArgument).join(", ") + ds + ")"
                | [Pair(EVariant(_, word, _, _), elseBody), ...list] { word == "ff:core/Bool.True" } =>
                    "(" + list.foldLeft(self.emitTerm(elseBody)) {| otherwise, Pair(condition, body) =>
                        self.emitTerm(condition) +
                        "\n? " + self.emitTerm(body) + "\n: " + otherwise
                    } + ")"
                | list =>
                    "(" + list.foldLeft("ff_core_Option.None()") {| otherwise, Pair(condition, body) =>
                        self.emitTerm(condition) +
                        "\n? ff_core_Option.Some(" + self.emitTerm(body) + ")\n: " + otherwise
                    } + ")"
            }
        | ERecord(at, fields) =>
            if(fields.isEmpty()) {"{}"} else {
                let list = fields.map { f => escapeKeyword(f.name) + " = " + self.emitTerm(f.value) }
                "{\n" + list.join(",\n") + "\n}"
            }
        | EWildcard(at, index) =>
            if(index == 0) {fail(at, "Unbound wildcard")}
            "_w" + index
        | _ =>
            "(function() {\n" + self.emitStatements(term, True) + "\n})()"
    }

    emitDictionary(d : Dictionary): String {
        let m = if(d.moduleName != "") {
            d.packageName.replace(":", "_") + "_" + d.moduleName.replace("/", "_") + "."
        } else { "" }
        let c = m + makeDictionaryName(d.traitName, d.typeName)
        if(d.dictionaries.isEmpty()) {
            c
        } else {
            c + "(" + d.dictionaries.map(self.emitDictionary).join(", ") + ")"
        }
    }

    emitStatements(term: Term, last: Bool): String {
        term.{
            | EFunctions(at, functions, body) =>
                let functionStrings = functions.map { f =>
                    self.emitFunctionDefinition(DFunction(at, f.signature, f.body, Targets(None)))
                }
                functionStrings.join("\n") + "\n" + self.emitStatements(body, last)
            | ELet(at, mutable, name, valueType, value, body) =>
                self.emitLetDefinition(DLet(at, name, valueType, value, Targets(None)), mutable) + "\n" + self.emitStatements(body, last)
            | EVariant(at, word, _, _) { word == "ff:core/Unit.Unit" } =>
                ""
            | ESequential(at, EVariant(at, word, _, _), after) { word == "ff:core/Unit.Unit" } =>
                self.emitStatements(after, last)
            | ESequential(at, before, EVariant(at, word, _, _)) { word == "ff:core/Unit.Unit" } =>
                self.emitStatements(before, False)
            | ESequential(at, before, after) =>
                self.emitStatements(before, False) + "\n" + self.emitStatements(after, last)
            | EAssign(at, operator, name, value) =>
                escapeKeyword(name) + " " + operator + "= " + self.emitTerm(value)
            | EAssignField(at, operator, record, field, value) =>
                self.emitTerm(record) + "." + escapeKeyword(field) + " " + operator + "= " + self.emitTerm(value)
            | ECall(at, _, _, EVariable(_, word), _, [condition, body], _) { word == "ff:core/Core.while" } =>
                "while(" + self.emitTerm(invokeImmediately(condition.value)) + ") {\n" +
                self.emitStatements(invokeImmediately(body.value), False) + "\n}"
            | ECall(at, _, _, EVariable(_, word), _, [condition, body], _) { word == "ff:core/Core.if" } =>
                "if(" + self.emitTerm(condition.value) + ") {\n" +
                if(last) {
                    "return ff_core_Option.Some(" + self.emitTerm(invokeImmediately(body.value)) +
                    ")\n} else return ff_core_Option.None()"
                } else {
                    self.emitStatements(invokeImmediately(body.value), False) + "\n}"
                }
            | ECall(at, instanceCall, True, function, _, arguments, _) =>
                if(instanceCall) { fail(at, "Not yet implemented: Tail calls on trait methods.") }
                self.tailCallUsed = True
                let pair = arguments.map { a =>
                    Some(Pair(
                        "const " + escapeKeyword(a.name.expect() + "_r") + " = " + self.emitTerm(a.value)
                        escapeKeyword(a.name.expect()) + " = " + escapeKeyword(a.name.expect() + "_r")
                    ))
                }.collect {_}.unzip()
                "{\n" + pair.first.join("\n") + "\n" + pair.second.join("\n") + "\ncontinue _tailcall\n}"
            | EPipe(at, value, ELambda(_, Lambda(_, cases))) =>
                Patterns.convertAndCheck(self.otherModules, cases)
                if(!last) { "for(;;) " }.else { "" } +
                "{\nconst _1 = " + self.emitTerm(value) + "\n" +
                cases.map { "{\n" + self.emitCase(["_1"], _, last) + "\n}" }.join("\n") +
                "\n}"
            | _ =>
                detectIfElse(term).{
                    | [] =>
                        if(last) { "return " + self.emitTerm(term) } else { self.emitTerm(term) }
                    | [Pair(EVariant(_, word, _, _), elseBody), ...list] { word == "ff:core/Bool.True" } =>
                        let initial = "{\n" + self.emitStatements(elseBody, last) + "\n}"
                        list.foldLeft(initial) {| otherwise, Pair(condition, body) =>
                            "if(" + self.emitTerm(condition) + ") {\n" +
                            self.emitStatements(body, last) + "\n} else " + otherwise
                        }
                    | list { !last } =>
                        list.foldLeft("{}") {| otherwise, Pair(condition, body) =>
                            "if(" + self.emitTerm(condition) + ") {\n" +
                            self.emitStatements(body, last) + "\n} else " + otherwise
                        }
                    | list =>
                        list.foldLeft("return ff_core_Option.None()") {| otherwise, Pair(condition, body) =>
                            "if(" + self.emitTerm(condition) + ") {\n" +
                            "return ff_core_Option.Some(" + self.emitTerm(body) + ")\n} else " + otherwise
                        }
                }
        }
    }

    emitCase(arguments: List[String], matchCase: MatchCase, last: Bool): String {
        Pair(matchCase.patterns, matchCase.guard).{
            | Pair([p, ...ps], _) =>
                self.emitPattern(
                    arguments.expect(0),
                    p,
                    arguments.dropFirst(),
                    matchCase.MatchCase(patterns = ps),
                    last
                )
            | Pair([], Some(guard)) =>
                "const _guard = " + self.emitTerm(guard.term) + "\n" +
                self.emitCase(["_guard"], matchCase.MatchCase(patterns = [guard.pattern], guard = None), last)
            | Pair([], None) =>
                self.emitStatements(matchCase.body, last) +
                if(last) { "\nreturn" } else { "\nbreak" }
        }
    }

    emitPattern(
        argument: String,
        pattern: MatchPattern,
        arguments: List[String],
        matchCase: MatchCase,
        last: Bool
    ): String {
        pattern.{
            | PString(_, value) =>
                "if(" + argument + " == " + value + ") {\n" +
                self.emitCase(arguments, matchCase, last) +
                "\n}"
            | PInt(_, value) =>
                "if(" + argument + " == " + value + ") {\n" +
                self.emitCase(arguments, matchCase, last) +
                "\n}"
            | PChar(_, value) =>
                "if(" + argument + " == " + charLiteralToNumber(value) + ") {\n" +
                self.emitCase(arguments, matchCase, last) +
                "\n}"
            | PVariable(_, None) =>
                self.emitCase(arguments, matchCase, last)
            | PVariable(_, Some(name)) =>
                let escaped = escapeKeyword(name)
                if(escaped != argument) { "const " + escaped + " = " + argument + "\n" } else { "" } +
                self.emitCase(arguments, matchCase, last)
            | PVariant(_, name, []) { name == "ff:core/Bool.False" } =>
                "if(!" + argument + ") {\n" +
                self.emitCase(arguments, matchCase, last) +
                "\n}"
            | PVariant(_, name, []) { name == "ff:core/Bool.True" } =>
                "if(" + argument + ") {\n" +
                self.emitCase(arguments, matchCase, last) +
                "\n}"
            | PVariant(_, name, patterns) =>
                let processed = self.processVariantCase(name, argument)
                let newMatchCase = matchCase.MatchCase(patterns = [...patterns, ...matchCase.patterns])
                if(processed.loneVariant) { "" } else {
                    "if(" + argument + "." + processed.variantName + ") {\n"
                } +
                self.emitCase([...processed.arguments, ...arguments], newMatchCase, last) +
                if(processed.loneVariant) { "" } else { "\n}" }
            | PVariantAs(at, name, variable) =>
                let processed = self.processVariantCase(name, argument)
                if(processed.loneVariant) { "" } else {
                    "if(" + argument + "." + processed.variantName + ") {\n"
                } +
                variable.map(escapeKeyword).filter { _ != argument }.map {
                    "const " + _ + " = " + argument + "\n"
                }.else {""} +
                self.emitCase(arguments, matchCase, last) +
                if(processed.loneVariant) { "" } else { "\n}" }
            | PAlias(_, pattern, variable) =>
                let escaped = escapeKeyword(variable)
                if(escaped != argument) { "const " + escaped + " = " + argument + "\n" } else { "" } +
                self.emitPattern(argument, pattern, arguments, matchCase, last)
        }
    }

    emitList(items: List[Pair[Term, Bool]]): String {
        | [] => "ff_core_List.Empty()"
        | [Pair(e, True)] => self.emitTerm(e)
        | [Pair(e, False), ...list] => "ff_core_List.Link(" + self.emitTerm(e) + ", " + self.emitList(list) + ")"
        | [Pair(e, True), ...list] => "ff_core_List.List_addAll(" + self.emitTerm(e) + ", " + self.emitList(list) + ")"
    }

    processVariantCase(name: String, argument: String): ProcessedVariantCase {
        let variantNameUnqualified = name.reverse().takeWhile { _ != '.' }.reverse()
        let variantName = escapeKeyword(variantNameUnqualified)
        let moduleName = name.dropLast(variantNameUnqualified.size() + 1)
        let variantModule = self.otherModules.expect(moduleName)
        mutable newtype = False
        mutable loneVariant = False
        let newArguments = variantModule.types.collectFirst { definition =>
            definition.variants.find { _.name == variantName }.map { variant =>
                newtype = definition.newtype
                loneVariant = definition.variants.size() == 1
                [...definition.commonFields.map { _.name}, ...variant.fields.map {_.name}]
            }
        }.expect().map { field => if(newtype) { argument } else { argument + "." + escapeKeyword(field) } }
        ProcessedVariantCase(variantName, newtype, loneVariant, newArguments)
    }

    processVariant(name: String): Bool {
        let variantNameUnqualified = name.reverse().takeWhile { _ != '.' }.reverse()
        let variantName = escapeKeyword(variantNameUnqualified)
        let moduleName = name.dropLast(variantNameUnqualified.size() + 1)
        let variantModule = self.otherModules.expect(moduleName)
        mutable newtype = False
        let newArguments = variantModule.types.collectFirst { definition =>
            definition.variants.find { _.name == variantName }.map { variant =>
                newtype = definition.newtype
            }
        }.expect()
        newtype
    }

    emitArgument(argument: Argument): String {
        self.emitTerm(argument.value)
    }

}

type ProcessedVariantCase(
    variantName: String
    newtype: Bool
    loneVariant: Bool
    arguments: List[String]
)

detectIfElse(term: Term): List[Pair[Term, Term]] {
    | ECall(at, _, _, EVariable(_, word), _, [condition, body], _) { word == "ff:core/Core.if" } =>
        [Pair(condition.value, invokeImmediately(body.value))]
    | ECall(at, _, _, EVariable(_, word), _, [option, condition, body], _) { word == "ff:core/Option.Option_elseIf" } =>
        let list = detectIfElse(option.value)
        if(list.isEmpty()) { [] } else:
        [Pair(invokeImmediately(condition.value), invokeImmediately(body.value)), ...list]
    | ECall(at, _, _, EVariable(_, word), _, [option, body], _) { word == "ff:core/Option.Option_else" } =>
        let list = detectIfElse(option.value)
        if(list.isEmpty()) { [] } else:
        [Pair(EVariant(at, "ff:core/Bool.True", [], None), invokeImmediately(body.value)), ...list]
    | _ =>
        []
}

invokeImmediately(function: Term): Term {
    | ELambda(_, Lambda(_, [MatchCase(_, [], None, body)])) => body
    | _ => ECall(function.at, False, False, function, [], [], [])
}

extractTypeName(type: Type): String {
    | TVariable(at, index) =>
        fail(at, "Unexpected type variable: $" + index)
    | TConstructor t =>
        t.name
}

firstTypeName(types: List[Type]): String {
    types.expectFirst().{
        | TConstructor t => t
        | TVariable t => fail(t.at, " is still a unification variable")
    }.name
}

makeDictionaryName(traitName: String, typeName: String): String {
    traitName.replace(".", "_").replace(":", "_").replace("/", "_") + "$" +
    typeName.replace(".", "_").replace(":", "_").replace("/", "_")
}

    charLiteralToNumber(charLiteral: String): String {
        | "'\\t'" => "9"
        | "'\\n'" => "10"
        | "'\\r'" => "13"
        | "'\\\"'" => "34"
        | "'\\''" => "39"
        | value => "" + value.expect(1).codeUnit
    }

escapeResolved(word: String): String {
    let parts = word.replace(":", ".").replace("/", ".").split('.').toList()
    let initialParts = parts.dropLast()
    if(initialParts.isEmpty()) {
        escapeKeyword(parts.expectLast())
    } else {
        initialParts.join("_") + "." + escapeKeyword(parts.expectLast())
    }
}

escapeKeyword(word: String): String {
    if(word.expectFirst().isAsciiLower()) {word + "_"} else {word}
}
