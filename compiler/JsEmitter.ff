import Syntax
import Patterns
import JsImporter

capability JsEmitter(
    otherModules: Map[String, Module]
    jsImporter: JsImporter
    emitTarget: EmitTarget
    isMainModule: Bool
    compilerModulePath: Option[Path]
    packagePair: PackagePair
    moduleName: String
    mutable emittingAsync: Bool
    mutable tailCallUsed: Bool
)

data EmitTarget {
    EmitNode
    EmitBrowser
    EmitBuild
    EmitExecutable
}

make(
    otherModules: List[Module]
    emitTarget: EmitTarget
    isMainModule: Bool
    compilerModulePath: Option[Path]
    packagePair: PackagePair
    moduleName: String
): JsEmitter {
    JsEmitter(
        otherModules = otherModules.map {m =>
            let moduleName = m.packagePair.groupName() + "/" + m.file.dropLast(3)
            Pair(moduleName, m)
        }.toMap()
        jsImporter = JsImporter.make()
        emitTarget = emitTarget
        isMainModule = isMainModule
        compilerModulePath = compilerModulePath
        packagePair = packagePair
        moduleName = moduleName
        emittingAsync = False
        tailCallUsed = False
    )
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

extend self: JsEmitter {

    emitModule(packagePair: PackagePair, module: Module): String {
        let selfImport =
            "import * as " + packagePair.groupName("_") + "_" + module.file.dropLast(3) + " " +
            "from \"../../" + packagePair.groupName("/") + "/" + module.file.dropLast(3) + ".mjs\""
        let imports = [
            self.compilerModulePath.map {"import * as $firefly_compiler from '" + _.url() + "'"}.toList()
            module.imports.sortBy {i => Pair(i.package, i.file) }.map {self.emitImportDefinition(_)}
        ].flatten()
        let parts = [
            if(imports.any {_ == selfImport}) {imports} else {[selfImport, ...imports]}
            module.types.map {self.emitTypeDefinition(_)}
            module.lets.map {"export " + self.emitLetDefinition(_, False, False)}
            module.functions.map {"export " + self.emitFunctionDefinition(_, False)}
            self.withEmittingAsync {module.functions.map {"export " + self.emitFunctionDefinition(_, True)}}
            module.extends.map {self.emitExtendsDefinition(_)}
            module.instances.map {self.emitInstanceDefinition(_)}
            if(self.isMainModule) {
                self.emitRun(module.functions, packagePair, packagePair.group == "ff" && packagePair.name == "compiler")
            } else {[]}
        ]
        let ignoreJsImports = if(
            self.emitTarget == EmitExecutable &&
            packagePair.group == "ff" &&
            packagePair.name == "core"
        ) {["esbuild"]} else {[]}
        let jsImports = self.jsImporter.generateImports(ignoreJsImports.toSet())
        [jsImports, ...parts].map { _.join("\n\n") }.join("\n\n") + "\n"
    }

    withEmittingAsync[T](body: () => T): T {
        try {
            self.emittingAsync = True
            body()
        } finally {
            self.emittingAsync = False
        } grab()
    }

    emitRun(functions: List[DFunction], mainPackagePair: PackagePair, bootstrapping: Bool): List[String] {
        let buildMainFunction = functions.find { _.signature.name == "buildMain" }.filter {_ =>
            self.emitTarget != EmitBrowser && self.emitTarget != EmitExecutable
        }
        let willRunOnNode = self.emitTarget != EmitBrowser
        let targetMain = if(willRunOnNode) { "nodeMain" } else { "browserMain" }
        let mainFunction =
            functions.find { _.signature.name == targetMain }.orElse { functions.find { _.signature.name == "main" } }
        mainFunction.map {_.signature.name}.map { mainName => [[
            "export async function $run$(fireflyPath_, arguments_) {"
            "Error.stackTraceLimit = 50"
            "const $task = {controller: new AbortController(), subtasks: new Set(), promise: new Promise(() => {}), started: performance.now() * 0.001}"
            ...if(self.emitTarget != EmitBrowser) {[
                "let interval = setInterval(() => {}, 24 * 60 * 60 * 1000)" // To prevent deadlocks from exiting node
            ]} else {[]}
            "let system = {"
            "task_: $task,"
            "array_: arguments_,"
            "fireflyPath_: fireflyPath_,"
            "mainPackagePair_: {group_: \"" + mainPackagePair.group + "\", name_: \"" + mainPackagePair.name + "\"},"
            "executableMode_: " + if(self.emitTarget == EmitExecutable) {"true"} else {"false"} + ","
            "buildMode_: " + if(self.emitTarget == EmitBuild) {"true"} else {"false"}
            "}"
            "try {"
            ...if(!buildMainFunction.isEmpty()) {[
                "await buildMain_$(system, $task)"]
            } else {[]}
            ...if(self.emitTarget != EmitBuild) {[
                "await " + mainName + "_$(system, $task)"
            ]} else {[]}
            ...if(self.emitTarget == EmitBuild) {[
                "await $firefly_compiler.internalCreateExecutable_$(system, '.firefly/output/executable/Main.bundle.js', '.firefly/output', ['host'], system.assets_, $task)"
            ]} else {[]}
            "} finally {"
            ...if(self.emitTarget != EmitBrowser) {[
                "ff_core_Task.Task_abort$($task)"
                "clearInterval(interval)"
            ]} else {[]}
            "}"
            "}"
            ...self.emitTarget.{
                | EmitBrowser => [
                    "queueMicrotask(async () => {"
                    "await $run$(null, [])"
                    "})"
                ]
                | EmitNode {bootstrapping} => [
                    "import * as path from 'node:path'"
                    "queueMicrotask(async () => {"
                    "let fireflyPath_ = path.dirname(path.dirname(path.dirname(path.dirname(path.dirname(process.argv[1])))))"
                    "await $run$(fireflyPath_, process.argv.slice(2))"
                    "})"
                ]
                | EmitExecutable => [
                    "queueMicrotask(async () => {"
                    "await $run$(null, process.argv.slice(2))"
                    "})"
                ]
                | _ => []
            }
        ].join("\n")]}.else {[]}
    }

    emitImportDefinition(definition: DImport): String {
        "import * as " + definition.package.group + "_" + definition.package.name + "_" + definition.file + " " +
        "from \"../../" + definition.package.group + "/" + definition.package.name + "/" + definition.file + ".mjs\""
    }

    emitLetDefinition(definition: DLet, mutable: Bool, async: Bool): String {
        let mutability = if(mutable) {"let"} else {"const"}
        let valueCode = self.emitTerm(definition.value, async)
        mutability + " " + escapeKeyword(definition.name) + " = " + valueCode + ";"
    }

    emitExtendsDefinition(definition: DExtend): String {
        let typeName = extractTypeName(definition.type).reverse().takeWhile { _ != '.' }.reverse()
        let methods = definition.methods.map { method =>
            method.DFunction(
                signature = method.signature.Signature(
                    name = typeName + "_" + method.signature.name
                )
            )
        }
        let syncMethods = methods.map { "export " + self.emitFunctionDefinition(_, False) }
        let asyncMethods = self.withEmittingAsync {methods.map { "export " + self.emitFunctionDefinition(_, True) }}
        [...syncMethods, ...asyncMethods].join("\n\n")
    }

    emitInstanceDefinition(definition: DInstance): String {
        let name = makeDictionaryName(definition.traitName, firstTypeName(definition.typeArguments))
        let methods = definition.methods.map {self.emitFunctionDefinition(_, False)}.map { _.dropFirst("function ".size()) } // TODO
        let asyncMethods = self.withEmittingAsync {
            definition.methods.map {self.emitFunctionDefinition(_, True)}.map { "async " + _.dropFirst("async function ".size()) } // TODO
        }
        let body = "{\n" + [...methods, ...asyncMethods].join(",\n") + "\n}"
        definition.constraints.{
            | [] =>
                "export const " + name + " = " + body + ";"
            | constraints =>
                let dictionaries = constraints.map { c =>
                    makeDictionaryName(c.name, firstTypeName(c.generics))
                }
                "export function " + name + "(" + dictionaries.join(", ") + ") { return " + body + "}"
        }
    }

    emitFunctionDefinition(definition: DFunction, async: Bool, suffix: String = ""): String {
        let signature = self.emitSignature(definition.signature, async, suffix)
        Pair(async, definition.body).{
            | Pair(False, ForeignTarget(None, _)) =>
                signature + " {\nthrow new Error('Function " + definition.signature.name + " is missing on this target in sync context.');\n}"
            | Pair(True, ForeignTarget(_, None)) =>
                signature + " {\nthrow new Error('Function " + definition.signature.name + " is missing on this target in async context.');\n}"
            | Pair(False, ForeignTarget(Some(code), _)) =>
                signature + " {\n" + self.jsImporter.process(definition.at, code) + "\n}"
            | Pair(True, ForeignTarget(_, Some(code))) =>
                signature + " {\n" + self.jsImporter.process(definition.at, code) + "\n}"
            | Pair(_, FireflyTarget(lambda)) => lambda.{
                | Lambda(_, effect, [matchCase]) {
                    matchCase.patterns.all {
                        | PVariable(_, None) => True
                        | _ => False
                    }
                } =>
                    let body = self.emitTailCall { self.emitStatements(matchCase.body, True, async) }
                    signature + " {\n" + body + "\n}"
                | Lambda(_, effect, cases) =>
                    Patterns.convertAndCheck(self.otherModules, cases)
                    let escapedArguments = definition.signature.parameters.map { _.name + "_a" }
                    let shadowingWorkaround = definition.signature.parameters.map { p =>
                        "const " + p.name + "_a = " + escapeKeyword(p.name) + ";"
                    }.join("\n")
                    let body = self.emitTailCall {
                        let casesString = cases.map {
                            "{\n" + self.emitCase(escapedArguments, _, True, True, async) + "\n}"
                        }.join("\n")
                        "{\n" + shadowingWorkaround + "\n" + casesString + "\n}"
                    }
                    signature + " {\n" + body + "\n}"
            }
        }
    }

    emitTailCall(body: () => String): String {
        let outerTailCallUsed = self.tailCallUsed
        self.tailCallUsed = False
        let result = body()
        let tailCallUsed = self.tailCallUsed
        self.tailCallUsed = outerTailCallUsed
        if(tailCallUsed) {
            "_tailcall: for(;;) {\n" + result + "\nreturn\n}"
        } else {
            result
        }
    }

    emitSignature(signature: Signature, async: Bool, suffix: String = ""): String {
        let parameterStrings = signature.parameters.map {self.emitParameter(_, async)}
        let dictionaryStrings = signature.constraints.map { c =>
            makeDictionaryName(c.name, firstTypeName(c.generics))
        }
        let controller = if(async) {["$task"]} else {[]}
        let parameters = "(" + [...parameterStrings, ...dictionaryStrings, ...controller].join(", ") + ")"
        let prefix = if(async) {"async "} else {""}
        let asyncSuffix = if(async) {"$"} else {""}
        prefix + "function " + escapeKeyword(signature.name) + suffix + asyncSuffix + parameters
    }

    emitParameter(parameter: Parameter, async: Bool): String {
        let defaultValue = parameter.default.map { " = " + self.emitTerm(_, async) }.else{""}
        escapeKeyword(parameter.name) + defaultValue
    }

    emitTypeDefinition(definition: DType): String {
        if(definition.newtype) { "// newtype " + definition.name } else:
        "// type " + definition.name + "\n" +
        definition.variants.map { self.emitVariantDefinition(definition, _) }.join("\n")
    }

    emitVariantDefinition(typeDefinition: DType, definition: Variant): String {
        let allFields = [...typeDefinition.commonFields, ...definition.fields]
        let fields = allFields.map { escapeKeyword(_.name) }.join(", ")
        if(allFields.isEmpty()) {
            "const " + definition.name + "$ = {" + definition.name + ": true};\n" +
            "export function " + definition.name + "(" + fields + ") {\n" +
            "return " + definition.name + "$;\n" +
            "}"
        } elseIf { typeDefinition.variants.size() == 1 } {
            "export function " + definition.name + "(" + fields + ") {\n" +
            "return {" + fields + "};\n" +
            "}"
        } else {
            "export function " + definition.name + "(" + fields + ") {\n" +
            "return {" + definition.name + ": true, " + fields + "};\n" +
            "}"
        }
    }

    emitTerm(term: Term, async: Bool): String { term.{
        | EString(at, value) {value.startsWith("\"\"\"")} =>
            "`" + value.dropFirst(3).dropLast(3).replace("`", "\\`") + "`" // TODO: Fix escaping
        | EString(at, value) => value
        | EChar(at, value) => charLiteralToNumber(value)
        | EInt(at, value) => value
        | EFloat(at, value) => value
        | EVariable(at, name) => escapeResolved(name)
        | EList(at, _, items) =>
            self.emitList(items, async)
        | EVariant(at, "ff:core/Bool.False", _, _) =>
            "false"
        | EVariant(at, "ff:core/Bool.True", _, _) =>
            "true"
        | EVariant(at, "ff:core/Unit.Unit", _, _) =>
            "(void 0)"
        | EVariant(at, name, _, arguments) =>
            let argumentsString = arguments.toList().flatten().map {self.emitArgument(at, _, async)}.join(", ")
            let newtype = self.processVariant(name)
            if(newtype) { argumentsString } else:
            escapeResolved(name) + "(" + argumentsString + ")"
        | EVariantIs(at, "ff:core/Bool.False", _) =>
            "function(_v) { return !_v ? ff_core_Option.Some(_v) : ff_core_Option.None(); }"
        | EVariantIs(at, "ff:core/Bool.True", _) =>
            "function(_v) { return _v ? ff_core_Option.Some(_v) : ff_core_Option.None(); }"
        | EVariantIs(at, "ff:core/Unit.Unit", _) =>
            "function(_v) { return ff_core_Option.Some(_v); }"
        | EVariantIs(at, name, _) =>
            let n = name.reverse().takeWhile { _ != '.' }.reverse()
            "(function(_v) { " +
            "return _v." + escapeResolved(n) + " ? ff_core_Option.Some(_v) : ff_core_Option.None();" +
            "})"
        | ECopy(at, name, record, fields) =>
            let fieldCode = fields.map { f => escapeKeyword(f.name) + " = " + self.emitTerm(f.value, async) }.join(", ")
            "{..." + self.emitTerm(record, async) + ", " + fieldCode + "}"
        | EField(at, newtype, record, field) =>
            if(newtype) { self.emitTerm(record, async) } else:
            self.emitTerm(record, async) + "." + escapeKeyword(field)
        | ELambda(at, Lambda(_, effect, [MatchCase(_, patterns, [], body)])) {
            patterns.all {| PVariable _ => True | _ => False }
        } =>
            let newAsync = self.emittingAsync && effectTypeIsAsync(effect)
            let patternParameters = patterns.map {
                | PVariable p => p.name.map(escapeKeyword).else{"_"}
                | _ => panic("!")
            }
            let controller = if(newAsync) {["$task"]} else {[]}
            let parameters = [...patternParameters, ...controller].join(", ")
            let prefix = if(newAsync) {"async "} else {""}
            "(" + prefix + "(" + parameters + ") => {\n" + self.emitStatements(body, True, newAsync) + "\n})"
        | ELambda(at, Lambda(_, effect, cases)) =>
            let newAsync = self.emittingAsync && effectTypeIsAsync(effect)
            let controller = if(newAsync) {["$task"]} else {[]}
            Patterns.convertAndCheck(self.otherModules, cases)
            let arguments = cases.grab(0).patterns.pairs().map { "_" + (_.first + 1) }
            let escapedArguments = arguments.map(escapeKeyword) // emitCase arguments must be preescaped
            let caseStrings = cases.map { "{\n" + self.emitCase(escapedArguments, _, True, True, newAsync) + "\n}" }
            let prefix = if(newAsync) {"async "} else {""}
            "(" + prefix + "(" + [...escapedArguments, ...controller].join(", ") + ") => " +
            "{\n" + caseStrings.join("\n") + "\n})"
        | EPipe(at, value, effect, function) =>
            let await = async && effectTypeIsAsync(effect)
            let c = if(await) {", $task"} else {""}
            let call = "(" + self.emitTerm(function, async) + ")(" + self.emitTerm(value, async) + c + ")"
            if(await) {"(await " + call + ")"} else {call}
        | ECall(at, StaticCall(operator, _, _), _, [], [value], _) {!operator.grabFirst().isAsciiLetter()} =>
            "(" + operator + self.emitArgument(at, value, async) + ")"
        | ECall(at, StaticCall(operator, _, _), _, [], [left, right], _) {!operator.grabFirst().isAsciiLetter()} =>
            "(" + self.emitArgument(at, left, async) + " " + operator + " " + self.emitArgument(at, right, async) + ")"
        | ECall(at, StaticCall("ff:unsafejs/UnsafeJs.import", _, _), _, _, [Argument(_, _, EString(_, url))], _) =>
            self.jsImporter.add(url.replace("\"", ""))
        | ECall(at, StaticCall("ff:unsafejs/UnsafeJs.await", _, _), _, _, [Argument(_, _, body)], _) =>
            let emittedBody = self.emitTerm(body, async)
            if(async) {"(await " + emittedBody + "($task))"} else {"(" + emittedBody + "())"}
        | ECall(at, StaticCall("ff:unsafejs/UnsafeJs.cancelled", _, _), _, _, [], _) =>
            if(async) {"$task.controller.signal.aborted"} else {"false"}
        | ECall(at, StaticCall("ff:unsafejs/UnsafeJs.throwIfCancelled", _, _), _, _, [], _) =>
            if(async) {"((() => ff_core_Task.Task_throwIfAborted($task))())"} else {""}
        | ECall(at, StaticCall("ff:core/Equal.equals", _, _), _, _, [left, right], [Dictionary(_, _, _, typeName, [])]) {
            primitiveTypes.contains(typeName) || typeName == "ff:core/Ordering.Ordering"
        } =>
            "(" + self.emitArgument(at, left, async) + " === " + self.emitArgument(at, right, async) + ")"
        | ECall(at, StaticCall("ff:core/Equal.notEquals", _, _), _, _, [left, right], [Dictionary(_, _, _, typeName, [])]) {
            primitiveTypes.contains(typeName) || typeName == "ff:core/Ordering.Ordering"
        } =>
            "(" + self.emitArgument(at, left, async) + " !== " + self.emitArgument(at, right, async) + ")"
        | ECall(at, StaticCall("ff:core/Ordering.before", _, _), _, _, [left, right], [Dictionary(_, _, _, typeName, [])]) {
            primitiveTypes.contains(typeName)
        } =>
            "(" + self.emitArgument(at, left, async) + " < " + self.emitArgument(at, right, async) + ")"
        | ECall(at, StaticCall("ff:core/Ordering.notBefore", _, _), _, _, [left, right], [Dictionary(_, _, _, typeName, [])]) {
            primitiveTypes.contains(typeName)
        } =>
            "(" + self.emitArgument(at, left, async) + " >= " + self.emitArgument(at, right, async) + ")"
        | ECall(at, StaticCall("ff:core/Ordering.after", _, _), _, _, [left, right], [Dictionary(_, _, _, typeName, [])]) {
            primitiveTypes.contains(typeName)
        } =>
            "(" + self.emitArgument(at, left, async) + " > " + self.emitArgument(at, right, async) + ")"
        | ECall(at, StaticCall("ff:core/Ordering.notAfter", _, _), _, _, [left, right], [Dictionary(_, _, _, typeName, [])]) {
            primitiveTypes.contains(typeName)
        } =>
            "(" + self.emitArgument(at, left, async) + " <= " + self.emitArgument(at, right, async) + ")"
        | ECall(_, StaticCall("ff:core/Array.fillBy", _, _), effect, _, [size, Argument(_, _, ELambda(at,
            Lambda(_, _, [MatchCase(_, [PVariable(_, name)], [], body)@c])@l
        ))], _) {
            !effectTypeIsAsync(effect)
        } =>
            let n = name.map {escapeResolved(_)}.else {"i"}
            let newAsync = self.emittingAsync && effectTypeIsAsync(effect)
            let await = if(newAsync) {"await "} else {""}
            await + "((() => {\n" +
            "const size = " + self.emitArgument(at, size, async) + ";\n" + // Not correct if async and body isn't
            "const result = [];\n" +
            "for(let " + n + " = 0; " + n + " < size; " + n + "++) {\n" +
            "result.push(" + self.emitTerm(body, newAsync) + ");\n" +
            "}\n" +
            "return result;\n" +
            "})())"
        | ECall(at, StaticCall(name, _, True), effect, typeArguments, arguments, dictionaries) =>
            let await = async && effectTypeIsAsync(effect)
            let dictionaryStrings = dictionaries.map {self.emitDictionary(_)}
            let ds = dictionaryStrings.dropFirst()
            let d = dictionaryStrings.grabFirst()
            let asyncSuffix = if(await) {"$"} else {""}
            let n = escapeKeyword(name.reverse().takeWhile { _ != '.' }.reverse()) + asyncSuffix
            let emittedArguments = arguments.map {self.emitArgument(at, _, async)}
            let controller = if(await) {["$task"]} else {[]}
            let call = d + "." + n + "(" + [...emittedArguments, ...ds, ...controller].join(", ") + ")"
            if(await) {"(await " + call + ")"} else {call}
        | ECall(at, StaticCall(name, _, _), effect, typeArguments, arguments, dictionaries) =>
            detectIfElse(term).{
                | [] =>
                    let await = async && effectTypeIsAsync(effect)
                    let ds = dictionaries.map {self.emitDictionary(_)}
                    let functionCode = escapeResolved(name) + if(await) {"$"} else {""}
                    let emittedArguments = arguments.map {self.emitArgument(at, _, async)}
                    let controller = if(await) {["$task"]} else {[]}
                    let call = functionCode + "(" + [...emittedArguments, ...ds, ...controller].join(", ") + ")"
                    if(await) {"(await " + call + ")"} else {call}
                | [Pair(EVariant(_, "ff:core/Bool.True", _, _), elseBody), ...list] =>
                    "(" + list.foldLeft(self.emitTerm(elseBody, async)) {| otherwise, Pair(condition, body) =>
                        self.emitTerm(condition, async) +
                        "\n? " + self.emitTerm(body, async) + "\n: " + otherwise
                    } + ")"
                | list =>
                    "(" + list.foldLeft("ff_core_Option.None()") {| otherwise, Pair(condition, body) =>
                        self.emitTerm(condition, async) +
                        "\n? ff_core_Option.Some(" + self.emitTerm(body, async) + ")\n: " + otherwise
                    } + ")"
            }
        | ECall(at, DynamicCall(function, _), effect, typeArguments, arguments, dictionaries) =>
            let await = async && effectTypeIsAsync(effect)
            if(!dictionaries.isEmpty()) {fail(at, "Internal error: Dictionaries in lambda call")}
            let functionCode = self.emitTerm(function, async)
            let emittedArguments = arguments.map {self.emitArgument(at, _, async)}
            let controller = if(await) {["$task"]} else {[]}
            let call = functionCode + "(" + [...emittedArguments, ...controller].join(", ") + ")"
            if(await) {"(await " + call + ")"} else {call}
        | ERecord(at, fields) =>
            if(fields.isEmpty()) {"{}"} else {
                let list = fields.map { f => escapeKeyword(f.name) + ": " + self.emitTerm(f.value, async) }
                "{\n" + list.join(",\n") + "\n}"
            }
        | EWildcard(at, index) =>
            if(index == 0) {fail(at, "Unbound wildcard")}
            "_w" + index
        | _ {async} =>
            "(await (async function() {\n" + self.emitStatements(term, True, async) + "\n})())"
        | _ =>
            "(function() {\n" + self.emitStatements(term, True, async) + "\n})()"
    }}

    emitDictionary(d : Dictionary): String {
        let m = if(d.moduleName != "") {
            d.packagePair.groupName("_") + "_" + d.moduleName.replace("/", "_") + "."
        } else { "" }
        let c = m + makeDictionaryName(d.traitName, d.typeName)
        if(d.dictionaries.isEmpty()) {
            c
        } else {
            c + "(" + d.dictionaries.map {self.emitDictionary(_)}.join(", ") + ")"
        }
    }

    emitStatements(term: Term, last: Bool, async: Bool): String {
        term.{
            | EFunctions(at, functions, body) =>
                let functionStrings = functions.map { f =>
                    let newAsync = self.emittingAsync && effectTypeIsAsync(f.signature.effect)
                    self.emitFunctionDefinition(f, newAsync)
                }
                functionStrings.join("\n") + "\n" + self.emitStatements(body, last, async)
            | ELet(at, mutable, name, valueType, value, body) =>
                self.emitLetDefinition(DLet(at, name, valueType, value), mutable, async) + "\n" +
                self.emitStatements(body, last, async)
            | EVariant(at, "ff:core/Unit.Unit", _, _) =>
                ""
            | ESequential(at, EVariant(at, "ff:core/Unit.Unit", _, _), after) =>
                self.emitStatements(after, last, async)
            | ESequential(at, before, EVariant(at, "ff:core/Unit.Unit", _, _)) =>
                self.emitStatements(before, False, async)
            | ESequential(at, before, after) =>
                self.emitStatements(before, False, async) + ";\n" + self.emitStatements(after, last, async)
            | EAssign(at, operator, name, value) =>
                escapeKeyword(name) + " " + operator + "= " + self.emitTerm(value, async)
            | EAssignField(at, operator, record, field, value) =>
                self.emitTerm(record, async) + "." + escapeKeyword(field) + " " + operator + "= " +
                self.emitTerm(value, async)
            | ECall(at, StaticCall("ff:core/Core.while", _, _), _, _, [condition, body], _) =>
                "while(" + self.emitTerm(invokeImmediately(condition.value), async) + ") {\n" +
                self.emitStatements(invokeImmediately(body.value), False, async) + "\n}"
            | ECall(at, StaticCall("ff:core/Core.doWhile", _, _), _, _, [Argument(_, _, doWhileBody)], _) {
                invokeImmediately(doWhileBody) | ESequential(_, body, condition)
            } =>
                "while(true) {\n" +
                self.emitStatements(body, False, async) +
                "\nif(!" + self.emitTerm(condition, async) + ") break" +
                "\n}"
            | ECall(at, StaticCall("ff:core/Core.doWhile", _, _), _, _, [Argument(_, _, doWhileBody)], _) {
                invokeImmediately(doWhileBody) | body
            } =>
                "while(" + self.emitTerm(body, async) + ") {}"
            | ECall(at, StaticCall("ff:core/Core.if", _, _), _, _, [condition, body], _) =>
                "if(" + self.emitTerm(condition.value, async) + ") {\n" +
                if(last) {
                    "return ff_core_Option.Some(" + self.emitTerm(invokeImmediately(body.value), async) +
                    ")\n} else return ff_core_Option.None()"
                } else {
                    self.emitStatements(invokeImmediately(body.value), False, async) + "\n}"
                }
            | ECall(at, StaticCall("ff:core/Core.throw", _, _), _, _, [argument], [dictionary]) =>
                let d = self.emitDictionary(dictionary)
                let a = self.emitArgument(at, argument, async)
                "throw Object.assign(new Error(), {ffException: ff_core_Any.toAny_(" + a + ", " + d + ")})"
            | ECall(at, StaticCall("ff:core/Core.try", _, _), _, _, _, _) {!last} =>
                throw(CompileError(at, "Statements can't be a try without a grab"))
            | ECall(at, StaticCall("ff:core/Try.Try_map", _, _), _, _, _, _) {!last} =>
                throw(CompileError(at, "Statements can't be a map without a grab"))
            | ECall(at, StaticCall("ff:core/Try.Try_flatMap", _, _), _, _, _, _) {!last} =>
                throw(CompileError(at, "Statements can't be a flatMap without a grab"))
            | ECall(at, StaticCall("ff:core/Try.Try_flatten", _, _), _, _, _, _) {!last} =>
                throw(CompileError(at, "Statements can't be a flatten without a grab"))
            | ECall(at, StaticCall("ff:core/Try.Try_catch", _, _), _, _, _, _) {!last} =>
                throw(CompileError(at, "Statements can't be a catch without a grab"))
            | ECall(at, StaticCall("ff:core/Try.Try_catchAny", _, _), _, _, _, _) {!last} =>
                throw(CompileError(at, "Statements can't be a catchAny without a grab"))
            | ECall(at, StaticCall("ff:core/Try.Try_finally", _, _), _, _, _, _) {!last} =>
                throw(CompileError(at, "Statements can't be a finally without a grab"))
            | ECall(at, StaticCall("ff:core/Try.Try_grab", _, _), _, _, [argument], _) {
                self.emitTryCatchFinally(argument.value, last, async) | Some(code)
            } =>
                code
            | ECall(at, StaticCall("ff:unsafejs/UnsafeJs.throwIfCancelled", _, _), _, _, [], _) =>
                if(async) {"ff_core_Task.Task_throwIfAborted($task)"} else {""}
            | ECall(at, StaticCall(name, True, instanceCall), effect, _, arguments, _) =>
                if(instanceCall) {throw(CompileError(at, "Not yet implemented: Tail calls on trait methods."))}
                self.tailCallUsed = True
                let pair = arguments.map {a =>
                    Some(Pair(
                        "const " + escapeKeyword(a.name.grab() + "_r") + " = " + self.emitTerm(a.value, async) + ";"
                        escapeKeyword(a.name.grab()) + " = " + escapeKeyword(a.name.grab() + "_r")
                    ))
                }.collect {_}.unzip()
                "{\n" + pair.first.join("\n") + "\n" + pair.second.join("\n") + "\ncontinue _tailcall\n}"
            | EPipe(at, value, _, ELambda(_, Lambda(_, _, cases))) =>
                Patterns.convertAndCheck(self.otherModules, cases)
                if(!last) {"do "}.else {""} +
                "{\nconst _1 = " + self.emitTerm(value, async) + ";\n" +
                cases.map {"{\n" + self.emitCase(["_1"], _, True, last, async) + "\n}"}.join("\n") +
                "\n}" + if(!last) {" while(false)"}.else {""}
            | _ =>
                detectIfElse(term).{
                    | [] =>
                        if(last) {"return " + self.emitTerm(term, async)} else {self.emitTerm(term, async)}
                    | [Pair(EVariant(_, "ff:core/Bool.True", _, _), elseBody), ...list] =>
                        let initial = "{\n" + self.emitStatements(elseBody, last, async) + "\n}"
                        list.foldLeft(initial) {| otherwise, Pair(condition, body) =>
                            "if(" + self.emitTerm(condition, async) + ") {\n" +
                            self.emitStatements(body, last, async) + "\n} else " + otherwise
                        }
                    | list {!last} =>
                        list.foldLeft("{}") {| otherwise, Pair(condition, body) =>
                            "if(" + self.emitTerm(condition, async) + ") {\n" +
                            self.emitStatements(body, last, async) + "\n} else " + otherwise
                        }
                    | list =>
                        list.foldLeft("return ff_core_Option.None()") {| otherwise, Pair(condition, body) =>
                            "if(" + self.emitTerm(condition, async) + ") {\n" +
                            "return ff_core_Option.Some(" + self.emitTerm(body, async) + ")\n} else " + otherwise
                        }
                }
        }
    }

    emitTryCatchFinally(term: Term, last: Bool, async: Bool): Option[String] {
        function emitCatch(catchEffect: Type, cases: List[MatchCase]): String {
            let catchAsync = self.emittingAsync && effectTypeIsAsync(catchEffect)
            Patterns.convertAndCheck(self.otherModules, cases)
            let arguments = ["_exception.value_", "_error"]
            cases.{
                | [case] =>
                    self.emitCase(arguments, case, False, last, catchAsync)
                | cs =>
                    let caseStrings =
                        cases.map {"{\n" + self.emitCase(arguments, _, True, last, catchAsync) + "\n}"}
                    if(last) {caseStrings.join("\n")} else {"do {\n" + caseStrings.join("\n") + "\n} while(false)"}
            }
        }
        term.{
            | ECall(at, StaticCall("ff:core/Try.Try_finally", _, _), _, _, [
                Argument(_, _, ECall(at, StaticCall("ff:core/Core.try", _, _), _, _, [
                    Argument(_, _, ELambda(_, Lambda(_, tryEffect, [MatchCase(_, [], [], tryBody)])))
                ], _))
                Argument(_, _, ELambda(_, Lambda(_, finallyEffect, [MatchCase(_, [], [], finallyBody)])))
            ], _) =>
                let tryAsync = self.emittingAsync && effectTypeIsAsync(tryEffect)
                let finallyAsync = self.emittingAsync && effectTypeIsAsync(finallyEffect)
                Some(
                    "try {\n" + self.emitStatements(tryBody, last, tryAsync) +
                    "\n} finally {\n" + self.emitStatements(finallyBody, last, finallyAsync) + "\n}"
                )
            | ECall(at, StaticCall("ff:core/Try.Try_catch", _, _), _, _, [
                Argument(_, _, ECall(at, StaticCall("ff:core/Core.try", _, _), _, _, [
                    Argument(_, _, ELambda(_, Lambda(_, tryEffect, [MatchCase(_, [], [], tryBody)])))
                ], _))
                Argument(_, _, ELambda(_, Lambda(_, catchEffect, cases)))
            ], [dictionary]) =>
                let tryAsync = self.emittingAsync && effectTypeIsAsync(tryEffect)
                let d = self.emitDictionary(dictionary)
                Some(
                    "try {\n" + self.emitStatements(tryBody, last, tryAsync) +
                    "\n} catch(_error) {\n" +
                        "if(!_error.ffException) throw _error\n" +
                        "const _exception = ff_core_Any.fromAny_(_error.ffException, " + d + ")\n" +
                        "if(!_exception.Some) throw _error\n" +
                        emitCatch(catchEffect, cases) +
                    "\n}"
                )
            | ECall(at, StaticCall("ff:core/Try.Try_finally", _, _), _, _, [
                Argument(_, _, ECall(at, StaticCall("ff:core/Try.Try_catch", _, _), _, _, [
                    Argument(_, _, ECall(at, StaticCall("ff:core/Core.try", _, _), _, _, [
                        Argument(_, _, ELambda(_, Lambda(_, tryEffect, [MatchCase(_, [], [], tryBody)])))
                    ], _))
                    Argument(_, _, ELambda(_, Lambda(_, catchEffect, cases)))
                ], [dictionary]))
                Argument(_, _, ELambda(_, Lambda(_, finallyEffect, [MatchCase(_, [], [], finallyBody)])))
            ], _) =>
                let tryAsync = self.emittingAsync && effectTypeIsAsync(tryEffect)
                let finallyAsync = self.emittingAsync && effectTypeIsAsync(finallyEffect)
                let d = self.emitDictionary(dictionary)
                Some(
                    "try {\n" + self.emitStatements(tryBody, last, tryAsync) +
                    "\n} catch(_error) {\n" +
                        "if(!_error.ffException) throw _error\n" +
                        "const _exception = ff_core_Any.fromAny_(_error.ffException, " + d + ")\n" +
                        "if(!_exception.Some) throw _error\n" +
                        emitCatch(catchEffect, cases) +
                    "\n} finally {\n" + self.emitStatements(finallyBody, last, finallyAsync) + "\n}"
                )
            | _ =>
                None
        }
    }

    emitCase(arguments: List[String], matchCase: MatchCase, jump: Bool, last: Bool, async: Bool): String {
        Pair(matchCase.patterns, matchCase.guards).{
            | Pair([p, ...ps], _) =>
                self.emitPattern(
                    arguments.grab(0)
                    p
                    arguments.dropFirst()
                    matchCase.MatchCase(patterns = ps)
                    jump
                    last
                    async
                )
            | Pair([], [guard, ...guards]) =>
                let guardName = "_guard" + (guards.size() + 1)
                let newCase = matchCase.MatchCase(patterns = [guard.pattern], guards = guards)
                "const " + guardName + " = " + self.emitTerm(guard.term, async) + ";\n" +
                self.emitCase([guardName], newCase, jump, last, async)
            | Pair([], []) =>
                self.emitStatements(matchCase.body, last, async) +
                if(jump && last) { "\nreturn" } elseIf {jump} { "\nbreak" } else {""}
        }
    }

    emitPattern(
        argument: String
        pattern: MatchPattern
        arguments: List[String]
        matchCase: MatchCase
        jump: Bool
        last: Bool
        async: Bool
    ): String {
        pattern.{
            | PString(_, value) =>
                "if(" + argument + " == " + value + ") {\n" +
                self.emitCase(arguments, matchCase, jump, last, async) +
                "\n}"
            | PInt(_, value) =>
                "if(" + argument + " == " + value + ") {\n" +
                self.emitCase(arguments, matchCase, jump, last, async) +
                "\n}"
            | PChar(_, value) =>
                "if(" + argument + " == " + charLiteralToNumber(value) + ") {\n" +
                self.emitCase(arguments, matchCase, jump, last, async) +
                "\n}"
            | PVariable(_, None) =>
                self.emitCase(arguments, matchCase, jump, last, async)
            | PVariable(_, Some(name)) =>
                let escaped = escapeKeyword(name)
                if(escaped != argument) {"const " + escaped + " = " + argument + ";\n"} else {""} +
                self.emitCase(arguments, matchCase, jump, last, async)
            | PVariant(_, "ff:core/Bool.False", []) =>
                "if(!" + argument + ") {\n" +
                self.emitCase(arguments, matchCase, jump, last, async) +
                "\n}"
            | PVariant(_, "ff:core/Bool.True", []) =>
                "if(" + argument + ") {\n" +
                self.emitCase(arguments, matchCase, jump, last, async) +
                "\n}"
            | PVariant(_, "List$Empty", []) =>
                "if(" + argument + ".length === 0) {\n" +
                self.emitCase(arguments, matchCase, jump, last, async) +
                "\n}"
            | PVariant(_, "List$Link", [head, tail]) =>
                let newArguments = [argument + "[0]", argument + ".slice(1)", ...arguments]
                let newMatchCase = matchCase.MatchCase(patterns = [head, tail, ...matchCase.patterns])
                "if(" + argument + ".length !== 0) {\n" +
                self.emitCase(newArguments, newMatchCase, jump, last, async) +
                "\n}"
            | PVariant(_, name, patterns) =>
                let processed = self.processVariantCase(name, argument)
                let newMatchCase = matchCase.MatchCase(patterns = [...patterns, ...matchCase.patterns])
                if(processed.loneVariant) {""} else {
                    "if(" + argument + "." + processed.variantName + ") {\n"
                } +
                self.emitCase([...processed.arguments, ...arguments], newMatchCase, jump, last, async) +
                if(processed.loneVariant) {""} else {"\n}"}
            | PVariantAs(at, name, variableAt, variable) =>
                let processed = self.processVariantCase(name, argument)
                if(processed.loneVariant) {""} else {
                    "if(" + argument + "." + processed.variantName + ") {\n"
                } +
                variable.map(escapeKeyword).filter {_ != argument}.map {
                    "const " + _ + " = " + argument + ";\n"
                }.else {""} +
                self.emitCase(arguments, matchCase, jump, last, async) +
                if(processed.loneVariant) {""} else {"\n}"}
            | PAlias(_, pattern, variable) =>
                let escaped = escapeKeyword(variable)
                if(escaped != argument) {"const " + escaped + " = " + argument + ";\n"} else {""} +
                self.emitPattern(argument, pattern, arguments, matchCase, jump, last, async)
        }
    }

    emitList(items: List[Pair[Term, Bool]], async: Bool): String {
        "[" + items.map {
            | Pair(item, False) => self.emitTerm(item, async)
            | Pair(item, True) => "..." + self.emitTerm(item, async)
        }.join(", ") + "]"
    }

    processVariantCase(name: String, argument: String): ProcessedVariantCase {
        let variantNameUnqualified = name.reverse().takeWhile { _ != '.' }.reverse()
        let variantName = escapeKeyword(variantNameUnqualified)
        let moduleName = name.dropLast(variantNameUnqualified.size() + 1)
        let variantModule = self.otherModules.grab(moduleName)
        mutable newtype = False
        mutable loneVariant = False
        let newArguments = variantModule.types.collectFirst { definition =>
            definition.variants.find { _.name == variantName }.map { variant =>
                newtype = definition.newtype
                loneVariant = definition.variants.size() == 1
                [...definition.commonFields.map { _.name}, ...variant.fields.map {_.name}]
            }
        }.grab().map { field => if(newtype) { argument } else { argument + "." + escapeKeyword(field) } }
        ProcessedVariantCase(variantName, newtype, loneVariant, newArguments)
    }

    processVariant(name: String): Bool {
        let variantNameUnqualified = name.reverse().takeWhile { _ != '.' }.reverse()
        let variantName = escapeKeyword(variantNameUnqualified)
        let moduleName = name.dropLast(variantNameUnqualified.size() + 1)
        let variantModule = self.otherModules.grab(moduleName)
        mutable newtype = False
        let newArguments = variantModule.types.collectFirst { definition =>
            definition.variants.find { _.name == variantName }.map { variant =>
                newtype = definition.newtype
            }
        }.grab()
        newtype
    }

    emitArgument(callAt: Location, argument: Argument, async: Bool): String {
        argument.value.{
            | ECall(_, StaticCall("ff:core/SourceLocation.callSite", _, _), _, _, _, _) => 
                "\"" + self.moduleName + ":" + callAt.line + ":" + callAt.column + 
                "," + self.packagePair.group + "," + self.packagePair.name + "\""
            | value =>
                self.emitTerm(value, async)
        }
    }

}

data ProcessedVariantCase(
    variantName: String
    newtype: Bool
    loneVariant: Bool
    arguments: List[String]
)

detectIfElse(term: Term): List[Pair[Term, Term]] {
    | ECall(at, StaticCall("ff:core/Core.if", _, _), _, _, [condition, body], _) =>
        [Pair(condition.value, invokeImmediately(body.value))]
    | ECall(at, StaticCall("ff:core/Option.Option_elseIf", _, _), _, _, [option, condition, body], _) =>
        let list = detectIfElse(option.value)
        if(list.isEmpty()) { [] } else:
        [Pair(invokeImmediately(condition.value), invokeImmediately(body.value)), ...list]
    | ECall(at, StaticCall("ff:core/Option.Option_else", _, _), _, _, [option, body], _) =>
        let list = detectIfElse(option.value)
        if(list.isEmpty()) { [] } else:
        [Pair(EVariant(at, "ff:core/Bool.True", [], None), invokeImmediately(body.value)), ...list]
    | _ =>
        []
}

invokeImmediately(function: Term): Term {
    | ELambda(_, Lambda(_, effect, [MatchCase(_, [], [], body)])) =>
        body
    | _ =>
        let effect = TConstructor(function.at, "Q$", []) // Awaits more often than required in async context
        ECall(function.at, DynamicCall(function, False), effect, [], [], [])
}

extractTypeName(type: Type): String {
    | TVariable(at, index) =>
        fail(at, "Unexpected type variable: $" + index)
    | TConstructor t =>
        t.name
}

firstTypeName(types: List[Type]): String {
    types.grabFirst().{
        | TConstructor t => t
        | TVariable t => fail(t.at, " is still a unification variable")
    }.name
}

makeDictionaryName(traitName: String, typeName: String): String {
    traitName.replace(".", "_").replace(":", "_").replace("/", "_") + "$" +
    typeName.replace(".", "_").replace(":", "_").replace("/", "_")
}

charLiteralToNumber(charLiteral: String): String {
    | "'\\t'" => "9"
    | "'\\n'" => "10"
    | "'\\r'" => "13"
    | "'\\\"'" => "34"
    | "'\\''" => "39"
    | value => "" + value.grab(1).codeUnit
}

escapeResolved(word: String): String {
    let parts = word.replace(":", ".").replace("/", ".").split('.')
    let initialParts = parts.dropLast()
    if(initialParts.isEmpty()) {
        escapeKeyword(parts.grabLast())
    } else {
        initialParts.join("_") + "." + escapeKeyword(parts.grabLast())
    }
}

escapeKeyword(word: String): String {
    if(word.grabFirst().isAsciiLower()) {word + "_"} else {word}
}

effectTypeIsAsync(effect: Type): Bool {
    | TConstructor(_, "Q$", _) => True
    | _ => False
}

primitiveTypes = [
    "ff:core/Bool.Bool"
    "ff:core/Char.Char"
    "ff:core/Int.Int"
    "ff:core/Float.Float"
    "ff:core/String.String"
].toSet()
