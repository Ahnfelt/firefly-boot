import Syntax

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

emitModule(packagePair: Pair[String, String], module: Module): String {
    let parts = [
        ["// package " + packagePair.first + ":" + packagePair.second + "/" + module.file.dropLast(3)]
        module.imports.sortBy { i =>
            i.package.first + "." + i.package.second + "." + i.file
        }.map { emitImportDefinition(_) }
        module.types.map { emitTypeDefinition(_) }
        module.lets.map { emitLetDefinition(_) }
        module.functions.map { "export " + emitFunctionDefinition(_) }
        module.extends.map { emitExtendsDefinition(_) }
    ]
    parts.map { _.join("\n\n") }.join("\n\n") + "\n"
}

emitImportDefinition(definition: DImport): String {
    "import * as " + definition.package.first + "_" + definition.package.second + "_" + definition.file + " " +
    "from \"../../" + definition.package.first + "/" + definition.package.second + "/" + definition.file + ".js\""
}

emitLetDefinition(definition: DLet, mutable: Bool = False): String {
    let mutability = if(mutable) {"let"} else {"const"}
    let valueCode = definition.targets.scala.else { emitTerm(definition.value) }
    mutability + " " + escapeKeyword(definition.name) + " = " + valueCode
}

emitExtendsDefinition(definition: DExtend): String {
    let typeName = extractTypeName(definition.type).getReverse().takeWhile { _ != '.' }.getReverse()
    let methods = definition.methods.map { method =>
        method.DFunction(
            signature = method.signature.Signature(
                name = typeName + "_" + method.signature.name
            )
        )
    }
    methods.map { "export " + emitFunctionDefinition(_) }.join("\n\n")
}

emitFunctionDefinition(definition: DFunction, suffix: String = ""): String {
    let signature = emitSignature(definition.signature, suffix)
    definition.targets.javaScript.map { code =>
        if(code.startsWith("#")) {
            code.dropFirst()
        } else {
            signature + " {\n" + code + "\n}"
        }
    }.else:
    definition.body.{
        | Lambda(_, [matchCase]) {
            matchCase.patterns.all {| PVariable(_, None) => True | _ => False }
        } =>
            let body = "// TODO: emitStatements(matchCase.body)"
            signature + " {\n" + body + "\n}"
        | _ =>
            let body = "// TODO: Pattern matching"
            signature + " {\n" + body + "\n}"
    }
}

emitSignature(signature: Signature, suffix: String = ""): String {
    let parameters = "(" + signature.parameters.map(emitParameter).join(", ") + ")"
    "function " + escapeKeyword(signature.name) + suffix + parameters
}

emitParameter(parameter: Parameter): String {
    let defaultValue = parameter.default.map { " = " + emitTerm(_) }.else{""}
    escapeKeyword(parameter.name) + defaultValue
}

emitTypeDefinition(definition: DType): String {
    "// type " + definition.name
}

emitTerm(term: Term): String {
    "// TODO: emitTerm"
}

extractTypeName(type: Type): String {
    | TVariable(at, index) =>
        fail(at, "Unexpected type variable: $" + index)
    | TConstructor t =>
        t.name
}

escapeResolved(word: String): String {
    let parts = word.replace(":", ".").replace("/", ".").split('.').getList()
    let initialParts = parts.dropLast()
    if(initialParts.getEmpty()) {
        escapeKeyword(parts.expectLast())
    } else {
        initialParts.join(".") + "_." + escapeKeyword(parts.expectLast())
    }
}
escapeKeyword(word: String): String {
    if(word.expectFirst().getIsLower()) {word + "_"} else {word}
}
