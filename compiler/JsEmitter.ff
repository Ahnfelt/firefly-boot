import Syntax

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

emitModule(packagePair: Pair[String, String], module: Module): String {
    let parts = [
        ["// package " + packagePair.first + ":" + packagePair.second + "/" + module.file.dropLast(3)]
        module.imports.sortBy { i =>
            i.package.first + "." + i.package.second + "." + i.file
        }.map { emitImportDefinition(_) }
        module.types.map { emitTypeDefinition(_) }
        module.lets.map { emitLetDefinition(_) }
        module.functions.map { "export " + emitFunctionDefinition(_) }
        module.extends.map { emitExtendsDefinition(_) }
    ]
    parts.map { _.join("\n\n") }.join("\n\n") + "\n"
}

emitImportDefinition(definition: DImport): String {
    "import * as " + definition.package.first + "_" + definition.package.second + "_" + definition.file + " " +
    "from \"../../" + definition.package.first + "/" + definition.package.second + "/" + definition.file + ".js\""
}

emitLetDefinition(definition: DLet, mutable: Bool = False): String {
    let mutability = if(mutable) {"let"} else {"const"}
    let valueCode = definition.targets.scala.else { emitTerm(definition.value) }
    mutability + " " + escapeKeyword(definition.name) + " = " + valueCode
}

emitExtendsDefinition(definition: DExtend): String {
    let typeName = extractTypeName(definition.type).getReverse().takeWhile { _ != '.' }.getReverse()
    let methods = definition.methods.map { method =>
        method.DFunction(
            signature = method.signature.Signature(
                name = typeName + "_" + method.signature.name
            )
        )
    }
    methods.map { "export " + emitFunctionDefinition(_) }.join("\n\n")
}

emitFunctionDefinition(definition: DFunction, suffix: String = ""): String {
    let signature = emitSignature(definition.signature, suffix)
    definition.targets.javaScript.map { code =>
        if(code.startsWith("#")) {
            code.dropFirst()
        } else {
            signature + " {\n" + code + "\n}"
        }
    }.else:
    definition.body.{
        | Lambda(_, [matchCase]) {
            matchCase.patterns.all {| PVariable(_, None) => True | PVariable(_, Some(x)) {True /* TODO */} => True | _ => False }
        } =>
            let body = emitStatements(matchCase.body, True)
            signature + " {\n" + body + "\n}"
        | _ =>
            let body = "// TODO: Pattern matching"
            signature + " {\n" + body + "\n}"
    }
}

emitSignature(signature: Signature, suffix: String = ""): String {
    let parameters = "(" + signature.parameters.map(emitParameter).join(", ") + ")"
    "function " + escapeKeyword(signature.name) + suffix + parameters
}

emitParameter(parameter: Parameter): String {
    let defaultValue = parameter.default.map { " = " + emitTerm(_) }.else{""}
    escapeKeyword(parameter.name) + defaultValue
}

emitTypeDefinition(definition: DType): String {
    "// type " + definition.name
}

emitTerm(term: Term): String {
    | EString(at, value) => value
    | EChar(at, value) => value
    | EInt(at, value) => value
    | EFloat(at, value) => value
    | EVariable(at, name, _, _) => escapeResolved(name)
    | EList(at, _, items) =>
        "ff_core_Array.Array_getList([" + items.map {
            | Pair(item, False) => emitTerm(item)
            | Pair(item, True) => "...ff_core_List.List_getArray(" + emitTerm(item) + ")"
        }.join(", ") + "])"
    | EVariant(at, name, _, arguments) =>
        escapeResolved(name) + "(" + arguments.getList().getFlatten().map(emitArgument).join(", ") + ")"
    | EVariantIs(at, name, _) =>
        "(function(_v) { " +
        "return _v._ === '" + escapeResolved(name) + "' ? ff_core_Option.Some(_v) : ff_core_Option.None();" +
        "})"
    | ECopy(at, name, record, fields) =>
        let fieldCode = fields.map { f => escapeKeyword(f.name) + " = " + emitTerm(f.value) }.join(", ")
        "{..." + emitTerm(record) + ", " + fieldCode + "}"
    | EField(at, record, field) =>
        emitTerm(record) + "." + escapeKeyword(field)
    | ELambda(at, Lambda(_, [MatchCase(_, patterns, None, body)])) {
        patterns.all {| PVariable _ => True | _ => False }
    } =>
        let parameters =
            patterns.map {| PVariable p => p.name.map(escapeKeyword).else{"_"} | _ => panic("!") }.join(", ")
        "((" + parameters + ") => {\n" + emitStatements(body, True) + "\n})"
    | ELambda(at, Lambda(_, cases)) =>
        let arguments = cases.expect(0).patterns.pairs().map { "_" + (_.first + 1) }
        let casesString = cases.map { emitCase(arguments, _) }.join("\n")
        "((" + arguments.join(", ") + ") => {\n" + casesString + "\nthrow 'Unexhaustive pattern match'\n})"
    | EPipe(at, value, function) =>
        "(" + emitTerm(function) + ")(" + emitTerm(value) + ")"
    | ECall(at, _, EVariable(_, operator, _, _), [], [value]) {!operator.expectFirst().getIsLetter()} =>
        "(" + operator + emitArgument(value) + ")"
    | ECall(at, _, EVariable(_, operator, _, _), [], [left, right]) {!operator.expectFirst().getIsLetter()} =>
        "(" + emitArgument(left) + " " + operator + " " + emitArgument(right) + ")"
    | ECall(at, _, function, _, arguments) =>
        emitTerm(function) + "(" + arguments.map(emitArgument).join(", ") + ")"
    | ERecord(at, fields) =>
        if(fields.getEmpty()) {"{}"} else {
            let list = fields.map { f => escapeKeyword(f.name) + " = " + emitTerm(f.value) }
            "{\n" + list.join(",\n") + "\n}"
        }
    | EWildcard(at, index) =>
        if(index == 0) {fail(at, "Unbound wildcard")}
        "_w" + index
    | _ =>
        "(function() {\n" + emitStatements(term, True) + "\n})()"
}

emitStatements(term: Term, last: Bool): String {
    term.{
        | EFunctions(at, functions, body) =>
            let functionStrings = functions.map { f =>
                emitFunctionDefinition(DFunction(at, f.signature, f.body, Targets(None, None)))
            }
            functionStrings.join("\n") + "\n" + emitStatements(body, True)
        | ELet(at, mutable, name, valueType, value, body) =>
            emitLetDefinition(DLet(at, name, valueType, value, Targets(None, None)), mutable) + ";\n" + emitStatements(body, True)
        | ESequential(at, before, after) =>
            emitStatements(before, False) + ";\n" + emitStatements(after, last)
        | EAssign(at, operator, name, value) =>
            escapeKeyword(name) + " " + operator + "= " + emitTerm(value)
        | EAssignField(at, operator, record, field, value) =>
            emitTerm(record) + "." + escapeKeyword(field) + " " + operator + "= " + emitTerm(value)
        | _ {last} => "return " + emitTerm(term)
        | _ => emitTerm(term)
    }
}

emitCase(arguments: List[String], matchCase: MatchCase): String {
    "if(true /* TODO */) {\n" + emitStatements(matchCase.body, True) + "\n}"
}

emitArgument(argument: Argument): String {
    emitTerm(argument.value)
}

extractTypeName(type: Type): String {
    | TVariable(at, index) =>
        fail(at, "Unexpected type variable: $" + index)
    | TConstructor t =>
        t.name
}

escapeResolved(word: String): String {
    let parts = word.replace(":", ".").replace("/", ".").split('.').getList()
    let initialParts = parts.dropLast()
    if(initialParts.getEmpty()) {
        escapeKeyword(parts.expectLast())
    } else {
        initialParts.join("_") + "." + escapeKeyword(parts.expectLast())
    }
}
escapeKeyword(word: String): String {
    if(word.expectFirst().getIsLower()) {word + "_"} else {word}
}
