import Tokenizer
import Parser
import Syntax
import Resolver
import Compiler
import Unification
import Builder
import Dependencies
import JsEmitter

type MainCommand {
    BootstrapCommand
    RunCommand(mainPath : String)
    BrowserCommand(mainPath : String)
    BuildCommand(mainPath : String)
}

main(system: NodeSystem): Unit {

    let eq = 1337 != 42

    mutable arguments = system.arguments()
    function consumeArgument(): Option[String] {
        let first = arguments.first()
        arguments = arguments.dropFirst()
        first
    }

    let fireflyPath = consumeArgument().expect()

    let command = consumeArgument().expect().{
        | s {s.endsWith(".ff")} => RunCommand(s.dropLast(3))
        | "run" => RunCommand(consumeArgument().expect().dropLast(3))
        | "browser" => BrowserCommand(consumeArgument().expect().dropLast(3))
        | "build" => BuildCommand(consumeArgument().expect().dropLast(3))
        | "bootstrap" => BootstrapCommand
        | s => panic("Unknown command '" + s + "'")
    }

    command.{
        | RunCommand(moduleName) =>
        | _ =>
            arguments.first().each { argument =>
                panic("Unknown argument: " + argument)
            }
    }

    function buildScript(
        mainFile: String,
        mainPackagePair: PackagePair
        emitTarget: EmitTarget
        resolvedDependencies: ResolvedDependencies
    ) {
        let fixedPackagePaths = if(resolvedDependencies.packagePaths.contains(PackagePair("ff", "core"))) {
            resolvedDependencies.packagePaths
        } else {
            resolvedDependencies.packagePaths.add(PackagePair("ff", "core"), fireflyPath + "/core")
        }
        let compilerModulePath = if(emitTarget != EmitBrowser && emitTarget != EmitExecutable) {
            fireflyPath + "/output/js/ff/compiler/Builder.mjs"
        }
        let targetName = emitTarget.{
            | EmitBuild => "build"
            | EmitNode => "node"
            | EmitBrowser => "browser"
            | EmitExecutable => "executable"
        }
        Builder.build(
            system = system
            emitTarget = emitTarget
            mainPackage = mainPackagePair
            mainModule = mainFile
            resolvedDependencies = resolvedDependencies.ResolvedDependencies(packagePaths = fixedPackagePaths)
            compilerModulePath = compilerModulePath
            tempPath = ".firefly/temporary"
            jsOutputPath = ".firefly/output/" + targetName
            printMeasurements = False
        )
    }

    command.{

        | RunCommand(mainFile) =>
            let resolvedDependencies = Dependencies.process(system.files(), system.fetch(), mainFile + ".ff")
            let fixedDependencies = resolvedDependencies.ResolvedDependencies(
                packagePaths = resolvedDependencies.packagePaths.add(resolvedDependencies.mainPackagePair, ".")
            )
            prepareFireflyDirectory(system.files())
            buildScript(mainFile, resolvedDependencies.mainPackagePair, EmitNode, fixedDependencies)
            importAndRun(system.files(), fireflyPath, "node", resolvedDependencies.mainPackagePair, mainFile, arguments)

        | BrowserCommand(mainFile) =>
            let resolvedDependencies = Dependencies.process(system.files(), system.fetch(), mainFile + ".ff")
            let fixedDependencies = resolvedDependencies.ResolvedDependencies(
                packagePaths = resolvedDependencies.packagePaths.add(resolvedDependencies.mainPackagePair, ".")
            )
            prepareFireflyDirectory(system.files())
            buildScript(mainFile, resolvedDependencies.mainPackagePair, EmitBrowser, fixedDependencies)
            bundleForBrowser(system, resolvedDependencies.mainPackagePair, mainFile)

        | BuildCommand(mainFile) =>
            let resolvedDependencies = Dependencies.process(system.files(), system.fetch(), mainFile + ".ff")
            let fixedDependencies = resolvedDependencies.ResolvedDependencies(
                packagePaths = resolvedDependencies.packagePaths.add(resolvedDependencies.mainPackagePair, ".")
            )
            prepareFireflyDirectory(system.files())
            buildScript(mainFile, resolvedDependencies.mainPackagePair, EmitBuild, fixedDependencies)
            buildScript(mainFile, resolvedDependencies.mainPackagePair, EmitExecutable, fixedDependencies)
            bundleForPkg(system, resolvedDependencies.mainPackagePair, mainFile)
            importAndRun(system.files(), fireflyPath, "build", resolvedDependencies.mainPackagePair, mainFile, arguments)

        | BootstrapCommand =>
            Builder.build(
                system = system
                emitTarget = EmitNode
                mainPackage = PackagePair("ff", "compiler")
                mainModule = "Main"
                resolvedDependencies = ResolvedDependencies(
                    mainPackagePair = PackagePair("ff", "compiler")
                    packages = [].toMap() // Only used for includes currently
                    packagePaths = [
                        Pair(PackagePair("ff","compiler"), "compiler")
                        Pair(PackagePair("ff", "core"), "core")
                    ].toMap()
                    singleFilePackages = [].toSet()
                )
                compilerModulePath = None
                tempPath = "output/temporary"
                jsOutputPath = "output/js"
                printMeasurements = True
            )

    }

}

bundleForPkg(system: NodeSystem, packagePair: PackagePair, mainFile: String) {
    let prefix = ".firefly/output/executable/"
    let mainJsFile = prefix + packagePair.groupName("/") + "/" + mainFile + ".mjs"
    let file = prefix + "Main.bundle.js"
    BuildSystem.internalNodeCallEsBuild(system, mainJsFile, outputPath = file, minify = False)
}

bundleForBrowser(system: NodeSystem, packagePair: PackagePair, mainFile: String) {
    let prefix = ".firefly/output/browser/"
    let mainJsFile = prefix + packagePair.groupName("/") + "/" + mainFile + ".mjs"
    let file = prefix + "Main.bundle.js"
    let browserCode = BrowserCode(
        packageGroup = packagePair.group
        packageName = packagePair.name
        mainFile = mainFile
        assetSystem = AssetSystem([Pair("/", system.files().readStream(""))].toMap())
    ) // TODO
    BuildSystem.internalCallEsBuild(browserCode, mainJsFile, outputPath = file, minify = True, sourceMap = True)
}

importAndRun(
    fs: FileSystem
    fireflyPath: String
    target: String
    packagePair: PackagePair
    mainFile: String
    arguments: List[String]
): Unit
    target node async """
        const process = await import('process');
        const cwd = process.cwd();
        const packagePath = packagePair_.group_ + "/" + packagePair_.name_
        const main = await import(cwd + "/.firefly/output/" + target_ + "/" + packagePath + "/" + mainFile_ + ".mjs");
        await main.$run$(fireflyPath_, ff_core_List.List_toArray(arguments_))
    """

prepareFireflyDirectory(fs: FileSystem) {
    if(!fs.exists(".firefly/output")) {
        if(!fs.exists(".firefly")) {
            fs.createDirectory(".firefly")
        }
        fs.createDirectory(".firefly/output")
    }
}

detectBuildMain(fs: FileSystem, packagePair: PackagePair, mainFile: String): Bool {
    let file = mainFile + ".ff"
    let code = fs.readText(file)
    let tokens = Tokenizer.tokenize(file, code)
    let parser = Parser.make(PackagePair("script", "script"), file, tokens, False)
    let module = parser.parseModuleWithPackageInfo().module
    module.functions.any { definition =>
        (definition.signature.name == "buildMain" || definition.signature.name == "main") &&
        definition.signature.parameters.{ // This is a bit wrong, since BrowserSystem may be aliased or qualified
            | [Parameter p] {p.valueType | TConstructor(_, "BuildSystem", _)} => True
            | _ => False
        }
    }
}
