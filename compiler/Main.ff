import Tokenizer
import Parser
import Syntax
import Resolver
import Compiler
import Unification
import Builder
import Dependencies

type MainCommand {
    BootstrapCommand
    RunCommand(mainPath : String)
    BuildCommand(mainPath : String, platform : BuildPlatform)
}

type BuildPlatform {
    BrowserPlatform
    LinuxPlatform
    WindowsPlatform
    MacosPlatform
}

main(system: NodeSystem): Unit {

    mutable arguments = system.arguments()
    function consumeArgument(): Option[String] {
        let first = arguments.first()
        arguments = arguments.dropFirst()
        first
    }

    let fireflyPath = consumeArgument().expect()
    let parseCommand : String => MainCommand = { // TODO: Fix the code emitter so this can be a direct match instead
        | s {s.endsWith(".ff")} => RunCommand(s.dropLast(3))
        | "run" => RunCommand(consumeArgument().expect().dropLast(3))
        | "browser" => BuildCommand(consumeArgument().expect().dropLast(3), BrowserPlatform)
        | "linux" => BuildCommand(consumeArgument().expect().dropLast(3), LinuxPlatform)
        | "windows" => BuildCommand(consumeArgument().expect().dropLast(3), WindowsPlatform)
        | "macos" => BuildCommand(consumeArgument().expect().dropLast(3), MacosPlatform)
        | "bootstrap" => BootstrapCommand
        | s => panic("Unknown command '" + s + "'")
    }
    let command = parseCommand(consumeArgument().expect())

    command.{
        | RunCommand(moduleName) =>
        | _ =>
            arguments.first().each { argument =>
                panic("Unknown argument: " + argument)
            }
    }

    function buildScript(
        mainFile: String,
        target: String,
        resolvedDependencies: ResolvedDependencies
    ) {
        let fixedPackagePaths = if(resolvedDependencies.packagePaths.contains("ff:core")) {
            resolvedDependencies.packagePaths
        } else {
            resolvedDependencies.packagePaths.add("ff:core", fireflyPath + "/core")
        }
        Builder.build(
            system = system
            target = target
            mainPackage = "script:script"
            mainModule = mainFile
            // TODO: When using the copy syntax, this becomes a promise
            resolvedDependencies = ResolvedDependencies(packagePaths = fixedPackagePaths, singleFilePackages = resolvedDependencies.singleFilePackages)
            tempPath = ".firefly/temporary"
            jsOutputPath = ".firefly/output/" + target
            printMeasurements = False
        )
    }

    deleteRunFile(system.files())

    command.{

        | RunCommand(mainFile) =>
            let resolvedDependencies = Dependencies.process(system.files(), mainFile + ".ff")
            let fixedDependencies = ResolvedDependencies( // TODO: When using the copy syntax, this becomes a promise
                packagePaths = resolvedDependencies.packagePaths.add("script:script", ".")
                singleFilePackages = resolvedDependencies.singleFilePackages
            )
            prepareFireflyDirectory(system.files())
            if(detectBrowserMain(system.files(), Pair("script", "script"), mainFile)) {
                buildScript(mainFile, "browser", fixedDependencies)
            }
            buildScript(mainFile, "node", fixedDependencies)
            writeNodeRunFile(system.files(), mainFile, arguments)

        | BuildCommand(mainFile, BrowserPlatform) =>
            let resolvedDependencies = Dependencies.process(system.files(), mainFile + ".ff")
            let fixedDependencies = resolvedDependencies.ResolvedDependencies(
                packagePaths = resolvedDependencies.packagePaths.add("script:script", ".")
            )
            prepareFireflyDirectory(system.files())
            buildScript(mainFile, "browser", fixedDependencies)
            writeEsbuildRunFile(system.files(), fireflyPath, mainFile)

        | BuildCommand(_, LinuxPlatform) =>
            panic("Not yet implemented: 'linux'")

        | BuildCommand(_, WindowsPlatform) =>
            panic("Not yet implemented: 'windows'")

        | BuildCommand(_, MacosPlatform) =>
            panic("Not yet implemented: 'macos'")

        | BootstrapCommand =>
            Builder.build(
                system = system
                target = "node"
                mainPackage = "ff:compiler"
                mainModule = "Main"
                resolvedDependencies = ResolvedDependencies(
                    packagePaths = [
                        Pair("ff:compiler", "compiler")
                        Pair("ff:core", "core")
                    ].toMap()
                    singleFilePackages = [].toSet()
                )
                tempPath = "output/temporary"
                jsOutputPath = "output/js"
                printMeasurements = True
            )

    }

}

deleteRunFile(fs: FileSystem) {
    if(fs.exists(".firefly/output/run")) {
        fs.delete(".firefly/output/run")
    }
}

writeNodeRunFile(fs: FileSystem, mainFile: String, arguments: List[String]) {
    fs.writeText(".firefly/output/run"
        "node --experimental-fetch '.firefly/output/node/script/script/" + mainFile.replace("'", "''") + ".mjs'" +
        arguments.map {" '" + _.replace("'", "''") + "'"}.join()
    )
}

writeEsbuildRunFile(fs: FileSystem, fireflyPath: String, mainFile: String) {
    let esbuildPath = "" + fireflyPath + "/node_modules/.bin/esbuild"
    let mainPath = ".firefly/output/browser/script/script/" + mainFile + ".mjs"
    let outPath = ".firefly/output/browser/" + mainFile + ".min.js"
    fs.writeText(".firefly/output/run"
        "'" + esbuildPath.replace("'", "''") + "' '" + mainPath.replace("'", "''") + "' " +
        "--outfile='" + outPath.replace("'", "''") + "' " +
        "--platform=browser --target=es6 --bundle --minify --log-level=warning"
    )
}

prepareFireflyDirectory(fs: FileSystem) {
    if(!fs.exists(".firefly/output")) {
        if(!fs.exists(".firefly")) {
            fs.createDirectory(".firefly")
        }
        fs.createDirectory(".firefly/output")
    }
}

detectBrowserMain(fs: FileSystem, packagePair: Pair[String, String], mainFile: String): Bool {
    let file = mainFile + ".ff"
    let code = fs.readText(file)
    let tokens = Tokenizer.tokenize(file, code)
    let parser = Parser.make(Pair("script", "script"), file, tokens, False)
    let module = parser.parseModuleWithPackageInfo().module
    module.functions.any { definition =>
        (definition.signature.name == "browserMain" || definition.signature.name == "main") &&
        definition.signature.parameters.{ // This is a bit wrong, since BrowserSystem may be aliased or qualified
            | [Parameter p] {p.valueType | TConstructor(_, "BrowserSystem", _)} => True
            | _ => False
        }
    }
}
