fromWritten(
    javascriptFile: String
    fireflyFile: String
    writtenStrings: Array[Array[String]]
    writtenSegments: Array[Array[List[Int]]]
    writtenAnchors: IntMap[List[String]]
    writtenNames: StringMap[Int]
): Pair[String, Json] {
    let lines = Array.new()
    let output = Array.new()
    mutable index = 0
    mutable lastSource = 0
    mutable lastLine = 0
    mutable lastColumn = 0
    mutable lastName = 0
    writtenStrings.drain().zip(writtenSegments.drain()).each {| Pair(strings, segments) =>
        writtenAnchors.get(index).each {anchorLines =>
            anchorLines.each {l =>
                lines.push([])
                output.push(l)
            }
        }
        mutable lastOutputColumn = 0
        let line = Array.new()
        segments.each {segment =>
            let relative = Array.new()
            let newOutputColumn = segment.grab(0)
            relative.push(newOutputColumn - lastOutputColumn)
            lastOutputColumn = newOutputColumn
            if(segment.size() > 1) {
                let newSource = segment.grab(1)
                relative.push(newSource - lastSource)
                lastSource = newSource
                let newLine = segment.grab(2)
                relative.push(newLine - lastLine)
                lastLine = newLine
                let newColumn = segment.grab(3)
                relative.push(newColumn - lastColumn)
                lastColumn = newColumn
                if(segment.size() == 5) {
                    let newName = segment.grab(4)
                    relative.push(newName - lastName)
                    lastName = newName
                }
            }
            line.push(relative.drain())
        }
        lines.push(line.drain())
        output.push(strings.join())
        index += 1
    }
    let sourceMap = sourceMap(javascriptFile, [fireflyFile], writtenNames.keys(), lines.drain())
    Pair(output.join("\n"), sourceMap)
}

sourceMap(
    file: String
    sources: List[String]
    names: List[String]
    lines: List[List[List[Int]]]
): Json {
    Json->(
        version = 3
        file = file
        sources = sources
        sourcesContent = [Json.null()]
        names = names
        mappings = toMappings(lines)
    )
}

toMappings(lines: List[List[List[Int]]]): String {
    mutable result = ""
    mutable firstLine = True
    lines.each {line =>
        if(firstLine) {
            firstLine = False
        } else {
            result += ";"
        }
        mutable firstSegment = True
        line.each {segment =>
            if(firstSegment) {
                firstSegment = False
            } else {
                result += ","
            }
            segment.each {field =>
                result += toBase64Vlq(field)
            }
        }
    }
    result
}

toBase64Vlq(value: Int): String {
    let vlq = internalToVlq(value)
    let result = Buffer.new(vlq.size())

    0.until(vlq.size()).each {i =>
        result.setUint8(i, base64Characters.grab(vlq.grab(i)).codeUnit)
    }

    result.toString()
}

internalToVlq(value: Int): List[Int] {
    let vlq = Array.new()
    mutable digit = 0
    mutable v = value

    if(v < 0) {
        v = v.abs().bitLeft(1).bitOr(1)
    } else {
        v = v.bitLeft(1)
    }

    doWhile {
        digit = v.bitAnd(vlqBaseMask)
        v = v.bitRightUnsigned(vlqBaseShift)
        if(v > 0) {
            digit = digit.bitOr(vlqContinuationBit)
        }
        vlq.push(digit)
        v > 0
    }
    vlq.drain()
}

vlqBaseShift = 5
vlqBaseMask = (1.bitLeft(vlqBaseShift)).bitNot()
vlqContinuationBit = 1.bitLeft(vlqBaseShift)
base64Characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
