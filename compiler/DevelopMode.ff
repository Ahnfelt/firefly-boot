import Main
import ModuleCache
import Dependencies
import DependencyLock
import Syntax
import JsEmitter

capability Runner(
    lock: Lock
    lockCondition: LockCondition
    mutable state: RunnerState
    mutable recompile: Bool
    mutable changedSinceCompilationStarted: Set[String]
)

data RunnerState {
    CompilingState
    CompileErrorState(output: String)
    AppRunningState
    AppCrashedState(output: String)
}

run(system: NodeSystem, fireflyPath: Path, mainFile: String, arguments: List[String]) {
    let lock = system.mainTask().lock()
    let lockCondition = lock.condition()
    let runner = Runner(lock, lockCondition, CompilingState, False, Set.new())
    let moduleCache = ModuleCache.new(0)
    mutable iteration = 0
    startProxy(system, runner, 8081, 8080)
    Main.prepareFireflyDirectory(system.path("."))
    startChangeListener(system, runner, system.path("."))
    while {True} {
        let resolvedDependencies = Dependencies.process(
            system.httpClient()
            DependencyLock.new(system.mainTask())
            system.path(mainFile)
        )
        let mainPath = system.path(mainFile)
        let moduleKey = Main.buildScript(
            system
            mainPath
            resolvedDependencies.mainPackagePair
            EmitNode
            resolvedDependencies
            moduleCache
        )
        runner.lock.do {
            runner.state = AppRunningState
        }
        let taskIteration = iteration
        let task = startApp(system, fireflyPath, moduleKey, mainFile, arguments) {exitCode, standardOut, standardError =>
            runner.lock.do {
                runner.state.{
                    | AppRunningState {taskIteration == iteration} => 
                        runner.state = AppCrashedState(
                            "Exited with code: " + exitCode + "\n" + standardOut + "\n" + standardError
                        )
                    | _ => 
                }
            }
        }
        runner.lock.do {
            while {!runner.recompile} {
                runner.lockCondition.sleep()
            }
            task.abort()
            runner.changedSinceCompilationStarted.each {key =>
                moduleCache.invalidate(key)
                // Invalidate dependent files as well (only one layer though, and only if the file defines traits)
            }
            runner.state = CompilingState
            runner.recompile = False
            runner.changedSinceCompilationStarted = Set.new()
            iteration += 1
        }
    }
}

startApp(
    system: NodeSystem
    fireflyPath: Path
    moduleKey: ModuleKey
    mainFile: String
    arguments: List[String]
    onExit: (Int, String, String) => Unit
): Task {
    // Start in separate task + process
    system.mainTask().spawn {task =>
        if(!Main.importAndRun(system, fireflyPath, "node", moduleKey, arguments)) {
            let at = Location(system.path(mainFile).absolute(), 1, 1)
            throw(CompileError(at, "This module does not contain a 'nodeMain' function"))
        }
    }
}

startChangeListener(
    system: NodeSystem
    runner: Runner
    path: Path
) {
    // Listen for file changes
}

startProxy(
    system: NodeSystem
    runner: Runner
    proxyPort: Int
    targetPort: Int
) {
    let net = Js.import("node:net")
    let targetServer = "localhost" // 127.0.0.1
    
    function parseHeaders(headerData: JsValue): JsValue {
        let headers = Js->()
        let lines = headerData->split("\r\n")
        if(lines.get(0)->endsWith(" HTTP/1.1")? || lines.get(0)->endsWith(" HTTP/1.0")?) {
            lines->forEach(Js->{line =>
                let index = line->indexOf(":")
                if(index !== -1) {
                    let key = line->substring(0, index)->trim()->toLowerCase()
                    let value = line->substring(index + 1!)->trim()
                    headers.set(key, value)
                }
            })
        }
        headers
    }
    
    let proxyServer = net->createServer(Js->{clientSocket =>
        mutable buffer = Js->Buffer->alloc(0)
        mutable isHttpNavigateRequest = False
        clientSocket->on("data", Js->{data =>
            buffer = Js->Buffer->concat([buffer, data])
            let headerEnd = buffer->indexOf("\r\n\r\n")
            if(headerEnd !== -1 || buffer->length? >= 64 * 1024) {
                let headerData = buffer->subarray(0, headerEnd)->toString()
                let headers = parseHeaders(headerData)
                
                if(headers.get("sec-fetch-user") === "?1") {
                    isHttpNavigateRequest = True
                    Js->console->log("Detected HTTP request with Sec-Fetch-User")
                    runner.lock.do {
                        if(runner.changedSinceCompilationStarted.size() != 0) {
                            runner.recompile = True
                            runner.lockCondition.wakeAll()
                        }
                    }
                }
                
                mutable targetSocket = Js.undefined()
                targetSocket = net->createConnection(targetPort, targetServer, Js->{
                    Js->console->log("Connected to target server")
                    targetSocket->write(buffer)
                    clientSocket->pipe(targetSocket)->pipe(clientSocket)
                })

                clientSocket->on("error", Js->{err =>
                    Js->console->error("Client socket error:", err)
                    targetSocket->end()
                })

                targetSocket->on("error", Js->{err =>
                    Js->console->error("Target socket error:", err)
                    clientSocket->end()
                })
            }
        })
    })
    
    proxyServer->listen(proxyPort, Js->{
        Js->console->log("Proxy server running on port " + proxyPort)
    })
}
