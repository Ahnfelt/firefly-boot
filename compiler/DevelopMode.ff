import Main
import ModuleCache
import Dependencies
import DependencyLock
import Syntax
import JsEmitter

capability Runner(
    lock: Lock
    lockCondition: LockCondition
    mutable state: RunnerState
    mutable recompile: Bool
    mutable changedSinceCompilationStarted: Set[String]
)

data RunnerState {
    CompilingState
    CompileErrorState(output: String)
    AppRunningState
    AppCrashedState(output: String)
}

run(system: NodeSystem, fireflyPath: Path, mainFile: String, arguments: List[String]) {
    let lock = system.mainTask().lock()
    let lockCondition = lock.condition()
    let runner = Runner(lock, lockCondition, CompilingState, False, Set.new())
    let moduleCache = ModuleCache.new(0)
    mutable iteration = 0
    startProxy(system, runner, 8081, 8080)
    Main.prepareFireflyDirectory(system.path("."))
    startChangeListener(system, runner, system.path("."))
    while {True} {
        let moduleKey = try {
            let resolvedDependencies = Dependencies.process(
                system.httpClient()
                DependencyLock.new(system.mainTask())
                system.path(mainFile)
            )
            let mainPath = system.path(mainFile)
            Some(Main.buildScript(
                system
                mainPath
                resolvedDependencies.mainPackagePair
                EmitNode
                resolvedDependencies
                moduleCache
            ))
        } tryCatch {| CompileError(at, message), error =>
            Log.debug(message)
            Log.debug(" at " + at.file.replace("./", "") + ":" + at.line + ":" + at.column)
            runner.lock.do {
                runner.state = CompileErrorState(message)
            }
            None
        } tryCatch {| CompileErrors(compileErrors), error =>
            compileErrors.each {| CompileError(at, message) =>
                Log.debug(message)
                Log.debug(" at " + at.file.replace("./", "") + ":" + at.line + ":" + at.column)
                runner.lock.do {
                    runner.state = CompileErrorState(message)
                }
            }
            None
        } catchAny {error =>
            Log.debug(error.message())
            runner.lock.do {
                runner.state = CompileErrorState(error.message())
            }
            None
        }
        runner.lock.do {
            runner.state = AppRunningState
        }
        let taskIteration = iteration
        let task = moduleKey.{
            | None => 
                system.mainTask().spawn {_ => }
            | Some(key) => 
                startApp(system, fireflyPath, key, mainFile, arguments) {exitCode, standardOut, standardError =>
                    runner.lock.do {
                        runner.state.{
                            | AppRunningState {taskIteration == iteration} => 
                                runner.state = AppCrashedState(
                                    "Exited with code: " + exitCode + "\n\n" + standardOut + "\n\n" + standardError
                                )
                            | _ => 
                        }
                    }
                }                
        }
        runner.lock.do {
            while {!runner.recompile} {
                runner.lockCondition.sleep()
            }
            task.abort()
            runner.changedSinceCompilationStarted.each {key =>
                moduleCache.invalidate(key)
                // Invalidate dependent files as well (only one layer though, and only if the file defines traits)
            }
            runner.state = CompilingState
            runner.recompile = False
            runner.changedSinceCompilationStarted = Set.new()
            iteration += 1
        }
    }
}

startApp(
    system: NodeSystem
    fireflyPath: Path
    moduleKey: ModuleKey
    mainFile: String
    arguments: List[String]
    onExit: (Int, String, String) => Unit
): Task {
    // Start in separate task + process
    system.mainTask().spawn {task =>
        if(!Main.importAndRun(system, fireflyPath, "node", moduleKey, arguments)) {
            let at = Location(system.path(mainFile).absolute(), 1, 1)
            throw(CompileError(at, "This module does not contain a 'nodeMain' function"))
        }
    }
}

startChangeListener(
    system: NodeSystem
    runner: Runner
    path: Path
) {
    let fs = Js.import("node:fs")
    fs->watch(path.absolute(), Js->(recursive = True), Js->{eventType, fileName =>
        let file: String = fileName?
        if(file.endsWith(".ff") || file.endsWith(".firefly-workspace")) {
            let key = system.path(file).url()
            runner.lock.do {
                // Probably we should also listen for other files, e.g. resources
                runner.changedSinceCompilationStarted = runner.changedSinceCompilationStarted.add(key)
            }
        }
    })
}

startProxy(
    system: NodeSystem
    runner: Runner
    proxyPort: Int
    targetPort: Int
) {
    let net = Js.import("node:net")
    let targetServer = "localhost" // 127.0.0.1
    
    function parseHeaders(headerData: JsValue): JsValue {
        let headers = Js->()
        let lines = headerData->split("\r\n")
        if(lines.get(0)->endsWith(" HTTP/1.1")? || lines.get(0)->endsWith(" HTTP/1.0")?) {
            lines->forEach(Js->{line =>
                let index = line->indexOf(":")
                if(index !== -1) {
                    let key = line->substring(0, index)->trim()->toLowerCase()
                    let value = line->substring(index + 1!)->trim()
                    headers.set(key, value)
                }
            })
        }
        headers
    }
    
    let proxyServer = net->createServer(Js->{clientSocket =>
        mutable buffer = Js->Buffer->alloc(0)
        mutable isHttpNavigateRequest = False
        clientSocket->on("data", Js->{data =>
            system.mainTask().spawn {task =>
                buffer = Js->Buffer->concat([buffer, data])
                let headerEnd = buffer->indexOf("\r\n\r\n")
                if(headerEnd !== -1 || buffer->length? >= 64 * 1024) {
                    let headerData = buffer->subarray(0, headerEnd)->toString()
                    let headers = parseHeaders(headerData)
                    
                    mutable serveWaiter = False
                    if(headers.get("sec-fetch-user") === "?1") {
                        isHttpNavigateRequest = True
                        runner.lock.do {
                            if(runner.changedSinceCompilationStarted.size() != 0) {
                                runner.recompile = True
                                runner.lockCondition.wakeAll()
                                serveWaiter = True
                            } else {
                                serveWaiter = runner.state.{
                                    | AppRunningState => False
                                    | _ => True
                                }
                            }
                        }
                    }
                    
                    mutable targetSocket = Js.undefined()
                    clientSocket->on("error", Js->{err =>
                        if(!targetSocket.isUndefined()) {targetSocket->end()}
                    })

                    function serveWaiterHtml() {
                        let waiterBuffer = waiterHtml.toBuffer()
                        clientSocket->write("HTTP/1.1 200 OK\r\n")
                        clientSocket->write("Content-Type: text/html\r\n")
                        clientSocket->write("Content-Length: " + waiterBuffer.size() + "\r\n")
                        clientSocket->write("Connection: close\r\n")
                        clientSocket->write("\r\n")
                        clientSocket->write(waiterBuffer)
                        clientSocket->end()
                    }
                    
                    if(serveWaiter) {
                        serveWaiterHtml()
                    } else {
                        mutable connectedToTarget = False
                        targetSocket = net->createConnection(targetPort, targetServer, Js->{
                            connectedToTarget = True
                            targetSocket->write(buffer)
                            clientSocket->pipe(targetSocket)->pipe(clientSocket)
                        })

                        targetSocket->on("error", Js->{err =>
                            if(connectedToTarget) {
                                Js->console->error("Target socket error:", err)
                                clientSocket->end()?
                            } else {
                                serveWaiterHtml()
                            }
                        })
                    }
                }
            }
        })
    })
    
    proxyServer->listen(proxyPort, Js->{
        Js->console->log("Proxy server running on port " + proxyPort)
    })
}

waiterHtml = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="refresh" content="1">
    <title>Firefly develop mode</title>
</head>
<body>
    <h1>Firefly develop mode</h1>
    <p>Refreshing...</p>
</body>
</html>
"""
