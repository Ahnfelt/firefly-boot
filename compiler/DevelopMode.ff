import Main
import ModuleCache
import Dependencies
import DependencyLock
import Syntax
import JsEmitter

capability Runner(
    lock: Lock
    lockCondition: LockCondition
    mutable iteration: Int
    mutable state: RunnerState
    mutable changedSinceCompilationStarted: Set[String]
    mutable recompile: Bool
    mutable appRunning: Bool
)

data RunnerState {
    CompilingState
    CompileErrorState(output: String)
    ApplicationRunningState
    ApplicationCrashedState(output: String)
}

run(system: NodeSystem, fireflyPath: Path, mainFile: String, arguments: List[String]) {
    let lock = system.mainTask().lock()
    let lockCondition = lock.condition()
    let runner = Runner(lock, lockCondition, 1, CompilingState, Set.new(), False, False)
    startProxy(system, runner, 8081, 8080)
    startChangeListener(system, runner, system.path("."))
    let moduleCache = ModuleCache.new(0)
    while {True} {
        Log.debug("Compiling...")
        let moduleKey = build(system, runner, mainFile, moduleCache)
        let task = moduleKey.{
            | None => 
                system.mainTask().spawn {_ => }
            | Some(key) => 
                Log.debug("Running...")
                runner.lock.do {
                    runner.state = ApplicationRunningState
                }
                startApp(system, runner, fireflyPath, key, mainFile, arguments)
        }
        runner.lock.do {
            if(runner.appRunning) {
                Log.debug("Still shutting down app...")
                while {!runner.appRunning} {
                    runner.lockCondition.sleep()
                }
            }
            Log.debug("Waiting...")
            while {!runner.recompile} {
                runner.lockCondition.sleep()
            }
            Log.debug("Shutting down app...")
            task.abort()
            runner.changedSinceCompilationStarted.each {key =>
                moduleCache.invalidate(key)
                moduleCache.emittedModules = Map.new() // Since we currenly delete all files each build
                // Invalidate dependent files as well (only one layer though, and only if the file defines traits)
            }
            runner.state = CompilingState
            runner.recompile = False
            runner.changedSinceCompilationStarted = Set.new()
            runner.iteration += 1
        }
    }
}

build(system: NodeSystem, runner: Runner, mainFile: String, moduleCache: ModuleCache): Option[ModuleKey] {
    try {
        Main.prepareFireflyDirectory(system.path("."))
        let resolvedDependencies = Dependencies.process(
            system.httpClient()
            DependencyLock.new(system.mainTask())
            system.path(mainFile)
        )
        let mainPath = system.path(mainFile)
        Some(Main.buildScript(
            system
            mainPath
            resolvedDependencies.mainPackagePair
            EmitNode
            resolvedDependencies
            moduleCache
        ))
    } tryCatch {| CompileError(at, message), error =>
        Log.debug(message)
        Log.debug(" at " + at.file.replace("./", "") + ":" + at.line + ":" + at.column)
        runner.lock.do {
            runner.state = CompileErrorState(message)
        }
        None
    } tryCatch {| CompileErrors(compileErrors), error =>
        compileErrors.each {| CompileError(at, message) =>
            Log.debug(message)
            Log.debug(" at " + at.file.replace("./", "") + ":" + at.line + ":" + at.column)
            runner.lock.do {
                runner.state = CompileErrorState(message)
            }
        }
        None
    } catchAny {error =>
        Log.debug(error.message())
        runner.lock.do {
            runner.state = CompileErrorState(error.message())
        }
        None
    }    
}

startApp(
    system: NodeSystem
    runner: Runner
    fireflyPath: Path
    moduleKey: ModuleKey
    mainFile: String
    arguments: List[String]
): Task {
    let taskIteration = runner.iteration
    system.mainTask().spawn {task =>
        try {
            let runFile = Main.locateRunFile(system, "node", moduleKey)
            let runFilePath = if(runFile.contains("://")) {system.pathFromUrl(runFile)} else {system.path(runFile)}
            let startPath = runFilePath.parent().grab().slash(runFilePath.base() + ".start.mjs")
            startPath.writeText(
                "import * as run from " + Json.string(runFilePath.url()).write() + "\n" + 
                "await run.$run$(" + Json.string(fireflyPath.absolute()).write() + ", " + Json.toJson(arguments).write() + ")"
            )
            let relativeStartFile = startPath.relativeTo(system.path("."))
            let result = system.execute(relativeStartFile, arguments, node = True)
            let standardOut = result.standardOut.toString()
            let standardError = result.standardError.toString()
            runner.lock.do {
                runner.appRunning = False
                Log.debug("Exited with code: " + result.exitCode + "\n\n" + standardOut + "\n\n" + standardError)
                runner.state.{
                    | ApplicationRunningState {taskIteration == runner.iteration} => 
                        runner.state = ApplicationCrashedState(
                            "Exited with code: " + result.exitCode + "\n\n" + standardOut + "\n\n" + standardError
                        )
                    | _ => 
                }
                runner.lockCondition.wakeAll()
            }
        } catchAny {error =>
            runner.lock.do {
                runner.appRunning = False
                runner.lockCondition.wakeAll()
            }
        }
    }
}

startChangeListener(
    system: NodeSystem
    runner: Runner
    path: Path
) {
    let fs = Js.import("node:fs")
    fs->watch(path.absolute(), Js->(recursive = True), Js->{eventType, fileName =>
        if(!fileName.isNullOrUndefined()):
        let file: String = fileName?
        if(file.endsWith(".ff") || file.endsWith(".firefly-workspace")) {
            let key = system.path(file).absolute()
            runner.lock.do {
                // Probably we should also listen for other files, e.g. resources
                Log.debug("Changed! " + key)
                runner.changedSinceCompilationStarted = runner.changedSinceCompilationStarted.add(key)
            }
        }
    })
}

startProxy(
    system: NodeSystem
    runner: Runner
    proxyPort: Int
    targetPort: Int
) {
    let net = Js.import("node:net")
    let targetServer = "localhost" // 127.0.0.1
    
    function parseHeaders(headerData: JsValue): JsValue {
        let headers = Js->()
        let lines = headerData->split("\r\n")
        if(lines.get(0)->endsWith(" HTTP/1.1")? || lines.get(0)->endsWith(" HTTP/1.0")?) {
            lines->forEach(Js->{line =>
                let index = line->indexOf(":")
                if(index !== -1) {
                    let key = line->substring(0, index)->trim()->toLowerCase()
                    let value = line->substring(index + 1!)->trim()
                    headers.set(key, value)
                }
            })
        }
        headers
    }
    
    let proxyServer = net->createServer(Js->{clientSocket =>
        system.mainTask().spawn {task =>
            mutable buffer = Js->Buffer->alloc(0)
            mutable isHttpNavigateRequest = False
            clientSocket->on("data", Js->{data =>
                buffer = Js->Buffer->concat([buffer, data])
                let headerEnd = buffer->indexOf("\r\n\r\n")
                if(headerEnd !== -1 || buffer->length? >= 64 * 1024) {
                    let headerData = buffer->subarray(0, headerEnd)->toString()
                    let headers = parseHeaders(headerData)
                    
                    let refreshLike = headers.get("sec-fetch-dest") === "document"
                    let serveWaiter = if(refreshLike) {
                        runner.lock.do {
                            if(runner.changedSinceCompilationStarted.size() != 0) {
                                runner.recompile = True
                                runner.lockCondition.wakeAll()
                                True
                            } else {
                                runner.state.{
                                    | ApplicationRunningState => runner.recompile
                                    | _ => True
                                }
                            }
                        }
                    } else {
                        let j: Json = headers.get("sec-fetch-dest")?
                        False
                    }
                    if(refreshLike) {
                        Log.debug("Refreshed!")
                    }
                    
                    mutable targetSocket = Js.undefined()
                    clientSocket->on("error", Js->{err =>
                        if(!targetSocket.isUndefined()) {targetSocket->end()}
                    })

                    function serveWaiterHtml() {
                        let status = runner.state.{
                            | _ {runner.recompile} => "Restarting..."
                            | ApplicationCrashedState(output) => "Application crashed!"
                            | ApplicationRunningState => "Starting application..."
                            | CompileErrorState(output) => "Compile error!"
                            | CompilingState => "Compiling..."
                        }
                        let waiterBuffer = waiterHtml.replace("[STATUS]", status).toBuffer()
                        clientSocket->write("HTTP/1.1 200 OK\r\n")
                        clientSocket->write("Content-Type: text/html\r\n")
                        clientSocket->write("Content-Length: " + waiterBuffer.size() + "\r\n")
                        clientSocket->write("Connection: close\r\n")
                        clientSocket->write("\r\n")
                        clientSocket->write(waiterBuffer)
                        clientSocket->end()
                    }
                    
                    if(serveWaiter) {
                        serveWaiterHtml()
                    } else {
                        mutable connectedToTarget = False
                        targetSocket = net->createConnection(targetPort, targetServer, Js->{
                            connectedToTarget = True
                            targetSocket->write(buffer)
                            clientSocket->pipe(targetSocket)->pipe(clientSocket)
                        })

                        targetSocket->on("error", Js->{err =>
                            if(connectedToTarget) {
                                Log.debug("Target socket error:" + err?)
                                clientSocket->end()?
                            } elseIf {!refreshLike} {
                                clientSocket->write("HTTP/1.1 503 Service Unavailable\r\n")
                                clientSocket->write("Connection: close\r\n")
                                clientSocket->write("\r\n")
                                clientSocket->end()?
                            } else {
                                Log.debug("Fallback!")
                                serveWaiterHtml()
                            }
                        })
                    }
                }
            })
        }
    })
    
    proxyServer->listen(proxyPort, Js->{
        Js->console->log("Proxy server running on port " + proxyPort)
    })
}

waiterHtml = """<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="refresh" content="1">
    <title>Firefly develop mode</title>
</head>
<body>
    <h1>Firefly develop mode</h1>
    <p>[STATUS]</p>
</body>
</html>
"""
