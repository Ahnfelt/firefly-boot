import Syntax
import Unification
import Environment

type Dictionaries(
    instances: Map[InstanceKey, InstanceValue]
)

make(modules: List[Module]): Dictionaries {
    Dictionaries(Unification.make(modules).instances)
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

extend self: Dictionaries {

    processModule(module: Module, otherModules: List[Module]): Module {
        let environment = Environment.make(module, otherModules)
        let functionSignatures = environment.symbols.pairs().collect {
            | Pair(name, s) {!s.isVariable} => Some(Pair(name, s.signature))
            | _ => None
        }.toMap()

        let lets = module.lets.map { self.processLetDefinition(functionSignatures, _) }
        let functions = module.functions.map { self.processFunctionDefinition(functionSignatures, _) }
        let extends = module.extends.map { self.processExtendDefinition(functionSignatures, _) }
        //let traits = module.traits.map { self.processTraitDefinition(functionSignatures, _) }
        let instances = module.instances.map { self.processInstanceDefinition(functionSignatures, _) }
        Module(...module,
            //traits = traits,
            instances = instances,
            extends = extends,
            lets = lets,
            functions = functions,
        )
    }

    processLetDefinition(functions: Map[String, Signature], definition: DLet): DLet {
        DLet(...definition,
            value = self.processTerm(functions, definition.value)
        )
    }

    processExtendDefinition(functions: Map[String, Signature], definition: DExtend): DExtend {
        DExtend(...definition,
            methods = definition.methods.map { self.processFunctionDefinition(functions, _) }
        )
    }

    processFunctionDefinition(functions: Map[String, Signature], definition: DFunction): DFunction {
        let instances = constraintsToInstances(definition.signature.constraints)
        let self2 = Dictionaries(...self, instances = self.instances.addAll(instances))
        DFunction(...definition,
            body = self2.processLambda(functions, definition.body)
        )
    }

    processInstanceDefinition(functions: Map[String, Signature], definition: DInstance): DInstance {
        let instances = constraintsToInstances(definition.constraints)
        let self2 = Dictionaries(...self, instances = self.instances.addAll(instances))
        DInstance(...definition,
            methods = definition.methods.map { self2.processFunctionDefinition(functions, _) }
        )
    }

    processLambda(functions: Map[String, Signature], definition: Lambda): Lambda {
        Lambda(...definition,
            cases = definition.cases.map { case =>
                // TODO: Remove the case variables from the functions
                MatchCase(...case,
                    condition = case.condition.map { self.processTerm(functions, _) }
                    body = self.processTerm(functions, case.body)
                )
            }
        )
    }

    processTerm(functions: Map[String, Signature], term: Term): Term {
        term.{
            | EString _ => term
            | EChar _ => term
            | EInt _ => term
            | EFloat _ => term
            | EVariable _ => term
            | EField e => EField(...e, record = self.processTerm(functions, e.record))
            | EWildcard e => term
            | EList e => EList(...e,
                items = e.items.map {| Pair(item, b) => Pair(self.processTerm(functions, item), b) }
            )
            | ESequential e => ESequential(...e,
                before = self.processTerm(functions, e.before)
                after = self.processTerm(functions, e.after)
            )
            | ELet e =>
                let newFunctions = functions.remove(e.name)
                ELet(...e,
                    value = self.processTerm(functions, e.value)
                    body = self.processTerm(newFunctions, e.body)
                )
            | ELambda e => ELambda(...e, lambda = self.processLambda(functions, e.lambda))
            | EVariant e => EVariant(...e,
                arguments = e.arguments.map { _.map { self.processArgument(functions, _) } }
            )
            | EVariantIs e => term
            | ECopy e => ECopy(...e,
                record = self.processTerm(functions, e.record)
                arguments = e.arguments.map { self.processField(functions, _) }
            )
            | EPipe e => EPipe(...e,
                value = self.processTerm(functions, e.value)
                function = self.processTerm(functions, e.function)
            )
            | ECall(at, instanceCall, tailCall, EVariable(_, functionName)@x, typeArguments, arguments, _) {
                functions.contains(functionName)
            } =>
                let signature = functions.expect(functionName)
                let dictionaries = signature.constraints.map {
                    self.makeDictionary(signature.generics, typeArguments, _)
                }
                ECall(
                    at = at
                    instanceCall = instanceCall
                    tailCall = tailCall
                    function = x
                    typeArguments = typeArguments
                    arguments = arguments.map { self.processArgument(functions, _) }
                    dictionaries = dictionaries
                )
            | ECall e =>
                ECall(...e,
                    function = self.processTerm(functions, e.function)
                    arguments = e.arguments.map { self.processArgument(functions, _) }
                )
            | ERecord e => ERecord(...e, fields = e.fields.map { self.processField(functions, _) })
            | EFunctions e =>
                let newFunctions = functions.addAll(e.functions.map { f =>
                    Pair(f.signature.name, f.signature)
                }.toMap())
                EFunctions(...e,
                    functions = e.functions.map { self.processFunctionDefinition(newFunctions, _) }
                    body = self.processTerm(newFunctions, e.body)
                )
            | EAssign e => EAssign(...e, value = self.processTerm(functions, e.value))
            | EAssignField e => EAssignField(...e,
                record = self.processTerm(functions, e.record)
                value = self.processTerm(functions, e.value)
            )
        }
    }

    processArgument(functions: Map[String, Signature], argument: Argument): Argument {
        Argument(...argument, value = self.processTerm(functions, argument.value))
    }

    processField(functions: Map[String, Signature], field: Field): Field {
        Field(...field, value = self.processTerm(functions, field.value))
    }

    makeDictionary(typeParameters: List[String], typeArguments: List[Type], constraint: Constraint): Dictionary {
        let instantiationMap = typeParameters.zip(typeArguments).toMap()
        let unification = Unification.make([])
        let newGenerics = constraint.generics.map { unification.instantiate(instantiationMap, _) }
        let firstType = newGenerics.expectFirst().{
            | TConstructor t => t
            | TVariable t => fail(t.at, " is still a unification variable")
        }
        let instance = self.instances.expect(InstanceKey(constraint.name, firstType.name))
        let dictionaries = instance.constraints.map { c =>
            self.makeDictionary(instance.generics, firstType.generics, c)
        }
        Dictionary(instance.packageName, instance.moduleName, constraint.name, firstType.name, dictionaries)
    }

}

constraintsToInstances(constraints: List[Constraint]): Map[InstanceKey, InstanceValue] {
    constraints.map { c =>
        let typeName = c.generics.expectFirst().{
            | TConstructor(_, name, _) => name
            | TVariable(_, i) => fail(c.at, "Unexpected unification variable: $" + i)
        }
        Pair(
            InstanceKey(c.name, typeName)
            InstanceValue(
                generics = []
                constraints = []
                packageName = ""
                moduleName = ""
                traitName = c.name
                typeArguments = c.generics
            )
        )
    }.toMap()
}
