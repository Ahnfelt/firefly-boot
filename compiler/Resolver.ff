import Syntax

type Resolver(
    variables: Map[String, String]
    variants: Map[String, String]
    types: Map[String, String]
    asyncTypes: Set[String]
    typeParameters: Set[String]
    traits: Map[String, String]
    mutable nextUnificationVariableIndex: Int
)

make(): Resolver {
    Resolver(
        variables = [].toMap()
        variants = [].toMap()
        types = [].toMap()
        asyncTypes = [].toSet()
        typeParameters = [].toSet()
        traits = [].toMap()
        nextUnificationVariableIndex = 2 // To avoid collision with the parser and unification
    )
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

extend self: Resolver {

    freshUnificationVariable(at: Location): Type {
        let result = TVariable(at, self.nextUnificationVariableIndex)
        self.nextUnificationVariableIndex += 3
        result
    }

    resolveModule(module: Module, otherModules: List[Module]): Module {
        let moduleNamespace =
            module.file.replace("\\", "/").reverse().takeWhile { _ != '/' }.reverse().takeWhile { _ != '.' }
        let self2 = self.processImports(module.imports, otherModules)
        let self3 = self2.processDefinitions(module, None)
        module.Module(
            types = module.types.map { self3.resolveTypeDefinition(_) }
            traits = module.traits.map { self3.resolveTraitDefinition(_) }
            instances = module.instances.map { self3.resolveInstanceDefinition(_) }
            extends = module.extends.map { self3.resolveExtendDefinition(_) }
            lets = module.lets.map { self3.resolveLetDefinition(_, True) }
            functions = module.functions.map { self3.resolveFunctionDefinition(_, True) }
        )
    }

    processImports(imports: List[DImport], modules: List[Module]): Resolver {
        mutable resolver = self
        imports.each { import =>
            modules.find { _.file.dropLast(3) == import.file }.{
                | Some(module) =>
                    resolver = resolver.processDefinitions(module, Some(import.alias))
                | None =>
                    fail(import.at, "No such module: " + import.file)
            }
        }
        resolver
    }

    processDefinitions(module: Module, importAlias: Option[String]): Resolver {
        function entry(name: String, unqualified: Bool): List[Pair[String, String]] {
            let full =
                module.packagePair.first + ":" + module.packagePair.second + "/" +
                module.file.dropLast(3) + "." + name
            importAlias.{
                | None => [Pair(name, full), Pair(full, full)]
                | Some(alias) { unqualified } => [Pair(alias + "." + name, full), Pair(name, full), Pair(full, full)]
                | Some(alias) => [Pair(alias + "." + name, full), Pair(full, full)]
            }
        }
        let isCore = // TODO: Extend imports to list unqualified symbols instead of this
            module.packagePair.first == "ff" &&
            module.packagePair.second == "core" &&
            module.file == "Core.ff"
        let lets = module.lets.flatMap { entry(_.name, isCore) }.toMap()
        let functions = module.functions.flatMap { entry(_.signature.name, isCore) }.toMap()
        let traitMethods = module.traits.flatMap { _.methods }.flatMap { entry(_.name, False) }.toMap()
        let traits = module.traits.flatMap { entry(_.name, True) }.toMap()
        let types = module.types.flatMap { entry(_.name, True) }.toMap()
        let asyncTypes = module.types.filter { _.generics.first().any {_ == "Q$"} }
            .flatMap { entry(_.name, True).map {_.first} }.toSet()
        let variants = module.types.flatMap { _.variants }.flatMap { entry(_.name, True) }.toMap()
        Resolver(
            variables = self.variables.addAll(lets).addAll(functions).addAll(traitMethods)
            variants = self.variants.addAll(variants)
            types = self.types.addAll(types)
            asyncTypes = self.asyncTypes.addAll(asyncTypes)
            typeParameters = [].toSet()
            traits = self.traits.addAll(traits)
        )
    }

    resolveTypeDefinition(definition: DType): DType {
        let generics = definition.generics.map { g => Pair(g, g) }.toMap()
        let self2 = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
        )
        definition.DType(
            constraints = definition.constraints.map { self2.resolveConstraint(_, True) }
            commonFields = definition.commonFields.map { f =>
                f.Parameter(
                    valueType = self2.resolveType(f.valueType, True)
                    default = f.default.map { self2.resolveTerm(_) }
                )
            }
            variants = definition.variants.map { v =>
                v.Variant(fields = v.fields.map { f =>
                    f.Parameter(
                        valueType = self2.resolveType(f.valueType, True)
                        default = f.default.map { self2.resolveTerm(_) }
                    )
                })
            }
        )
    }

    resolveTraitDefinition(definition: DTrait): DTrait {
        let generics = definition.generics.map { g => Pair(g, g) }.toMap()
        let self2 = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
        )
        definition.DTrait(
            constraints = definition.constraints.map { self2.resolveConstraint(_, True) },
            methods = definition.methods.map { self2.resolveSignature(_, True) },
            methodDefaults = definition.methodDefaults // TODO
        )
    }

    resolveInstanceDefinition(definition: DInstance): DInstance {
        let generics = definition.generics.map { g => Pair(g, g) }.toMap()
        let self2 = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
        )
        let traitName = self2.traits.get(definition.traitName).else {
            fail(definition.at, "No such trait: " + definition.traitName)
        }
        definition.DInstance(
            constraints = definition.constraints.map { self2.resolveConstraint(_, True) }
            traitName = traitName
            typeArguments = definition.typeArguments.map { self2.resolveType(_, True) }
            methods = definition.methods.map { self2.resolveFunctionDefinition(_, False) }
        )
    }

    resolveExtendDefinition(definition: DExtend): DExtend {
        let generics = definition.generics.map { g => Pair(g, g) }.toMap()
        let self2 = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
            variables = self.variables.add(definition.name, definition.name)
        )
        definition.DExtend(
            constraints = definition.constraints.map { self2.resolveConstraint(_, True) }
            type = self2.resolveType(definition.type, True)
            methods = definition.methods.map { self2.resolveFunctionDefinition(_, True) }
        )
    }

    resolveLetDefinition(definition: DLet, topLevel: Bool): DLet {
        let self2 = self.Resolver(variables = self.variables.add(definition.name, definition.name))
        definition.DLet(
            variableType = self.resolveType(definition.variableType, topLevel)
            value = self.resolveTerm(definition.value)
        )
    }

    resolveTerm(term: Term): Term {
        | EString _ => term
        | EChar _ => term
        | EInt _ => term
        | EFloat _ => term
        | EVariable e =>
            self.variables.get(e.name).map { e.EVariable(name = _) }.else {
                if(e.name.first().any { _.isAsciiLetter() }) {
                    fail(e.at, "No such variable: " + e.name)
                } else {
                    term
                }
            }
        | EList(at, t, items) =>
            EList(at, self.resolveType(t, False), items.map { | Pair(item, spread) =>
                Pair(self.resolveTerm(item), spread)
            })
        | EVariant(at, name, typeArguments, arguments) =>
            EVariant(
                at = at
                name = self.variants.get(name).else { fail(at, "No such variant: " + name) }
                typeArguments = typeArguments.map { self.resolveType(_, False) }
                arguments = arguments.map { _.map { a => a.Argument(value = self.resolveTerm(a.value)) }}
            )
        | EVariantIs(at, name, typeArguments) =>
            EVariantIs(
                at = at
                name = self.variants.get(name).else { fail(at, "No such variant: " + name) }
                typeArguments = typeArguments.map { self.resolveType(_, False) }
            )
        | ECopy(at, name, record, arguments) =>
            ECopy(
                at = at
                name = self.variants.get(name).else { fail(at, "No such variant: " + name) }
                record = self.resolveTerm(record)
                arguments = arguments.map { f => f.Field(value = self.resolveTerm(f.value)) }
            )
        | EField e =>
            e.EField(record = self.resolveTerm(e.record))
        | ELambda(at, Lambda(lambdaAt, cases)) =>
            ELambda(at, Lambda(lambdaAt, cases.map { self.resolveCase(_) }))
        | EPipe(at, value, function) =>
            EPipe(
                at = at
                value = self.resolveTerm(value)
                function = self.resolveTerm(function)
            )
        | ECall(at, instanceCall, tailCall, function, typeArguments, arguments, dictionaries) =>
            ECall(
                at = at
                instanceCall = instanceCall
                tailCall = tailCall
                function = self.resolveTerm(function)
                typeArguments = typeArguments.map { self.resolveType(_, False) }
                arguments = arguments.map { a => a.Argument(value = self.resolveTerm(a.value)) }
                dictionaries = dictionaries
            )
        | ERecord(at, fields) =>
            ERecord(
                at = at
                fields = fields.map { f => f.Field(value = self.resolveTerm(f.value)) }
            )
        | EWildcard e =>
            if(e.index == 0) { fail(e.at, "Unbound wildcard") }
            e.EWildcard()
        | EFunctions(at, functions, body) =>
            let functionMap = functions.map { _.signature.name }.map { name => Pair(name, name) }.toMap()
            let self2 = self.Resolver(variables = self.variables.addAll(functionMap))
            EFunctions(
                at = at,
                functions = functions.map { self2.resolveFunctionDefinition(_, False) },
                body = self2.resolveTerm(body)
            )
        | ELet e =>
            let self2 = self.Resolver(variables = self.variables.add(e.name, e.name))
            e.ELet(
                valueType = self.resolveType(e.valueType, False)
                value = self.resolveTerm(e.value)
                body = self2.resolveTerm(e.body)
            )
        | ESequential(at, before, after) =>
            ESequential(
                at = at
                before = self.resolveTerm(before)
                after = self.resolveTerm(after)
            )
        | EAssign(at, operator, variable, value) =>
            EAssign(
                at = at
                operator = operator
                variable = self.variables.get(variable).else { fail(at, "No such variable: " + variable) }
                value = self.resolveTerm(value)
            )
        | EAssignField(at, operator, record, field, value) =>
            EAssignField(
                at = at
                operator = operator
                record = self.resolveTerm(record)
                field = field
                value = self.resolveTerm(value)
            )
    }

    resolveType(type: Type, topLevel: Bool): Type {
        | TVariable _, _ =>
            type
        | TConstructor constructor, _ =>
            let name = if(constructor.name.contains("$")) {
                constructor.name
            } else {
                self.types.get(constructor.name).else { fail(constructor.at, "No such type: " + constructor.name) }
            }
            let effect = if(self.asyncTypes.contains(constructor.name)) {
                if(topLevel) {
                    if(!self.typeParameters.contains("Q$")) {
                        TConstructor(constructor.at, "ff:core/Nothing.Nothing", [])
                    } else {
                        [TConstructor(constructor.at, "Q$", [])]
                    }
                } else {
                    [self.freshUnificationVariable(constructor.at)]
                }
            } else {[]}
            constructor.TConstructor(
                name = name
                generics = [...effect, ...constructor.generics.map { self.resolveType(_, topLevel) }]
            )
    }

    resolveConstraint(constraint: Constraint, topLevel: Bool): Constraint {
        let name =
            self.traits.get(constraint.name).else { fail(constraint.at, "No such trait: " + constraint.name) }
        constraint.Constraint(
            name = name
            generics = constraint.generics.map { self.resolveType(_, topLevel) }
        )
    }

    resolveFunctionDefinition(definition: DFunction, topLevel: Bool): DFunction {
        let signature = if(topLevel) {
            definition.signature.Signature(
                generics = [TConstructor(constructor.at, "Q$", []), ...definition.signature.generics]
            )
        } else { definition.signature }
        signature.generics.find { name => self.typeParameters.contains(name) }.each { name =>
            fail(definition.at, "Type parameter " + name + " is already in scope")
        }
        let variableMap = signature.parameters.map { _.name }.map { name => Pair(name, name) }.toMap()
        let typeMap = signature.generics.map { name => Pair(name, name) }.toMap()
        let self2 = self.Resolver(
            variables = self.variables.addAll(variableMap)
            typeParameters = self.typeParameters.addAll(signature.generics.toSet())
            types = self.types.addAll(typeMap)
            asyncTypes = self.asyncTypes.removeAll(signature.generics.toSet())
        )
        let newSignature = self2.resolveSignature(signature, topLevel)
        let body = definition.body.Lambda(cases = definition.body.cases.map { self2.resolveCase(_) })
        DFunction(definition.at, newSignature, body, definition.targets)
    }

    resolveSignature(signature: Signature, topLevel: Bool): Signature {
        signature.Signature(
            constraints = signature.constraints.map { self.resolveConstraint(_, topLevel) }
            parameters = signature.parameters.map { p =>
                p.Parameter(
                    valueType = self.resolveType(p.valueType, topLevel)
                    default = p.default.map { self.resolveTerm(_) }
                )
            }
            returnType = self.resolveType(signature.returnType, topLevel)
        )
    }

    resolveCase(case: MatchCase): MatchCase {
        function findVariables(pattern: MatchPattern): Map[String, String] {
            | PString _ =>
                Map.empty()
            | PInt _ =>
                Map.empty()
            | PChar _ =>
                Map.empty()
            | PVariable(_, Some(name)) =>
                [Pair(name, name)].toMap()
            | PVariable(_, None) =>
                Map.empty()
            | PVariant(_, _, patterns) =>
                patterns.map(findVariables).foldLeft(Map.empty[String, String]()) {_.addAll(_)}
            | PVariantAs(_, _, variable) =>
                variable.toList().map { x => Pair(x, x) }.toMap()
            | PAlias(_, pattern, variable) =>
                [Pair(variable, variable)].toMap().addAll(findVariables(pattern))
        }
        let variableMap = case.patterns.map(findVariables).foldLeft(Map.empty[String, String]()) {_.addAll(_)}
        mutable guards = []
        let variableMap2 = case.guards.foldLeft(variableMap) { variableMap1, g =>
            let self2 = self.Resolver(variables = self.variables.addAll(variableMap1))
            let guard = g.MatchGuard(term = self2.resolveTerm(g.term), pattern = self2.resolvePattern(g.pattern))
            guards = [guard, ...guards]
            variableMap1.addAll(findVariables(guard.pattern))
        }
        let self3 = self.Resolver(variables = self.variables.addAll(variableMap2))
        MatchCase(
            at = case.at
            patterns = case.patterns.map { self.resolvePattern(_) }
            guards = guards.reverse()
            body = self3.resolveTerm(case.body)
        )
    }

    resolvePattern(pattern: MatchPattern): MatchPattern {
        | PString _ =>
            pattern
        | PInt _ =>
            pattern
        | PChar _ =>
            pattern
        | PVariable _ =>
            pattern
        | PVariant(at, name, patterns) =>
            let newName = self.variants.get(name).else { fail(at, "No such variant: " + name) }
            let newPatterns = patterns.map { self.resolvePattern(_) }
            PVariant(at, newName, newPatterns)
        | PVariantAs(at, name, variable) =>
            let newName = self.variants.get(name).else { fail(at, "No such variant: " + name) }
            PVariantAs(at, newName, variable)
        | PAlias(at, pattern, variable) =>
            let newPattern = self.resolvePattern(pattern)
            PAlias(at, newPattern, variable)
    }

}
