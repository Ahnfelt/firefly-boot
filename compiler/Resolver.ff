import Syntax

type Resolver(
    variables: Map[String, String]
    variants: Map[String, String]
    types: Map[String, String]
    asyncTypes: Set[String]
    typeParameters: Set[String]
    traits: Map[String, String]
    state: ResolverState
)

type ResolverState(mutable nextUnificationVariableIndex: Int)

make(): Resolver {
    Resolver(
        variables = [].toMap()
        variants = [].toMap()
        types = [].toMap()
        asyncTypes = [].toSet()
        typeParameters = [].toSet()
        traits = [].toMap()
        state = ResolverState(nextUnificationVariableIndex = 2) // To avoid collision with the parser and unification
    )
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

extend self: Resolver {

    freshUnificationVariable(at: Location): Type {
        let result = TVariable(at, self.state.nextUnificationVariableIndex)
        self.state.nextUnificationVariableIndex += 3
        result
    }

    resolveModule(module: Module, otherModules: List[Module]): Module {
        let moduleNamespace =
            module.file.replace("\\", "/").reverse().takeWhile { _ != '/' }.reverse().takeWhile { _ != '.' }
        let self2 = self.processImports(module.imports, otherModules)
        let self3 = self2.processDefinitions(module, None)
        module.Module(
            types = module.types.map { self3.resolveTypeDefinition(_) }
            traits = module.traits.map { self3.resolveTraitDefinition(_) }
            instances = module.instances.map { self3.resolveInstanceDefinition(_) }
            extends = module.extends.map { self3.resolveExtendDefinition(_) }
            lets = module.lets.map { self3.resolveLetDefinition(_, True) }
            functions = module.functions.map { self3.resolveFunctionDefinition(_, True) }
        )
    }

    processImports(imports: List[DImport], modules: List[Module]): Resolver {
        mutable resolver = self
        imports.each { import =>
            modules.find { _.file.dropLast(3) == import.file }.{
                | Some(module) =>
                    resolver = resolver.processDefinitions(module, Some(import.alias))
                | None =>
                    fail(import.at, "No such module: " + import.file)
            }
        }
        resolver
    }

    processDefinitions(module: Module, importAlias: Option[String]): Resolver {
        function entry(name: String, unqualified: Bool): List[Pair[String, String]] {
            let full =
                module.packagePair.groupName() + "/" +
                module.file.dropLast(3) + "." + name
            importAlias.{
                | None => [Pair(name, full), Pair(full, full)]
                | Some(alias) { unqualified } => [Pair(alias + "." + name, full), Pair(name, full), Pair(full, full)]
                | Some(alias) => [Pair(alias + "." + name, full), Pair(full, full)]
            }
        }
        let isCore = // TODO: Extend imports to list unqualified symbols instead of this
            module.packagePair.group == "ff" &&
            module.packagePair.name == "core" &&
            module.file == "Core.ff"
        let lets = module.lets.flatMap { entry(_.name, isCore) }.toMap()
        let functions = module.functions.flatMap { entry(_.signature.name, isCore) }.toMap()
        let traitMethods = module.traits.flatMap { _.methods }.flatMap { entry(_.name, False) }.toMap()
        let traits = module.traits.flatMap { entry(_.name, True) }.toMap()
        let types = module.types.flatMap { entry(_.name, True) }.toMap()
        let asyncTypes = module.types.filter { _.generics.first().any {_ == "Q$"} }
            .flatMap { entry(_.name, True).map {_.first} }.toSet()
        let variants = module.types.flatMap { _.variants }.flatMap { entry(_.name, True) }.toMap()
        Resolver(
            variables = self.variables.addAll(lets).addAll(functions).addAll(traitMethods)
            variants = self.variants.addAll(variants)
            types = self.types.addAll(types)
            asyncTypes = self.asyncTypes.addAll(asyncTypes)
            typeParameters = [].toSet()
            traits = self.traits.addAll(traits)
            state = self.state
        )
    }

    resolveTypeDefinition(definition: DType): DType {
        let generics = definition.generics.map { g => Pair(g, g) }.toMap()
        let self2 = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
        )
        if(!definition.generics.first().any {_ == "Q$"}) {
            [...definition.commonFields, ...definition.variants.flatMap {_.fields}].each { f =>
                if(self2.containsAsyncType(f.valueType)) {
                    fail(f.at, "Type '" + definition.name + "' has not been marked with '!', but is potentially async due to the type of the '" + f.name + "' field")
                }
            }
        }
        definition.DType(
            constraints = definition.constraints.map { self2.resolveConstraint(_, True) }
            commonFields = definition.commonFields.map { f =>
                f.Parameter(
                    valueType = self2.resolveType(f.valueType, True)
                    default = f.default.map { self2.resolveTerm(_, True) }
                )
            }
            variants = definition.variants.map { v =>
                v.Variant(fields = v.fields.map { f =>
                    f.Parameter(
                        valueType = self2.resolveType(f.valueType, True)
                        default = f.default.map { self2.resolveTerm(_, True) }
                    )
                })
            }
        )
    }

    resolveTraitDefinition(definition: DTrait): DTrait {
        let generics = definition.generics.map { g => Pair(g, g) }.toMap()
        let self2 = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
        )
        definition.DTrait(
            constraints = definition.constraints.map { self2.resolveConstraint(_, True) },
            methods = definition.methods.map { self2.resolveSignature(_, True) },
            methodDefaults = definition.methodDefaults.map {| Pair(name, lambda) =>
                let signature = definition.methods.find {_.name == name}.grab()
                let function1 = DFunction(signature.at, signature, FireflyTarget(lambda))
                let function2 = self2.resolveFunctionDefinition(function1, True)
                Pair(name, function2.body.{
                    | FireflyTarget(lambda) => lambda
                    | _ => fail(signature.at, "Internal error: Expected method default to be a lambda")
                })
            }
        )
    }

    resolveInstanceDefinition(definition: DInstance): DInstance {
        let generics = definition.generics.map { g => Pair(g, g) }.toMap()
        let self2 = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
        )
        let traitName = self2.traits.get(definition.traitName).else {
            fail(definition.at, "No such trait: " + definition.traitName)
        }
        definition.DInstance(
            constraints = definition.constraints.map { self2.resolveConstraint(_, True) }
            traitName = traitName
            typeArguments = definition.typeArguments.map { self2.resolveType(_, True) }
            methods = definition.methods.map { self2.resolveFunctionDefinition(_, True) }
        )
    }

    resolveExtendDefinition(definition: DExtend): DExtend {
        let generics = definition.generics.map { g => Pair(g, g) }.toMap()
        let selfWithNoQ = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
            variables = self.variables.add(definition.name, definition.name)
        )
        let selfWithQ = selfWithNoQ.Resolver(
            types = selfWithNoQ.types.add("Q$", "Q$")
            typeParameters = selfWithNoQ.typeParameters.add("Q$")
        )
        definition.DExtend(
            constraints = definition.constraints.map { selfWithQ.resolveConstraint(_, True) }
            type = selfWithQ.resolveType(definition.type, True)
            methods = definition.methods.map { selfWithNoQ.resolveFunctionDefinition(_, True) }
        )
    }

    resolveLetDefinition(definition: DLet, topLevel: Bool): DLet {
        let self2 = self.Resolver(variables = self.variables.add(definition.name, definition.name))
        definition.DLet(
            variableType = self.resolveType(definition.variableType, topLevel)
            value = self.resolveTerm(definition.value, True)
        )
    }

    resolveTerm(term: Term, topLevel: Bool): Term {
        | EString _, _ => term
        | EChar _, _ => term
        | EInt _, _ => term
        | EFloat _, _ => term
        | EVariable e, _ =>
            self.variables.get(e.name).map { e.EVariable(name = _) }.else {
                if(e.name.first().any { _.isAsciiLetter() }) {
                    fail(e.at, "No such variable: " + e.name)
                } else {
                    term
                }
            }
        | EList(at, t, items), _ =>
            EList(at, self.resolveType(t, topLevel), items.map { | Pair(item, spread) =>
                Pair(self.resolveTerm(item, topLevel), spread)
            })
        | EVariant(at, name, typeArguments, arguments), _ =>
            EVariant(
                at = at
                name = self.variants.get(name).else { fail(at, "No such variant: " + name) }
                typeArguments = typeArguments.map { self.resolveType(_, topLevel) }
                arguments = arguments.map { _.map { a => a.Argument(value = self.resolveTerm(a.value, topLevel)) }}
            )
        | EVariantIs(at, name, typeArguments), _ =>
            EVariantIs(
                at = at
                name = self.variants.get(name).else { fail(at, "No such variant: " + name) }
                typeArguments = typeArguments.map { self.resolveType(_, topLevel) }
            )
        | ECopy(at, name, record, arguments), _ =>
            ECopy(
                at = at
                name = self.variants.get(name).else { fail(at, "No such variant: " + name) }
                record = self.resolveTerm(record, topLevel)
                arguments = arguments.map { f => f.Field(value = self.resolveTerm(f.value, topLevel)) }
            )
        | EField e, _ =>
            e.EField(record = self.resolveTerm(e.record, topLevel))
        | ELambda(at, Lambda(lambdaAt, _, cases)), _ =>
            let effect = self.makeEffectArgument(lambdaAt, topLevel)
            ELambda(at, Lambda(lambdaAt, effect, cases.map { self.resolveCase(_, topLevel) }))
        | EPipe(at, value, effect, function), _ =>
            EPipe(
                at = at
                value = self.resolveTerm(value, topLevel)
                effect = self.resolveType(effect, topLevel)
                function = self.resolveTerm(function, topLevel)
            )
        | ECall(at, DynamicCall target, effect, typeArguments, arguments, dictionaries), _ =>
            ECall(
                at = at
                target = target.DynamicCall(function = self.resolveTerm(target.function, topLevel))
                effect = self.resolveType(effect, topLevel)
                typeArguments = typeArguments.map { self.resolveType(_, topLevel) }
                arguments = arguments.map { a => a.Argument(value = self.resolveTerm(a.value, topLevel)) }
                dictionaries = dictionaries
            )
        | ECall(at, StaticCall _, _, _, _, _), _ =>
            fail(at, "Internal error: Static calls not expected in the Resolver phase")
        | ERecord(at, fields), _ =>
            ERecord(
                at = at
                fields = fields.map { f => f.Field(value = self.resolveTerm(f.value, topLevel)) }
            )
        | EWildcard e, _ =>
            if(e.index == 0) { fail(e.at, "Unbound wildcard") }
            e.EWildcard()
        | EFunctions(at, functions, body), _ =>
            let functionMap = functions.map { _.signature.name }.map { name => Pair(name, name) }.toMap()
            let self2 = self.Resolver(variables = self.variables.addAll(functionMap))
            EFunctions(
                at = at,
                functions = functions.map { self2.resolveFunctionDefinition(_, topLevel) },
                body = self2.resolveTerm(body, topLevel)
            )
        | ELet e, _ =>
            let self2 = self.Resolver(variables = self.variables.add(e.name, e.name))
            e.ELet(
                valueType = self.resolveType(e.valueType, topLevel)
                value = self.resolveTerm(e.value, topLevel)
                body = self2.resolveTerm(e.body, topLevel)
            )
        | ESequential(at, before, after), _ =>
            ESequential(
                at = at
                before = self.resolveTerm(before, topLevel)
                after = self.resolveTerm(after, topLevel)
            )
        | EAssign(at, operator, variable, value), _ =>
            EAssign(
                at = at
                operator = operator
                variable = self.variables.get(variable).else { fail(at, "No such variable: " + variable) }
                value = self.resolveTerm(value, topLevel)
            )
        | EAssignField(at, operator, record, field, value), _ =>
            EAssignField(
                at = at
                operator = operator
                record = self.resolveTerm(record, topLevel)
                field = field
                value = self.resolveTerm(value, topLevel)
            )
    }

    resolveType(type: Type, topLevel: Bool): Type {
        | TVariable _, _ =>
            type
        | TConstructor constructor, _ =>
            let name = if(constructor.name.contains("$")) {
                constructor.name
            } else {
                self.types.get(constructor.name).else { fail(constructor.at, "No such type: " + constructor.name) }
            }
            let isFunctionType = name.startsWith("Function$")
            let effect = if(isFunctionType || self.asyncTypes.contains(constructor.name)) {
                [self.makeEffectArgument(constructor.at, topLevel)]
            } else {[]}
            let generics = constructor.generics.map { self.resolveType(_, topLevel) }
            if(isFunctionType) {
                let arguments = generics.dropLast()
                let returnType = generics.grabLast()
                constructor.TConstructor(
                    name = name
                    generics = [...effect, ...arguments, returnType]
                )
            } else {
                constructor.TConstructor(
                    name = name
                    generics = [...effect, ...generics]
                )
            }
    }

    makeEffectArgument(at: Location, topLevel: Bool): Type {
        if(topLevel) {
            if(!self.typeParameters.contains("Q$")) {
                TConstructor(at, "ff:core/Nothing.Nothing", []) // Temporary workaround for top-level let
            } else {
                TConstructor(at, "Q$", [])
            }
        } else {
            self.freshUnificationVariable(at)
        }
    }

    resolveConstraint(constraint: Constraint, topLevel: Bool): Constraint {
        let name =
            self.traits.get(constraint.name).else { fail(constraint.at, "No such trait: " + constraint.name) }
        constraint.Constraint(
            name = name
            generics = constraint.generics.map { self.resolveType(_, topLevel) }
        )
    }

    resolveFunctionDefinition(definition: DFunction, topLevel: Bool): DFunction {
        let signature = self.resolveSignature(definition.signature, topLevel)
        let self2 = self.withSignature(signature)
        let body = definition.body.mapFirefly { lambda => lambda.Lambda(
            effect = signature.effect
            cases = lambda.cases.map { self2.resolveCase(_, False) }
        )}
        DFunction(definition.at, signature, body)
    }

    resolveSignature(signature: Signature, topLevel: Bool): Signature {
        let newSignature = if(topLevel) {
            signature.Signature(
                generics = ["Q$", ...signature.generics]
                effect = TConstructor(signature.at, "Q$", [])
            )
        } else {
            signature.Signature(
                effect = self.freshUnificationVariable(signature.at)
            )
        }
        newSignature.generics.find { name => self.typeParameters.contains(name) }.each { name =>
            fail(signature.at, "Type parameter " + name + " is already in scope")
        }
        let self2 = self.withSignature(newSignature)
        newSignature.Signature(
            constraints = newSignature.constraints.map { self2.resolveConstraint(_, topLevel) }
            parameters = newSignature.parameters.map { p =>
                p.Parameter(
                    valueType = self2.resolveType(p.valueType, topLevel)
                    default = p.default.map { self2.resolveTerm(_, topLevel) }
                )
            }
            returnType = self2.resolveType(newSignature.returnType, topLevel)
        )
    }

    withSignature(signature: Signature): Resolver {
        let variableMap = signature.parameters.map { _.name }.map { name => Pair(name, name) }.toMap()
        let typeMap = signature.generics.map { name => Pair(name, name) }.toMap()
        self.Resolver(
            variables = self.variables.addAll(variableMap)
            typeParameters = self.typeParameters.addAll(signature.generics.toSet())
            types = self.types.addAll(typeMap)
            asyncTypes = self.asyncTypes.removeAll(signature.generics.toSet())
        )
    }

    resolveCase(case: MatchCase, topLevel: Bool): MatchCase {
        function findVariables(pattern: MatchPattern): Map[String, String] {
            | PString _ =>
                Map.empty()
            | PInt _ =>
                Map.empty()
            | PChar _ =>
                Map.empty()
            | PVariable(_, Some(name)) =>
                [Pair(name, name)].toMap()
            | PVariable(_, None) =>
                Map.empty()
            | PVariant(_, _, patterns) =>
                patterns.map(findVariables).foldLeft(Map.empty[String, String]()) {_.addAll(_)}
            | PVariantAs(_, _, variable) =>
                variable.toList().map { x => Pair(x, x) }.toMap()
            | PAlias(_, pattern, variable) =>
                [Pair(variable, variable)].toMap().addAll(findVariables(pattern))
        }
        let variableMap = case.patterns.map(findVariables).foldLeft(Map.empty[String, String]()) {_.addAll(_)}
        mutable guards = []
        let variableMap2 = case.guards.foldLeft(variableMap) { variableMap1, g =>
            let self2 = self.Resolver(variables = self.variables.addAll(variableMap1))
            let guard = g.MatchGuard(
                term = self2.resolveTerm(g.term, topLevel)
                pattern = self2.resolvePattern(g.pattern)
            )
            guards = [guard, ...guards]
            variableMap1.addAll(findVariables(guard.pattern))
        }
        let self3 = self.Resolver(variables = self.variables.addAll(variableMap2))
        MatchCase(
            at = case.at
            patterns = case.patterns.map { self.resolvePattern(_) }
            guards = guards.reverse()
            body = self3.resolveTerm(case.body, topLevel)
        )
    }

    resolvePattern(pattern: MatchPattern): MatchPattern {
        | PString _ =>
            pattern
        | PInt _ =>
            pattern
        | PChar _ =>
            pattern
        | PVariable _ =>
            pattern
        | PVariant(at, name, patterns) =>
            let newName = self.variants.get(name).else { fail(at, "No such variant: " + name) }
            let newPatterns = patterns.map { self.resolvePattern(_) }
            PVariant(at, newName, newPatterns)
        | PVariantAs(at, name, variable) =>
            let newName = self.variants.get(name).else { fail(at, "No such variant: " + name) }
            PVariantAs(at, newName, variable)
        | PAlias(at, pattern, variable) =>
            let newPattern = self.resolvePattern(pattern)
            PAlias(at, newPattern, variable)
    }

    containsAsyncType(type: Type): Bool {
        | TVariable _ =>
            False
        | TConstructor constructor =>
            let name = if(constructor.name.contains("$")) {
                constructor.name
            } else {
                self.types.get(constructor.name).else { fail(constructor.at, "No such type: " + constructor.name) }
            }
            let isFunctionType = name.startsWith("Function$")
            isFunctionType || self.asyncTypes.contains(constructor.name) ||
            constructor.generics.any(self.containsAsyncType)
    }

}
