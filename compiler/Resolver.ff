import Syntax

class Resolver(
    variables: Map[String, String]
    variableLocations: Map[String, Location]
    variants: Map[String, String]
    types: Map[String, String]
    typeLocations: Map[String, Location]
    asyncTypes: Set[String]
    typeParameters: Set[String]
    traits: Map[String, String]
    traitLocations: Map[String, Location]
    state: ResolverState
    hoverAt: Option[Location]
    referencesTo: Option[Location]
)

class ResolverState(
    mutable nextUnificationVariableIndex: Int
    mutable hoverResult: HoverInfo
    mutable referencesResult: List[Location]
)

make(hoverAt: Option[Location], referencesTo: Option[Location]): Resolver {
    Resolver(
        variables = [].toMap()
        variableLocations = [].toMap()
        variants = [].toMap()
        types = [].toMap()
        typeLocations = [].toMap()
        asyncTypes = [].toSet()
        typeParameters = [].toSet()
        traits = [].toMap()
        traitLocations = [].toMap()
        state = ResolverState(
            nextUnificationVariableIndex = 2
            hoverResult = HoverInfo(None, None, None)
            referencesResult = []
        ) // To avoid collision with the parser and unification
        hoverAt = hoverAt
        referencesTo = referencesTo
    )
}

extend self: Resolver {

    freshUnificationVariable(at: Location): Type {
        let result = TVariable(at, self.state.nextUnificationVariableIndex)
        self.state.nextUnificationVariableIndex += 3
        result
    }

    resolveModule(module: Module, otherModules: List[Module]): Module {
        let moduleNamespace =
            module.file.replace("\\", "/").reverse().takeWhile { _ != '/' }.reverse().takeWhile { _ != '.' }
        let self2 = self.processImports(module.imports, otherModules)
        let self3 = self2.processDefinitions(module, None)
        let module2 = module.Module(
            types = module.types.map { self3.resolveTypeDefinition(_) }
            traits = module.traits.map { self3.resolveTraitDefinition(_) }
            instances = module.instances.map { self3.resolveInstanceDefinition(_) }
            extends = module.extends.map { self3.resolveExtendDefinition(_) }
            lets = module.lets.map { self3.resolveLetDefinition(_, True) }
            functions = module.functions.map { self3.resolveFunctionDefinition(_, True) }
        )
        module2.instances.each {_.typeArguments.each {self3.checkInstanceType(_)}}
        module2
    }

    checkInstanceType(type: Type) {
        type.{
            | TConstructor(_, name, typeArguments) =>
                if(self.asyncTypes.contains(name)) {
                    throw(CompileError(type.at, "Traits must not be instantiated for capability types"))
                }
                typeArguments.each {self.checkInstanceType(_)}
            | _ =>
        }
    }

    processImports(imports: List[DImport], modules: List[Module]): Resolver {
        mutable resolver = self
        imports.each { import =>
            modules.find { _.file.dropLast(3) == import.file }.{
                | Some(module) =>
                    resolver = resolver.processDefinitions(module, Some(import.alias))
                | None =>
                    throw(CompileError(import.at, "No such module: " + import.file))
            }
        }
        resolver
    }

    processDefinitions(module: Module, importAlias: Option[String]): Resolver {
        function entry(name: String, unqualified: Bool): List[Pair[String, String]] {
            let full =
                module.packagePair.groupName() + "/" +
                module.file.dropLast(3) + "." + name
            importAlias.{
                | None => [Pair(name, full), Pair(full, full)]
                | Some(alias) { unqualified } => [Pair(alias + "." + name, full), Pair(name, full), Pair(full, full)]
                | Some(alias) => [Pair(alias + "." + name, full), Pair(full, full)]
            }
        }
        let isCore = // TODO: Extend imports to list unqualified symbols instead of this
            module.packagePair.group == "ff" &&
            module.packagePair.name == "core" &&
            module.file == "Core.ff"
        let lets = module.lets.flatMap { entry(_.name, isCore) }.toMap()
        let functions = module.functions.flatMap { entry(_.signature.name, isCore) }.toMap()
        let traitMethods = module.traits.flatMap { _.methods }.flatMap { entry(_.name, False) }.toMap()
        let traits = module.traits.flatMap { entry(_.name, True) }.toMap()
        let traitLocations = module.traits.flatMap {d => entry(d.name, True).map {_.mapSecond {_ => d.at}} }.toMap()
        let types = module.types.flatMap { entry(_.name, True) }.toMap()
        let typeLocations = module.types.flatMap {d => entry(d.name, True).map {_.mapSecond {_ => d.at}} }.toMap()
        let asyncTypes = module.types.filter { _.generics.first().any {_ == "Q$"} }
            .flatMap { entry(_.name, True).map {_.first} }.toSet()
        let variants = module.types.flatMap { _.variants }.flatMap { entry(_.name, True) }.toMap()
        self.Resolver(
            variables = self.variables.addAll(lets).addAll(functions).addAll(traitMethods)
            variants = self.variants.addAll(variants)
            types = self.types.addAll(types)
            typeLocations = self.typeLocations.addAll(typeLocations)
            asyncTypes = self.asyncTypes.addAll(asyncTypes)
            typeParameters = [].toSet()
            traits = self.traits.addAll(traits)
            traitLocations = self.traitLocations.addAll(traitLocations)
            state = self.state
        )
    }

    resolveTypeDefinition(definition: DType): DType {
        if(self.hoverAt.contains(definition.at)) {
            self.state.hoverResult = self.state.hoverResult.HoverInfo(at = Some(definition.at))
        }
        if(self.referencesTo.contains(definition.at)) {
            self.state.referencesResult = [...self.state.referencesResult, definition.at]
        }
        let generics = definition.generics.map {g => Pair(g, g)}.toMap()
        let self2 = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
        )
        if(!definition.generics.first().any {_ == "Q$"}) {
            [...definition.commonFields, ...definition.variants.flatMap {_.fields}].each {f =>
                if(self2.containsAsyncType(f.valueType)) {
                    throw(CompileError(f.at, "Only capabilities can contain fields of concrete capability types"))
                }
            }
        }
        definition.DType(
            constraints = definition.constraints.map {self2.resolveConstraint(_, True)}
            commonFields = definition.commonFields.map {f =>
                f.Parameter(
                    valueType = self2.resolveType(f.valueType, True)
                    default = f.default.map {self2.resolveTerm(_, True)}
                )
            }
            variants = definition.variants.map {v =>
                v.Variant(fields = v.fields.map {f =>
                    f.Parameter(
                        valueType = self2.resolveType(f.valueType, True)
                        default = f.default.map {self2.resolveTerm(_, True) }
                    )
                })
            }
        )
    }

    resolveTraitDefinition(definition: DTrait): DTrait {
        let generics = definition.generics.map {g => Pair(g, g)}.toMap()
        let self2 = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
        )
        definition.DTrait(
            constraints = definition.constraints.map {self2.resolveConstraint(_, True)}
            methods = definition.methods.map {self2.resolveSignature(_, True)}
            methodDefaults = definition.methodDefaults.map {| Pair(name, lambda) =>
                let signature = definition.methods.find {_.name == name}.grab()
                let function1 = DFunction(signature.at, signature, FireflyTarget(lambda))
                let function2 = self2.resolveFunctionDefinition(function1, True)
                Pair(name, function2.body.{
                    | FireflyTarget(lambda) => lambda
                    | _ => throw(CompileError(signature.at, "Internal error: Expected method default to be a lambda"))
                })
            }
        )
    }

    resolveInstanceDefinition(definition: DInstance): DInstance {
        let generics = definition.generics.map { g => Pair(g, g) }.toMap()
        let self2 = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
        )
        let traitName = self2.traits.get(definition.traitName).else {
            throw(CompileError(definition.at, "No such trait: " + definition.traitName))
        }
        definition.DInstance(
            constraints = definition.constraints.map { self2.resolveConstraint(_, True) }
            traitName = traitName
            typeArguments = definition.typeArguments.map { self2.resolveType(_, True) }
            methods = definition.methods.map { self2.resolveFunctionDefinition(_, True) }
        )
    }

    resolveExtendDefinition(definition: DExtend): DExtend {
        let generics = definition.generics.map {g => Pair(g, g)}.toMap()
        let selfWithNoQ = self.Resolver(
            types = self.types.addAll(generics)
            asyncTypes = self.asyncTypes.removeAll(definition.generics.toSet())
            typeParameters = self.typeParameters.addAll(definition.generics.toSet())
            variables = self.variables.add(definition.name, definition.name)
            variableLocations = self.variableLocations.add(definition.name, definition.at)
        )
        let selfWithQ = selfWithNoQ.Resolver(
            types = selfWithNoQ.types.add("Q$", "Q$")
            typeParameters = selfWithNoQ.typeParameters.add("Q$")
        )
        definition.DExtend(
            constraints = definition.constraints.map {selfWithQ.resolveConstraint(_, True)}
            type = selfWithQ.resolveType(definition.type, True)
            methods = definition.methods.map {selfWithNoQ.resolveFunctionDefinition(_, True)}
        )
    }

    resolveLetDefinition(definition: DLet, topLevel: Bool): DLet {
        let self2 = self.Resolver(
            variables = self.variables.add(definition.name, definition.name)
            variableLocations = self.variableLocations.add(definition.name, definition.at)
        )
        definition.DLet(
            variableType = self.resolveType(definition.variableType, topLevel)
            value = self.resolveTerm(definition.value, True)
        )
    }

    resolveTerm(term: Term, topLevel: Bool): Term {
        | EString _, _ => term
        | EChar _, _ => term
        | EInt _, _ => term
        | EFloat _, _ => term
        | EVariable e, _ =>
            let at = self.variableLocations.get(e.name)
            if(self.hoverAt.contains(e.at)) {
                at.each {at =>
                    self.state.hoverResult = self.state.hoverResult.HoverInfo(at = Some(at))
                }
            }
            if(at.any {self.referencesTo.contains(_)}) {
                self.state.referencesResult = [...self.state.referencesResult, e.at]
            }
            self.variables.get(e.name).map {e.EVariable(name = _)}.else {term}
        | EList(at, t, items), _ =>
            EList(at, self.resolveType(t, topLevel), items.map {| Pair(item, spread) =>
                Pair(self.resolveTerm(item, topLevel), spread)
            })
        | EVariant(at, name, typeArguments, arguments), _ =>
            EVariant(
                at = at
                name = self.variants.get(name).else {name}
                typeArguments = typeArguments.map {self.resolveType(_, topLevel)}
                arguments = arguments.map {_.map {a => a.Argument(value = self.resolveTerm(a.value, topLevel))}}
            )
        | EVariantIs(at, name, typeArguments), _ =>
            EVariantIs(
                at = at
                name = self.variants.get(name).else { throw(CompileError(at, "No such variant: " + name)) }
                typeArguments = typeArguments.map { self.resolveType(_, topLevel) }
            )
        | ECopy(at, name, record, arguments), _ =>
            ECopy(
                at = at
                name = self.variants.get(name).else { throw(CompileError(at, "No such variant: " + name)) }
                record = self.resolveTerm(record, topLevel)
                arguments = arguments.map { f => f.Field(value = self.resolveTerm(f.value, topLevel)) }
            )
        | EField e, _ =>
            e.EField(record = self.resolveTerm(e.record, topLevel))
        | ELambda(at, Lambda(lambdaAt, _, cases)), _ =>
            let effect = self.makeEffectArgument(lambdaAt, topLevel)
            ELambda(at, Lambda(lambdaAt, effect, cases.map { self.resolveCase(_, topLevel) }))
        | EPipe(at, value, effect, function), _ =>
            EPipe(
                at = at
                value = self.resolveTerm(value, topLevel)
                effect = self.resolveType(effect, topLevel)
                function = self.resolveTerm(function, topLevel)
            )
        | ECall(at, DynamicCall target, effect, typeArguments, arguments, dictionaries), _ =>
            ECall(
                at = at
                target = target.DynamicCall(function = self.resolveTerm(target.function, topLevel))
                effect = self.resolveType(effect, topLevel)
                typeArguments = typeArguments.map {self.resolveType(_, topLevel)}
                arguments = arguments.map {a => a.Argument(value = self.resolveTerm(a.value, topLevel))}
                dictionaries = dictionaries
            )
        | ECall(at, StaticCall _, _, _, _, _), _ =>
            throw(CompileError(at, "Internal error: Static calls not expected in the Resolver phase"))
        | ERecord(at, fields), _ =>
            ERecord(
                at = at
                fields = fields.map {f => f.Field(value = self.resolveTerm(f.value, topLevel))}
            )
        | EWildcard e, _ =>
            if(e.index == 0) {throw(CompileError(e.at, "Unbound wildcard"))}
            e.EWildcard()
        | EFunctions(at, functions, body), _ =>
            let functionMap = functions.map {_.signature.name}.map {name => Pair(name, name)}.toMap()
            let self2 = self.Resolver(variables = self.variables.addAll(functionMap))
            EFunctions(
                at = at
                functions = functions.map {self2.resolveFunctionDefinition(_, topLevel)}
                body = self2.resolveTerm(body, topLevel)
            )
        | ELet e, _ =>
            let self2 = self.Resolver(
                variables = self.variables.add(e.name, e.name)
                variableLocations = self.variableLocations.add(e.name, e.at)
            )
            e.ELet(
                valueType = self.resolveType(e.valueType, topLevel)
                value = self.resolveTerm(e.value, topLevel)
                body = self2.resolveTerm(e.body, topLevel)
            )
        | ESequential(at, before, after), _ =>
            ESequential(
                at = at
                before = self.resolveTerm(before, topLevel)
                after = self.resolveTerm(after, topLevel)
            )
        | EAssign(at, operator, variable, value), _ =>
            if(self.referencesTo.any {r => self.variableLocations.get(variable).any {r == _}}) {
                self.state.referencesResult = [...self.state.referencesResult, at]
            }
            EAssign(
                at = at
                operator = operator
                variable = self.variables.get(variable).else {
                    throw(CompileError(at, "No such variable: " + variable))
                }
                value = self.resolveTerm(value, topLevel)
            )
        | EAssignField(at, operator, record, field, value), _ =>
            EAssignField(
                at = at
                operator = operator
                record = self.resolveTerm(record, topLevel)
                field = field
                value = self.resolveTerm(value, topLevel)
            )
    }

    resolveType(type: Type, topLevel: Bool): Type {
        | TVariable _, _ =>
            type
        | TConstructor constructor, _ =>
            self.typeLocations.get(constructor.name).each {at =>
                if(self.hoverAt.contains(type.at)) {
                    self.state.hoverResult = self.state.hoverResult.HoverInfo(at = Some(at))
                }
                if(self.referencesTo.contains(at)) {
                    self.state.referencesResult = [...self.state.referencesResult, constructor.at]
                }
            }
            let name = if(constructor.name.contains("$")) {
                constructor.name
            } else {
                self.types.get(constructor.name).else {
                    throw(CompileError(constructor.at, "No such type: " + constructor.name))
                }
            }
            let isFunctionType = name.startsWith("Function$")
            let effect = if(isFunctionType || self.asyncTypes.contains(constructor.name)) {
                [self.makeEffectArgument(constructor.at, topLevel)]
            } else {[]}
            let generics = constructor.generics.map {self.resolveType(_, topLevel)}
            if(isFunctionType) {
                let arguments = generics.dropLast()
                let returnType = generics.grabLast()
                constructor.TConstructor(
                    name = name
                    generics = [...effect, ...arguments, returnType]
                )
            } else {
                constructor.TConstructor(
                    name = name
                    generics = [...effect, ...generics]
                )
            }
    }

    makeEffectArgument(at: Location, topLevel: Bool): Type {
        if(topLevel) {
            if(!self.typeParameters.contains("Q$")) {
                TConstructor(at, "ff:core/Nothing.Nothing", []) // Temporary workaround for top-level let
            } else {
                TConstructor(at, "Q$", [])
            }
        } else {
            self.freshUnificationVariable(at)
        }
    }

    resolveConstraint(constraint: Constraint, topLevel: Bool): Constraint {
        self.traitLocations.get(constraint.name).each {at =>
            if(self.hoverAt.contains(constraint.at)) {
                self.state.hoverResult = self.state.hoverResult.HoverInfo(at = Some(at))
            }
            if(self.referencesTo.contains(at)) {
                self.state.referencesResult = [...self.state.referencesResult, at]
            }            
        }
        let name =
            self.traits.get(constraint.name).else {
                throw(CompileError(constraint.at, "No such trait: " + constraint.name))
            }
        constraint.Constraint(
            name = name
            generics = constraint.generics.map {self.resolveType(_, topLevel)}
        )
    }

    resolveFunctionDefinition(definition: DFunction, topLevel: Bool): DFunction {
        let signature = self.resolveSignature(definition.signature, topLevel)
        let self2 = self.withSignature(signature)
        let body = definition.body.mapFirefly {lambda => lambda.Lambda(
            effect = signature.effect
            cases = lambda.cases.map {self2.resolveCase(_, False)}
        )}
        DFunction(definition.at, signature, body)
    }

    resolveSignature(signature: Signature, topLevel: Bool): Signature {
        let newSignature = if(topLevel) {
            signature.Signature(
                generics = ["Q$", ...signature.generics]
                effect = TConstructor(signature.at, "Q$", [])
            )
        } else {
            signature.Signature(
                effect = self.freshUnificationVariable(signature.at)
            )
        }
        newSignature.generics.find {name => self.typeParameters.contains(name)}.each {name =>
            throw(CompileError(signature.at, "Type parameter " + name + " is already in scope"))
        }
        let self2 = self.withSignature(newSignature)
        newSignature.Signature(
            constraints = newSignature.constraints.map {self2.resolveConstraint(_, topLevel)}
            parameters = newSignature.parameters.map {p =>
                p.Parameter(
                    valueType = self2.resolveType(p.valueType, topLevel)
                    default = p.default.map {self2.resolveTerm(_, topLevel)}
                )
            }
            returnType = self2.resolveType(newSignature.returnType, topLevel)
        )
    }

    withSignature(signature: Signature): Resolver {
        let variableMap = signature.parameters.map {_.name}.map {name => Pair(name, name)}.toMap()
        let variableLocationMap = signature.parameters.map {p => Pair(p.name, p.at)}.toMap()
        let typeMap = signature.generics.map {name => Pair(name, name)}.toMap()
        self.Resolver(
            variables = self.variables.addAll(variableMap)
            variableLocations = self.variableLocations.addAll(variableLocationMap)
            typeParameters = self.typeParameters.addAll(signature.generics.toSet())
            types = self.types.addAll(typeMap)
            asyncTypes = self.asyncTypes.removeAll(signature.generics.toSet())
        )
    }

    resolveCase(case: MatchCase, topLevel: Bool): MatchCase {
        function findVariables(pattern: MatchPattern): Map[String, Pair[Location, String]] {
            | PString _ =>
                Map.empty()
            | PInt _ =>
                Map.empty()
            | PChar _ =>
                Map.empty()
            | PVariable(at, Some(name)) =>
                [Pair(name, Pair(at, name))].toMap()
            | PVariable(_, None) =>
                Map.empty()
            | PVariant(_, _, patterns) =>
                patterns.map(findVariables).foldLeft(Map.empty()) {_.addAll(_)}
            | PVariantAs(at, _, variable) =>
                variable.toList().map {x => Pair(x, Pair(at, x))}.toMap()
            | PAlias(at, pattern, variable) =>
                [Pair(variable, Pair(at, variable))].toMap().addAll(findVariables(pattern))
        }
        let variableMap = case.patterns.map(findVariables).foldLeft(Map.empty()) {_.addAll(_)}
        mutable guards = []
        let variableMap2 = case.guards.foldLeft(variableMap) {variableMap1, g =>
            let self2 = self.Resolver(
                variables = self.variables.addAll(variableMap1.mapValues {_, p => p.second})
                variableLocations = self.variableLocations.addAll(variableMap1.mapValues {_, p => p.first})
            )
            let guard = g.MatchGuard(
                term = self2.resolveTerm(g.term, topLevel)
                pattern = self2.resolvePattern(g.pattern)
            )
            guards = [guard, ...guards]
            variableMap1.addAll(findVariables(guard.pattern))
        }
        let self3 = self.Resolver(
            variables = self.variables.addAll(variableMap2.mapValues {_, p => p.second})
            variableLocations = self.variableLocations.addAll(variableMap2.mapValues {_, p => p.first})
        )
        MatchCase(
            at = case.at
            patterns = case.patterns.map {self.resolvePattern(_)}
            guards = guards.reverse()
            body = self3.resolveTerm(case.body, topLevel)
        )
    }

    resolvePattern(pattern: MatchPattern): MatchPattern {
        | PString _ =>
            pattern
        | PInt _ =>
            pattern
        | PChar _ =>
            pattern
        | PVariable _ =>
            pattern
        | PVariant(at, name, patterns) =>
            let newName = self.variants.get(name).else {throw(CompileError(at, "No such variant: " + name))}
            let newPatterns = patterns.map {self.resolvePattern(_)}
            PVariant(at, newName, newPatterns)
        | PVariantAs(at, name, variable) =>
            let newName = self.variants.get(name).else {throw(CompileError(at, "No such variant: " + name))}
            PVariantAs(at, newName, variable)
        | PAlias(at, pattern, variable) =>
            let newPattern = self.resolvePattern(pattern)
            PAlias(at, newPattern, variable)
    }

    containsAsyncType(type: Type): Bool {
        | TVariable _ =>
            False
        | TConstructor constructor =>
            let name = if(constructor.name.contains("$")) {
                constructor.name
            } else {
                self.types.get(constructor.name).else {
                    throw(CompileError(constructor.at, "No such type: " + constructor.name))
                }
            }
            let isFunctionType = name.startsWith("Function$")
            isFunctionType || self.asyncTypes.contains(constructor.name) ||
            constructor.generics.any {self.containsAsyncType(_)}
    }

}
