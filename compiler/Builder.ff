import Tokenizer
import Parser
import Syntax
import Resolver
import Compiler
import Unification
import Dependencies
import JsEmitter
import LspHook

build(
    system: NodeSystem
    emitTarget: EmitTarget
    mainPackage: PackagePair
    mainModule: String
    resolvedDependencies: ResolvedDependencies
    compilerModulePath: Option[String]
    tempPath: String
    jsOutputPath: String
    printMeasurements: Bool
): Unit {

    let fs = system.files()

    if(fs.exists(tempPath)) {fs.deleteDirectory(tempPath)}
    fs.createDirectory(tempPath)

    let jsPathFile = tempPath + "/js"
    fs.createDirectories(jsPathFile)

    let success = do {
        let compiler = Compiler.make(
            emitTarget
            fs
            system.time()
            compilerModulePath
            jsPathFile
            resolvedDependencies
            Map.empty()
            lspHook = LspHook.disabled()
        )
        compiler.emit(mainPackage, mainModule, isMainModule = True)
        if(printMeasurements) {compiler.printMeasurements()}
        resolvedDependencies.packagePaths.each {packagePair, packagePath =>
            resolvedDependencies.packages.get(packagePair).each {packageInfo =>
                processIncludes(fs, jsPathFile, packagePath, packageInfo)
            }
        }
        True
    }

    if(success) {
        if(fs.exists(jsOutputPath)) {fs.deleteDirectory(jsOutputPath)}
        fs.rename(jsPathFile, jsOutputPath)
    }

}

processIncludes(fs: FileSystem, jsPathFile: String, packagePath: String, info: PackageInfo): Unit {
    info.includes.each {include =>
        fs.copy(
            packagePath + "/.firefly/include/" + include.path
            jsPathFile + "/" + info.package.packagePair.groupName("/") + "/" + include.path
        )
    }
}

buildViaBuildSystem(system: NodeSystem, fireflyPath: String, mainFile: String, target: String) {
    let resolvedDependencies = Dependencies.process(system.files(), system.httpClient(), mainFile)
    let fixedPackagePaths = if(resolvedDependencies.packagePaths.contains(PackagePair("ff", "core"))) {
        resolvedDependencies.packagePaths
    } else {
        resolvedDependencies.packagePaths.add(PackagePair("ff", "core"), fireflyPath + "/core")
    }
    if(target != "browser") {
        panic("buildViaBuildSystem is currently limited to browser target only - the restriction can be lifted")
    }
    build(
        system = system
        emitTarget = EmitBrowser
        mainPackage = resolvedDependencies.mainPackagePair
        mainModule = mainFile.dropLast(".ff".size())
        resolvedDependencies = resolvedDependencies.ResolvedDependencies(packagePaths = fixedPackagePaths)
        compilerModulePath = None
        tempPath = ".firefly/temporary"
        jsOutputPath = ".firefly/output/" + target
        printMeasurements = False
    )
}

check(
    system: NodeSystem, 
    fireflyPath: String, 
    path: String, 
    virtualFiles: Map[String, String], 
    lspHook: LspHook
    infer: Bool
) {
    let fs = system.files()
    let packages = fs.isDirectory(path).{
        | True => findPackageFiles(fs, path)
        | False => [PackageFiles(FileSystem.directoryName(path), None, [path])] // TODO
    }

    packages.each {package => 
        let firstFile = package.files.grabFirst()
        let resolvedDependencies = Dependencies.process(system.files(), system.httpClient(), firstFile)
        let fixedPackagePaths = if(resolvedDependencies.packagePaths.contains(PackagePair("ff", "core"))) {
            resolvedDependencies.packagePaths
        } else {
            resolvedDependencies.packagePaths.add(PackagePair("ff", "core"), fireflyPath + "/core")
        }
        let fixedResolvedDependencies = resolvedDependencies.ResolvedDependencies(packagePaths = fixedPackagePaths)
        let compiler = Compiler.make(
            EmitBuild
            system.files()
            system.time() 
            None
            ".firefly/temporary"
            fixedResolvedDependencies
            virtualFiles
            lspHook
        )
        package.files.each {file =>
            let localFile = FileSystem.baseName(file.replace("\\", "/"))
            if(infer) {
                compiler.infer(resolvedDependencies.mainPackagePair, localFile.dropLast(".ff".size()))
            } else {
                compiler.resolve(resolvedDependencies.mainPackagePair, localFile.dropLast(".ff".size()))
            }
        }
    }

}

data PackageFiles(
    root: String
    packageFile: Option[String]
    files: List[String]
)


findPackageFiles(fs: FileSystem, rootUri: String): List[PackageFiles] {
    let files = findFireflyFiles(fs, rootUri)
    let split = files.partition {_.endsWith(".firefly/package.ff")}
    let packageFiles = split.first
    mutable codeFiles = split.second
    let multiFileProjects = packageFiles.map {packageFile => 
        let projectRoot = packageFile.removeLast(".firefly/package.ff").grab()
        let files = codeFiles.filter {_.startsWith(projectRoot) }
        let filesSet = files.toSet()
        codeFiles = codeFiles.filter {file => !filesSet.contains(file)}
        PackageFiles(
            FileSystem.relative(fs.workingDirectory(), projectRoot), 
            Some(FileSystem.relative(fs.workingDirectory(), packageFile)), 
            files.map {FileSystem.relative(fs.workingDirectory(), _)}
        )
    }
    let singleFileProjects = codeFiles.map {file => 
        let projectRoot = file.reverse().dropWhile {_ != '/'}.reverse()
        PackageFiles(
            FileSystem.relative(fs.workingDirectory(), projectRoot), 
            None, 
            [FileSystem.relative(fs.workingDirectory(), file)]
        )
    }
    let unfixedProjects = [...multiFileProjects, ...singleFileProjects]
    unfixedProjects.map {project => PackageFiles(
        root = project.root.replace("\\", "/")
        packageFile = project.packageFile.map {_.replace("\\", "/")}
        files = project.files.map {_.replace("\\", "/")}
    )}
}

findFireflyFiles(fs: FileSystem, rootUri: String): List[String] {
    let split = fs.list(rootUri).partition {fs.isDirectory(_)}
    let directories = split.first
    let fireflyFiles = split.second.filter {_.endsWith(".ff")}
    let fixedFiles = fireflyFiles.map {_.replace("\\", "/")}
    [...fixedFiles, ...directories.flatMap {findFireflyFiles(fs, _)}]
}

internalCreateExecutable(
    self: BuildSystem
    mainJsFile: String = ".firefly/output/executable/Main.bundle.js"
    outputPath: String = ".firefly/output"
    targets: List[String] = ["host"]
    assets: AssetSystem = AssetSystem.create()
): Unit
    target node {
        let fs = internalFileSystem(self)
        let assetOutputPath = outputPath + "/assets"
        assets.files.pairs().each {| Pair(path, makeStream) =>
            let p = assetOutputPath + path
            fs.createDirectories(p.reverse().dropWhile {_ != '/'}.reverse())
            fs.writeStream(p, makeStream())
        }
        let json = """{
            "name": "main",
            "bin": {
                "firefly-main": "Main.bundle.js"
            },
            "devDependencies": {
                "pkg": "^5.8.0"
            },
            "pkg": {
                "scripts": "Main.bundle.js",
                "outputPath": "bin",
                "assets": ["../assets/**/*"],
                "targets": [
                    "node18-linux-x64",
                    "node18-macos-x64",
                    "node18-win-x64"
                ]
            }
        }"""
        let packageFile = outputPath + "/executable/package.json"
        fs.writeText(packageFile, json)
        internalCallPkg(self, packageFile, outputPath, targets)
    }

internalCallPkg(
    self: BuildSystem,
    packageFile: String,
    outputPath: String,
    targets: List[String]
): Unit
    target node async """
        import * as pkg from 'pkg'
        return await pkg.exec([
            packageFile_,
            '--out-path', outputPath_,
            '--target', ff_core_List.List_toArray(targets_).join(',')
        ])
    """

internalFileSystem(dummy: BuildSystem): FileSystem
    target node async """
        return null;
    """
