import Syntax
import Tokenizer
import Parser
import Resolver
import Inference
import ScalaEmitter
import JsEmitter

type Compiler(
    files: FileSystem
    scalaOutputPath: String
    jsOutputPath: String
    packagePaths: Map[String, String]
    mutable parsedModules: Map[String, Module]
    mutable resolvedModules: Map[String, Module]
    mutable inferredModules: Map[String, Module]
    mutable emittedModules: Set[String]
)

make(
    files: FileSystem
    scalaOutputPath: String
    jsOutputPath: String
    packagePaths: Map[String, String]
): Compiler {
    Compiler(
        files = files
        scalaOutputPath = scalaOutputPath
        jsOutputPath = jsOutputPath
        packagePaths = packagePaths
        parsedModules = Map.empty()
        resolvedModules = Map.empty()
        inferredModules = Map.empty()
        emittedModules = Set.empty()
    )
}

coreImports: List[DImport] =
    [
        "Array",
        "ArrayBuilder",
        "Bool",
        "Char",
        "Core",
        "FileSystem",
        "Int",
        "List",
        "Log",
        "Map",
        "Nothing",
        "Option",
        "Pair",
        "Set",
        "String",
        "System",
        "Try",
        "Unit"
    ].map { moduleName =>
        DImport(
            at = Location("<prelude>", 1, 1),
            alias = moduleName,
            package = Pair("ff", "core"),
            directory = [],
            file = moduleName
        )
    }

extend self: Compiler {

    parse(packageName: String, moduleName: String): Module {
        self.parsedModules.get(packageName + ":" + moduleName).else:

        let packagePair = do {
            let array = packageName.split(':')
            Pair(array.expect(0), array.expect(1))
        }
        let packagePath = self.packagePaths.expect(packageName)
        let file = moduleName + ".ff"
        let code = self.files.readText(packagePath + "/" + file)
        let tokens = Tokenizer.tokenize(file, code)
        let module = Parser.make(packagePair, file, tokens).parseModule()
        let result = module.Module(
            imports = coreImports ++ module.imports
        )

        self.parsedModules = self.parsedModules.add(packageName + ":" + moduleName, result)
        result
    }

    imports(packageName: String, module: Module): List[Module] {
        module.imports.map { import =>
            let newPackageName = import.package.first + ":" + import.package.second
            let newModuleName = import.directory.map { _ + "/" }.join("") + import.file
            self.parse(newPackageName, newModuleName)
        }
    }

    resolve(packageName: String, moduleName: String): Module {
        self.resolvedModules.get(packageName + ":" + moduleName).else:

        let module = self.parse(packageName, moduleName)
        let otherModules = self.imports(packageName, module)
        let result = Resolver.make().resolveModule(module, otherModules)

        self.resolvedModules = self.resolvedModules.add(packageName + ":" + moduleName, result)
        result
    }

    infer(packageName: String, moduleName: String): Module {
        self.inferredModules.get(packageName + ":" + moduleName).else:

        let module = self.resolve(packageName, moduleName)
        let otherModules = self.imports(packageName, module).map { i =>
            let newPackageName = i.packagePair.first + ":" + i.packagePair.second
            self.resolve(newPackageName, self.files.prefixName(i.file))
        }
        let instances = module.instances ++ otherModules.flatMap { _.instances }
        let result = Inference.make(instances).inferModule(module, otherModules)

        self.inferredModules = self.inferredModules.add(packageName + ":" + moduleName, result)
        result
    }

    emit(packageName: String, moduleName: String): Unit {
        if(self.emittedModules.contains(packageName + ":" + moduleName)) {} else:
        self.emittedModules = self.emittedModules.add(packageName + ":" + moduleName)

        let module = self.infer(packageName, moduleName)
        let otherModules = self.imports(packageName, module).map { i =>
            let newPackageName = i.packagePair.first + ":" + i.packagePair.second
            let newModuleName = self.files.prefixName(i.file)
            self.emit(newPackageName, newModuleName)
            self.infer(newPackageName, newModuleName)
        }

        let packagePair = do {
            let array = packageName.split(':')
            Pair(array.expect(0), array.expect(1))
        }

        let scala = ScalaEmitter.emitModule(packagePair, module)
        let scalaPath = self.scalaOutputPath + "/" + packageName.replace(":", "/")
        let scalaFile = scalaPath + "/" + moduleName + ".scala"
        self.files.createDirectories(scalaPath)
        self.files.writeText(scalaFile, scala)

        let js = JsEmitter.make([module, ...otherModules]).emitModule(packagePair, module)
        let jsPath = self.jsOutputPath + "/" + packageName.replace(":", "/")
        let jsFile = jsPath + "/" + moduleName + ".js"
        self.files.createDirectories(jsPath)
        self.files.writeText(jsFile, js)

    }

}
