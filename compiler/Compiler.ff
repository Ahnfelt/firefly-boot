import Syntax
import Tokenizer
import Parser
import Resolver
import Deriver
import Inference
import JsEmitter
import Dictionaries
import Dependencies

type Compiler!(
    emitTarget: EmitTarget
    files: FileSystem
    time: TimeSystem
    compilerModulePath: Option[String]
    jsOutputPath: String
    packagePaths: Map[PackagePair, String]
    singleFilePackages: Set[PackagePair]
    mutable parsedModules: Map[String, Module]
    mutable resolvedModules: Map[String, Module]
    mutable derivedModules: Map[String, Module]
    mutable inferredModules: Map[String, Module]
    mutable emittedModules: Set[String]
    mutable phaseDurations: List[Pair[String, Duration]]
    mutable phaseDurationDelta: Duration
)

make(
    emitTarget: EmitTarget
    files: FileSystem
    time: TimeSystem
    compilerModulePath: Option[String]
    jsOutputPath: String
    resolvedDependencies: ResolvedDependencies
): Compiler {
    Compiler(
        emitTarget = emitTarget
        files = files
        time = time
        compilerModulePath = compilerModulePath
        jsOutputPath = jsOutputPath
        packagePaths = resolvedDependencies.packagePaths
        singleFilePackages = resolvedDependencies.singleFilePackages
        parsedModules = Map.empty()
        resolvedModules = Map.empty()
        derivedModules = Map.empty()
        inferredModules = Map.empty()
        emittedModules = Set.empty()
        phaseDurations = [],
        phaseDurationDelta = Duration(0.0)
    )
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

coreImports: List[DImport] =
    [
        "Array"
        "AssetSystem"
        "Bool"
        "BrowserSystem"
        "Buffer"
        "BuildSystem"
        "Channel"
        "Char"
        "Core"
        "Duration"
        "Equal"
        "Error"
        "FetchSystem"
        "FileHandle"
        "FileSystem"
        "Float"
        "Instant"
        "Int"
        "JsValue"
        "JsSystem"
        "List"
        "Log"
        "Map"
        "NodeSystem"
        "Nothing"
        "Option"
        "Ordering"
        "Pair"
        "Set"
        "Show"
        "Stream"
        "String"
        "TaskSystem"
        "TimeSystem"
        "Try"
        "Unit"
        "Table"
    ].map { moduleName =>
        DImport(
            at = Location("<prelude>", 1, 1),
            alias = moduleName,
            package = PackagePair("ff", "core"),
            directory = [],
            file = moduleName
        )
    }

extend self: Compiler {

    measure[T](phase: String, packagePair: PackagePair, moduleName: String, body: () => T): T {
        let start = Duration(self.time.elapsed().seconds - self.phaseDurationDelta.seconds)
        let result = body()
        let stop = Duration(self.time.elapsed().seconds - self.phaseDurationDelta.seconds)
        let duration = Duration(stop.seconds - start.seconds)
        self.phaseDurationDelta = Duration(self.phaseDurationDelta.seconds + duration.seconds)
        let text = phase + " " + packagePair.groupName() + "/" + moduleName
        self.phaseDurations = [Pair(text, duration), ...self.phaseDurations]
        result
    }

    printMeasurements(): Unit {
        let worst = self.phaseDurations.sortBy { (_.second.seconds + 1000000.0) + "" }.takeLast(5).reverse()
        worst.each {| Pair(text, duration) =>
            Log.debug(text + ":\t" + duration.toString())
        }
    }

    parse(packagePair: PackagePair, moduleName: String): Module {
        let packageName = packagePair.groupName()
        self.parsedModules.get(packageName + ":" + moduleName).else:
        self.measure("Parse", packagePair, moduleName):

        let packagePath = self.packagePaths.get(packagePair).else {
            panic("Internal error - package path missing: " + packagePair.groupName())
        }
        let file = moduleName + ".ff"
        let code = self.files.readText(packagePath + "/" + file)
        let tokens = Tokenizer.tokenize(file, code)
        let parser = Parser.make(packagePair, file, tokens, self.emitTarget != EmitBrowser)
        let module = if(self.singleFilePackages.contains(packagePair)) {
            parser.parseModuleWithPackageInfo().module
        } else {
            parser.parseModuleWithoutPackageInfo()
        }
        let result = module.Module(
            imports = [...coreImports, ...module.imports]
        )

        self.parsedModules = self.parsedModules.add(packageName + ":" + moduleName, result)
        result
    }

    imports(module: Module): List[Module] {
        module.imports.map { import =>
            let newPackagePair = import.package
            let newModuleName = import.directory.map { _ + "/" }.join("") + import.file
            if(!self.packagePaths.contains(newPackagePair)) {
                fail(import.at, "Missing dependency declaration for: " + newPackagePair.groupName())
            }
            self.parse(newPackagePair, newModuleName)
        }
    }

    resolve(packagePair: PackagePair, moduleName: String): Module {
        let packageName = packagePair.groupName()
        self.resolvedModules.get(packageName + ":" + moduleName).else:
        self.measure("Resolve", packagePair, moduleName):

        let module = self.parse(packagePair, moduleName)
        let otherModules = self.imports(module)
        let result = Resolver.make().resolveModule(module, otherModules)

        self.resolvedModules = self.resolvedModules.add(packageName + ":" + moduleName, result)
        result
    }

    derive(packagePair: PackagePair, moduleName: String): Module {
        let packageName = packagePair.groupName()
        self.derivedModules.get(packageName + ":" + moduleName).else:
        self.measure("Derive", packagePair, moduleName):

        let module = self.resolve(packagePair, moduleName)
        let result = Deriver.make().deriveModule(module)

        self.derivedModules = self.derivedModules.add(packageName + ":" + moduleName, result)
        result
    }

    infer(packagePair: PackagePair, moduleName: String): Module {
        let packageName = packagePair.groupName()
        self.inferredModules.get(packageName + ":" + moduleName).else:
        self.measure("Infer", packagePair, moduleName):

        let module = self.derive(packagePair, moduleName)
        let otherModules = self.imports(module).map { i =>
            self.derive(i.packagePair, FileSystem.prefixName(i.file))
        }
        let inferredModule = Inference.make([module, ...otherModules]).inferModule(module, otherModules)
        let result = Dictionaries.make([module, ...otherModules]).processModule(inferredModule, otherModules)

        self.inferredModules = self.inferredModules.add(packageName + ":" + moduleName, result)
        result
    }

    emit(packagePair: PackagePair, moduleName: String, isMainModule: Bool): Unit {
        let packageName = packagePair.groupName()
        if(self.emittedModules.contains(packageName + ":" + moduleName)) {} else:
        self.measure("Emit", packagePair, moduleName):
        self.emittedModules = self.emittedModules.add(packageName + ":" + moduleName)

        let module = self.infer(packagePair, moduleName)
        let otherModules = self.imports(module).map { i =>
            let newModuleName = FileSystem.prefixName(i.file)
            self.emit(i.packagePair, newModuleName, isMainModule = False)
            self.infer(i.packagePair, newModuleName)
        }

        let js = JsEmitter.make([module, ...otherModules], self.emitTarget, isMainModule, self.compilerModulePath)
            .emitModule(packagePair, module)
        let jsPath = self.jsOutputPath + "/" + packagePair.groupName("/")
        let jsFile = jsPath + "/" + moduleName + ".mjs"
        self.files.createDirectories(jsPath)
        self.files.writeText(jsFile, js)
    }

}
