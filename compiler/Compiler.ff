import Syntax
import Tokenizer
import Parser
import Resolver
import Inference
import JsEmitter
import Dictionaries

type Compiler!(
    targetIsNode: Bool
    files: FileSystem
    time: TimeSystem
    jsOutputPath: String
    packagePaths: Map[String, String]
    mutable parsedModules: Map[String, Module]
    mutable resolvedModules: Map[String, Module]
    mutable inferredModules: Map[String, Module]
    mutable emittedModules: Set[String]
    mutable phaseDurations: List[Pair[String, Duration]]
    mutable phaseDurationDelta: Duration
)

make(
    targetIsNode: Bool
    files: FileSystem
    time: TimeSystem
    jsOutputPath: String
    packagePaths: Map[String, String]
): Compiler {
    Compiler(
        targetIsNode = targetIsNode,
        files = files
        time = time
        jsOutputPath = jsOutputPath
        packagePaths = packagePaths
        parsedModules = Map.empty()
        resolvedModules = Map.empty()
        inferredModules = Map.empty()
        emittedModules = Set.empty()
        phaseDurations = [],
        phaseDurationDelta = Duration(0.0)
    )
}

coreImports: List[DImport] =
    [
        "Array",
        "ArrayBuilder",
        "Bool",
        "BrowserSystem",
        "Buffer",
        "Channel",
        "Char",
        "Core",
        "Duration",
        "Error",
        "FetchSystem",
        "FileHandle",
        "FileSystem",
        "Float",
        "HttpServer",
        "Instant",
        "Int",
        "Iterator",
        "JsValue",
        "JsSystem",
        "List",
        "Log",
        "Map",
        "NodeSystem",
        "Nothing",
        "Option",
        "Ordering",
        "Pair",
        "Set",
        "Show",
        "Stream",
        "String",
        "TaskSystem",
        "TimeSystem",
        "Try",
        "Unit"
    ].map { moduleName =>
        DImport(
            at = Location("<prelude>", 1, 1),
            alias = moduleName,
            package = Pair("ff", "core"),
            directory = [],
            file = moduleName
        )
    }

extend self: Compiler {

    measure[T](phase: String, packageName: String, moduleName: String, body: () => T): T {
        let start = Duration(self.time.elapsed().seconds - self.phaseDurationDelta.seconds)
        let result = body()
        let stop = Duration(self.time.elapsed().seconds - self.phaseDurationDelta.seconds)
        let duration = Duration(stop.seconds - start.seconds)
        self.phaseDurationDelta = Duration(self.phaseDurationDelta.seconds + duration.seconds)
        let text = phase + " " + packageName + "/" + moduleName
        self.phaseDurations = [Pair(text, duration), ...self.phaseDurations]
        result
    }

    printMeasurements(): Unit {
        let worst = self.phaseDurations.sortBy { (_.second.seconds + 1000000.0) + "" }.takeLast(5).reverse()
        worst.each {| Pair(text, duration) =>
            Log.debug(text + ":\t" + duration.toString())
        }
    }

    parse(packageName: String, moduleName: String): Module {
        self.parsedModules.get(packageName + ":" + moduleName).else:
        self.measure("Parse", packageName, moduleName):

        let packagePair = do {
            let array = packageName.split(':')
            Pair(array.expect(0), array.expect(1))
        }
        let package = DPackage(
            at = Location("<todo>", 1, 1),
            packagePair = packagePair,
            version = Version(Location("<todo>", 1, 1), 0, 0, 0),
            targets = TargetNames(node = self.targetIsNode, browser = !self.targetIsNode)
        )
        let packagePath = self.packagePaths.expect(packageName)
        let file = moduleName + ".ff"
        let code = self.files.readText(packagePath + "/" + file)
        let tokens = Tokenizer.tokenize(file, code)
        let module = Parser.make(Some(package), file, tokens, self.targetIsNode).parseModule()
        let result = module.Module(
            imports = [...coreImports, ...module.imports]
        )

        self.parsedModules = self.parsedModules.add(packageName + ":" + moduleName, result)
        result
    }

    imports(packageName: String, module: Module): List[Module] {
        module.imports.map { import =>
            let newPackageName = import.package.first + ":" + import.package.second
            let newModuleName = import.directory.map { _ + "/" }.join("") + import.file
            self.parse(newPackageName, newModuleName)
        }
    }

    resolve(packageName: String, moduleName: String): Module {
        self.resolvedModules.get(packageName + ":" + moduleName).else:
        self.measure("Resolve", packageName, moduleName):

        let module = self.parse(packageName, moduleName)
        let otherModules = self.imports(packageName, module)
        let result = Resolver.make().resolveModule(module, otherModules)

        self.resolvedModules = self.resolvedModules.add(packageName + ":" + moduleName, result)
        result
    }

    infer(packageName: String, moduleName: String): Module {
        self.inferredModules.get(packageName + ":" + moduleName).else:
        self.measure("Infer", packageName, moduleName):

        let module = self.resolve(packageName, moduleName)
        let otherModules = self.imports(packageName, module).map { i =>
            let newPackageName = i.package.packagePair.first + ":" + i.package.packagePair.second
            self.resolve(newPackageName, FileSystem.prefixName(i.file))
        }
        let inferredModule = Inference.make([module, ...otherModules]).inferModule(module, otherModules)
        let result = Dictionaries.make([module, ...otherModules]).processModule(inferredModule, otherModules)

        self.inferredModules = self.inferredModules.add(packageName + ":" + moduleName, result)
        result
    }

    emit(packageName: String, moduleName: String): Unit {
        if(self.emittedModules.contains(packageName + ":" + moduleName)) {} else:
        self.measure("Emit", packageName, moduleName):
        self.emittedModules = self.emittedModules.add(packageName + ":" + moduleName)

        let module = self.infer(packageName, moduleName)
        let otherModules = self.imports(packageName, module).map { i =>
            let newPackageName = i.package.packagePair.first + ":" + i.package.packagePair.second
            let newModuleName = FileSystem.prefixName(i.file)
            self.emit(newPackageName, newModuleName)
            self.infer(newPackageName, newModuleName)
        }

        let packagePair = do {
            let array = packageName.split(':')
            Pair(array.expect(0), array.expect(1))
        }

        let js = JsEmitter.make([module, ...otherModules], self.targetIsNode).emitModule(packagePair, module)
        let jsPath = self.jsOutputPath + "/" + packageName.replace(":", "/")
        let jsFile = jsPath + "/" + moduleName + ".mjs"
        self.files.createDirectories(jsPath)
        self.files.writeText(jsFile, js)
    }

}
