import Syntax
import Tokenizer
import Parser
import Resolver
import Inference
import JsEmitter
import Dictionaries
import Dependencies

type Compiler!(
    targetIsNode: Bool
    files: FileSystem
    time: TimeSystem
    jsOutputPath: String
    packagePaths: Map[PackagePair, String]
    singleFilePackages: Set[PackagePair]
    mutable parsedModules: Map[String, Module]
    mutable resolvedModules: Map[String, Module]
    mutable inferredModules: Map[String, Module]
    mutable emittedModules: Set[String]
    mutable phaseDurations: List[Pair[String, Duration]]
    mutable phaseDurationDelta: Duration
)

make(
    targetIsNode: Bool
    files: FileSystem
    time: TimeSystem
    jsOutputPath: String
    resolvedDependencies: ResolvedDependencies
): Compiler {
    Compiler(
        targetIsNode = targetIsNode,
        files = files
        time = time
        jsOutputPath = jsOutputPath
        packagePaths = resolvedDependencies.packagePaths
        singleFilePackages = resolvedDependencies.singleFilePackages
        parsedModules = Map.empty()
        resolvedModules = Map.empty()
        inferredModules = Map.empty()
        emittedModules = Set.empty()
        phaseDurations = [],
        phaseDurationDelta = Duration(0.0)
    )
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

coreImports: List[DImport] =
    [
        "Array",
        "ArrayBuilder",
        "Bool",
        "BrowserSystem",
        "BuildSystem",
        "Buffer",
        "Channel",
        "Char",
        "Core",
        "Duration",
        "Error",
        "FetchSystem",
        "FileHandle",
        "FileSystem",
        "Float",
        "HttpServer",
        "Instant",
        "Int",
        "Iterator",
        "JsValue",
        "JsSystem",
        "List",
        "Log",
        "Map",
        "NodeSystem",
        "Nothing",
        "Option",
        "Ordering",
        "Pair",
        "Set",
        "Show",
        "Stream",
        "String",
        "TaskSystem",
        "TimeSystem",
        "Try",
        "Unit"
    ].map { moduleName =>
        DImport(
            at = Location("<prelude>", 1, 1),
            alias = moduleName,
            package = PackagePair("ff", "core"),
            directory = [],
            file = moduleName
        )
    }

extend self: Compiler {

    measure[T](phase: String, packagePair: PackagePair, moduleName: String, body: () => T): T {
        let start = Duration(self.time.elapsed().seconds - self.phaseDurationDelta.seconds)
        let result = body()
        let stop = Duration(self.time.elapsed().seconds - self.phaseDurationDelta.seconds)
        let duration = Duration(stop.seconds - start.seconds)
        self.phaseDurationDelta = Duration(self.phaseDurationDelta.seconds + duration.seconds)
        let text = phase + " " + packagePair.groupName() + "/" + moduleName
        self.phaseDurations = [Pair(text, duration), ...self.phaseDurations]
        result
    }

    printMeasurements(): Unit {
        let worst = self.phaseDurations.sortBy { (_.second.seconds + 1000000.0) + "" }.takeLast(5).reverse()
        worst.each {| Pair(text, duration) =>
            Log.debug(text + ":\t" + duration.toString())
        }
    }

    parse(packagePair: PackagePair, moduleName: String): Module {
        let packageName = packagePair.groupName()
        self.parsedModules.get(packageName + ":" + moduleName).else:
        self.measure("Parse", packagePair, moduleName):

        let packagePath = self.packagePaths.expect(packagePair)
        let file = moduleName + ".ff"
        let code = self.files.readText(packagePath + "/" + file)
        let tokens = Tokenizer.tokenize(file, code)
        let parser = Parser.make(packagePair, file, tokens, self.targetIsNode)
        let module = if(self.singleFilePackages.contains(packagePair)) {
            parser.parseModuleWithPackageInfo().module
        } else {
            parser.parseModuleWithoutPackageInfo()
        }
        let result = module.Module(
            imports = [...coreImports, ...module.imports]
        )

        self.parsedModules = self.parsedModules.add(packageName + ":" + moduleName, result)
        result
    }

    imports(module: Module): List[Module] {
        module.imports.map { import =>
            let newPackagePair = import.package
            let newModuleName = import.directory.map { _ + "/" }.join("") + import.file
            if(!self.packagePaths.contains(newPackagePair)) {
                fail(import.at, "Missing dependency declaration for: " + newPackagePair.groupName())
            }
            self.parse(newPackagePair, newModuleName)
        }
    }

    resolve(packagePair: PackagePair, moduleName: String): Module {
        let packageName = packagePair.groupName()
        self.resolvedModules.get(packageName + ":" + moduleName).else:
        self.measure("Resolve", packagePair, moduleName):

        let module = self.parse(packagePair, moduleName)
        let otherModules = self.imports(module)
        let result = Resolver.make().resolveModule(module, otherModules)

        self.resolvedModules = self.resolvedModules.add(packageName + ":" + moduleName, result)
        result
    }

    infer(packagePair: PackagePair, moduleName: String): Module {
        let packageName = packagePair.groupName()
        self.inferredModules.get(packageName + ":" + moduleName).else:
        self.measure("Infer", packagePair, moduleName):

        let module = self.resolve(packagePair, moduleName)
        let otherModules = self.imports(module).map { i =>
            self.resolve(i.packagePair, FileSystem.prefixName(i.file))
        }
        let inferredModule = Inference.make([module, ...otherModules]).inferModule(module, otherModules)
        let result = Dictionaries.make([module, ...otherModules]).processModule(inferredModule, otherModules)

        self.inferredModules = self.inferredModules.add(packageName + ":" + moduleName, result)
        result
    }

    emit(packagePair: PackagePair, moduleName: String): Unit {
        let packageName = packagePair.groupName()
        if(self.emittedModules.contains(packageName + ":" + moduleName)) {} else:
        self.measure("Emit", packagePair, moduleName):
        self.emittedModules = self.emittedModules.add(packageName + ":" + moduleName)

        let module = self.infer(packagePair, moduleName)
        let otherModules = self.imports(module).map { i =>
            let newModuleName = FileSystem.prefixName(i.file)
            self.emit(i.packagePair, newModuleName)
            self.infer(i.packagePair, newModuleName)
        }

        let js = JsEmitter.make([module, ...otherModules], self.targetIsNode).emitModule(packagePair, module)
        let jsPath = self.jsOutputPath + "/" + packagePair.groupName("/")
        let jsFile = jsPath + "/" + moduleName + ".mjs"
        self.files.createDirectories(jsPath)
        self.files.writeText(jsFile, js)
    }

}
