import Parser
import Syntax
import Tokenizer
import Workspace

type Dependencies(
    workspace: Workspace
    mutable packages: Map[PackagePair, PackageInfo]
    mutable packagePaths: Map[String, String]
    mutable singleFilePackages: Set[PackagePair]
)

type ResolvedDependencies(
    packagePaths: Map[String, String]
    singleFilePackages: Set[PackagePair]
)

extend self: Dependencies {

    loadPackageInfo(
        fs: FileSystem
        packagePair: PackagePair
        path: String
    ): PackageInfo {
        let packageDirectory = if(path.endsWith(".ff")) { FileSystem.directoryName(path) } else { path }
        let sharedPackageFile = packageDirectory + "/.firefly/package.ff"
        let packageFile = if(fs.exists(sharedPackageFile)) {
            sharedPackageFile
        } else {
            self.singleFilePackages = self.singleFilePackages.add(packagePair)
            path
        }
        let code = fs.readText(packageFile)
        let tokens = Tokenizer.tokenize(packageFile, code)
        let parser = Parser.make(packagePair, packageFile, tokens, False)
        parser.parsePackageInfo()
    }

    processPackageInfo(
        packageInfo: PackageInfo
    ): List[DDependency] {
        self.packages = self.packages.add(packageInfo.package.packagePair, packageInfo)
        packageInfo.dependencies.filter { !self.packages.contains(_.packagePair) }
    }

    fetchDependency(
        fs: FileSystem
        dependency: DDependency
    ): String {
        let location = self.workspace.findPackageLocation(dependency.packagePair, dependency.version)
        if(location.contains(":")) {
            panic("Loading packages by URL is not yet supported: " + location)
        } else {
            location
        }
    }

    processDependencies(
        fs: FileSystem
        dependencies: List[DDependency]
    ): Unit {
        // Remember to check for cycles
        let packageInfos = dependencies.map { dependency =>
            let path = self.fetchDependency(fs, dependency)
            let packageString = dependency.packagePair.group + ":" + dependency.packagePair.name
            self.packagePaths = self.packagePaths.add(packageString, path)
            let packageInfo = self.loadPackageInfo(fs, dependency.packagePair, path)
            checkPackagePairs(dependency.packagePair, packageInfo.package.packagePair)
            packageInfo
        }
        let newDependencies = packageInfos.flatMap { self.processPackageInfo(_) }
        if(newDependencies != []) {
            self.processDependencies(fs, newDependencies)
        }
    }

}

process(fs: FileSystem, path: String): ResolvedDependencies {
    let workspace = Workspace.loadWorkspace(fs, path)
    let self = Dependencies(workspace, [].toMap(), [].toMap(), [].toSet())
    let packageInfo = self.loadPackageInfo(fs, PackagePair("script", "script"), path)
    let newDependencies = self.processPackageInfo(packageInfo)
    self.processDependencies(fs, newDependencies)
    ResolvedDependencies(
        packagePaths = self.packagePaths
        singleFilePackages = self.singleFilePackages
    )
}

checkPackagePairs(dependencyPair : PackagePair, packagePair: PackagePair): Unit {
    if(
        packagePair.group != dependencyPair.group ||
        packagePair.name != dependencyPair.name
    ) {
        panic(
            "Dependency declaration and package declaration disagree on package name: " +
            dependencyPair.group + ":" + dependencyPair.name + " vs. " +
            packagePair.group + ":" + packagePair.name
        )
    }
}
