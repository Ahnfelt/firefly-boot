import Parser
import Syntax
import Tokenizer
import Workspace

type Dependencies(
    workspace: Workspace
    mutable packages: Map[PackagePair, PackageInfo]
    mutable packagePaths: Map[PackagePair, String]
    mutable singleFilePackages: Set[PackagePair]
)

type ResolvedDependencies(
    mainPackagePair: PackagePair
    packages: Map[PackagePair, PackageInfo]
    packagePaths: Map[PackagePair, String]
    singleFilePackages: Set[PackagePair]
)

extend self: Dependencies {

    loadPackageInfo(
        fs: FileSystem
        packagePair: PackagePair
        path: String
    ): PackageInfo {
        let packageDirectory = if(path.endsWith(".ff")) { FileSystem.directoryName(path) } else { path }
        let sharedPackageFile = packageDirectory + "/.firefly/package.ff"
        let packageFile = if(fs.exists(sharedPackageFile)) {
            sharedPackageFile
        } else {
            self.singleFilePackages = self.singleFilePackages.add(packagePair)
            path
        }
        let code = fs.readText(packageFile)
        let tokens = Tokenizer.tokenize(packageFile, code)
        let parser = Parser.make(packagePair, packageFile, tokens, False)
        let info = parser.parsePackageInfo()
        self.addCoreDependencyIfMissing(info)
    }

    addCoreDependencyIfMissing(info: PackageInfo): PackageInfo {
        if(info.dependencies.any { d =>
            d.packagePair.group == "ff" && d.packagePair.name == "core"
        }) {
            info
        } else {
            let coreDependency = DDependency(
                at = info.package.at
                packagePair = PackagePair("ff", "core")
                version = Version(info.package.at, 0, 0, 0)
                safety = Trusted
                targets = info.package.targets
            )
            info.PackageInfo(dependencies = [coreDependency, ...info.dependencies])
        }
    }

    processPackageInfo(
        packageInfo: PackageInfo
    ): List[DDependency] {
        self.packages = self.packages.add(packageInfo.package.packagePair, packageInfo)
        packageInfo.dependencies.filter { !self.packages.contains(_.packagePair) }
    }

    fetchDependency(
        fs: FileSystem
        fetch: FetchSystem
        dependency: DDependency
    ): String {
        let location = self.workspace.findPackageLocation(dependency.packagePair, dependency.version)
        if(location.contains(":")) {
            if(location.startsWith("http://") || location.startsWith("https://")) {
                let packagePair = dependency.packagePair
                let dependenciesPath = ".firefly/dependencies"
                let dependencyPath = dependenciesPath + "/" + packagePair.group + "/" + packagePair.name
                let tarGzPath = dependenciesPath + "/" + Workspace.tarGzName(packagePair, dependency.version)
                let donePath = dependenciesPath + "/" + Workspace.tarGzName(packagePair, dependency.version) + ".done"
                if(!fs.exists(donePath)) {
                    Log.debug("Fetching " + location)
                    let response = fetch.fetch(location, throw = False)
                    if(!response.ok()) {
                        panic("Could not download dependency: " + location)
                    }
                    let buffer = response.readBuffer()
                    if(fs.exists(dependencyPath)) {
                        fs.deleteDirectory(dependencyPath)
                    }
                    fs.createDirectories(dependencyPath)
                    fs.writeStream(tarGzPath, Stream { [buffer].toIterator() })
                    internalExtractTarGz(fs, tarGzPath, dependencyPath)
                    fs.rename(tarGzPath, donePath)
                }
                dependencyPath
            } else {
                panic("Loading packages by this protocol is not supported: " + location)
            }
        } else {
            location
        }
    }

    processDependencies(
        fs: FileSystem
        fetch: FetchSystem
        dependencies: List[DDependency]
    ): Unit {
        // Remember to check for cycles
        let packageInfos = dependencies.map { dependency =>
            let path = self.fetchDependency(fs, fetch, dependency)
            self.packagePaths = self.packagePaths.add(dependency.packagePair, path)
            let packageInfo = self.loadPackageInfo(fs, dependency.packagePair, path)
            checkPackagePairs(dependency.packagePair, packageInfo.package.packagePair)
            packageInfo
        }
        let newDependencies = packageInfos.flatMap { self.processPackageInfo(_) }
        if(newDependencies != []) {
            self.processDependencies(fs, fetch, newDependencies)
        }
    }

}

process(fs: FileSystem, fetch: FetchSystem, path: String): ResolvedDependencies {
    let workspace = Workspace.loadWorkspace(fs, path)
    let self = Dependencies(workspace, [].toMap(), [].toMap(), [].toSet())
    let packageInfo = self.loadPackageInfo(fs, PackagePair("script", "script"), path)
    let newDependencies = self.processPackageInfo(packageInfo)
    self.processDependencies(fs, fetch, newDependencies)
    ResolvedDependencies(
        mainPackagePair = packageInfo.package.packagePair
        packages = self.packages
        packagePaths = self.packagePaths
        singleFilePackages = self.singleFilePackages
    )
}

checkPackagePairs(dependencyPair : PackagePair, packagePair: PackagePair): Unit {
    if(
        packagePair.group != dependencyPair.group ||
        packagePair.name != dependencyPair.name
    ) {
        panic(
            "Dependency declaration and package declaration disagree on package name: " +
            dependencyPair.groupName() + " vs. " + packagePair.groupName()
        )
    }
}

internalExtractTarGz(fs: FileSystem, tarGzPath: String, path: String): Unit
    target node async """
        import * as tar from 'tar'
        await tar.extract({file: tarGzPath_, cwd: path_, strict: true})
    """
