type Effects(
    mutable effectVariables: Map[Int, Effect]
    mutable nextEffectVariableIndex: Int
)

type Effect(
    at: Location
    mutable alwaysAsync: Boolean
    mutable unionVariables: Set[Int]
    mutable unionParameters: Set[String]
)

extend self: Effect {
    affectBy(source: Type): Unit {
        | TConstructor(_, "Union$", [t1, t2]) =>
            self.affectBy(t1)
            self.affectBy(t2)
        | TConstructor(_, "Async$", []) =>
            self.alwaysAsync = True
        | TConstructor(_, "Sync$", []) =>
        | TConstructor(_, name, []) {name.startsWith("Q$")} =>
            self.unionParameters = self.unionParameters.add(name)
        | TConstructor _ =>
            fail(source.at, "Not an effect: " + source.show())
        | TVariable(_, index) =>
            self.unionVariables = self.unionVariables.add(index)
    }
}

make(): Effects {
    Effects([].toMap(), 1)
}

fail[T](at: Location, message: String): T {
    panic(message + " " + at.show())
}

// Represent effects as types in the AST.
// function foo[A, B, q1, q2](bar: Bar[A, q1], f: A =q2> B) =q1|q2> B
// A =q1> B    is represented as   Function$1[A, Effect$[B, q1]]   which is   TConstructor(at, "Function$1", [...])
// =q1|q2> B   is represented as   Effect$[B, q1|q2]               which is   TConstructor(at, "Effect$", [...])
// q1|q2       is represented as   Union$[q1, q2]                  which is   TConstructor(at, "Union$", [...])
// Async       is represented as   Async$[]                        which is   TConstructor(at, "Async$", [])
// Sync        is represented as   Sync$[]                         which is   TConstructor(at, "Sync$", [])
// q1          is represented as   Q$1[]                           which is   TConstructor(at, "Q$1", [])
// #1          is represented as   $1                              which is   TVariable(at, 1)

extend self: Effects {

    freshEffectVariable(at: Location): Type {
        let result = TVariable(at, self.nextEffectVariableIndex)
        let effect = Effect(at, False, [].toSet(), [].toSet())
        self.effectVariables = self.effectVariables.add(self.nextEffectVariableIndex, effect)
        self.nextEffectVariableIndex += 1
        result
    }

    affect(at: Location, target: Type, source: Type): Unit {
        | _, TVariable(_, i), t => self.effectVariables.expect(i).affectBy(t)
        | _, TConstructor(_, name1, generics1), TConstructor(_, name2, generics2) =>
            if(name1 != name2 || generics1.size() != generics2.size()) {
                fail(at, "Type mismatch: " + t1.show() + " vs. " + t2.show())
            }
            generics1.zip(generics2).each {| Pair(t1, t2) => self.affect(at, t1, t2) }
    }

    processTerm(target: Effect, term: Term): Unit {
        term.{
            | EString _ =>
            | EChar _ =>
            | EInt _ =>
            | EFloat _ =>
            | EVariable _ =>
            | EField e => self.processTerm(target, e.record)
            | EWildcard e =>
            | EList e =>
                e.items.each {| Pair(item, b) => self.processTerm(target, item) }
            | ESequential e =>
                self.processTerm(target, e.before)
                self.processTerm(target, e.after)
            )
            | ELet e =>
                self.processTerm(target, e.value)
                self.processTerm(target, e.body)
            | ELambda e =>
                // Can never have an effect? self.processLambda(target, e.lambda)
                // But obviously it should have an effect, when later called
            | EVariant e =>
                e.arguments.each { _.each { self.processTerm(target, _.value) } }
            | EVariantIs e =>
            | ECopy e =>
                self.processTerm(Target, e.record)
                e.arguments.each { self.processTerm(target, _.value) }
            | EPipe e =>
                self.processTerm(target, e.value)
                self.processTerm(target, e.function)
            | ECall e =>
                self.processTerm(target, e.function)
                e.arguments.each { self.processTerm(target, _.value) }
            | ERecord e =>
                e.fields.each { self.processTerm(target, value) }
            | EFunctions e =>
                e.functions.each { self.processFunctionDefinition(target, _) }
                self.processTerm(target, e.body)
            | EAssign e =>
                self.processTerm(target, e.value)
            | EAssignField e =>
                self.processTerm(target, e.record)
                self.processTerm(target, e.value)
        }
    }

}

// What if there could only be one effect parameter in scope at any given point? Gets rid of the union?
// function foo[A, B, q](bar: Bar[A, q], f: A =q> B) =q> B
// A =q> B   is represented as   Function$1[A, Effect$[B, q]]   which is   TConstructor(at, "Function$1", [...])
// =q> B     is represented as   Effect$[B, q]                  which is   TConstructor(at, "Effect$", [...])
// Async     is represented as   Async$[]                       which is   TConstructor(at, "Async$", [])
// Sync      is represented as   Sync$[]                        which is   TConstructor(at, "Sync$", [])
// q         is represented as   Q$[]                           which is   TConstructor(at, "Q$", [])
// #1        is represented as   $1                             which is   TVariable(at, 1)
