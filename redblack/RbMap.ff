// Based on https://github.com/Abhiroop/okasaki/blob/master/src/RedBlackTree.hs

type RbMap[K, V] {
    RbLeaf
    RbNode(isRed: Bool, left: RbMap[K, V], key: K, value: V, right: RbMap[K, V])
}

extend self[K, V]: RbMap[K, V] {

    get(key: K): Option[V] {
        self.{
            | RbLeaf => None
            | RbNode(_, l, k, _, _) {magicLess(key, k)} => l.get(key)
            | RbNode(_, _, k, _, r) {magicLess(k, key)} => r.get(key)
            | RbNode(_, _, _, v, _) => Some(v)
        }
    }

    add(key: K, value: V): RbMap[K, V] {
        function go(self: RbMap[K, V]): RbMap[K, V] {
            self.{
                | RbLeaf => RbNode(True, RbLeaf, key, value, RbLeaf)
                | RbNode(c, l, k, v, r) {magicLess(key, k)} => RbNode(c, go(l), k, v, r).balance()
                | RbNode(c, l, k, v, r) {magicLess(k, key)} => RbNode(c, l, k, v, go(r)).balance()
                | RbNode(c, l, _, _, r) => RbNode(c, l, key, value, r)
            }
        }
        go(self).{
            | RbNode(True, l, k, v, r) => RbNode(False, l, k, v, r)
            | n => n
        }
    }

    /*remove(key: K): RbMap[K, V] {
        function goLeft(self: RbMap[K, V]): RbMap[K, V] {
            self.{
                | RbLeaf => self
                | RbNode(c, l, k, v, r) {!l.isRed} => balanceLeft(RbNode(False, go(l), k, v, r))
                | RbNode(c, l, k, v, r) => balanceLeft(RbNode(True, go(l), k, v, r))
            }
        }
        function goRight(self: RbMap[K, V]): RbMap[K, V] {
            self.{
                | RbLeaf => self
                | RbNode(c, l, k, v, r) {!r.isRed} => balanceRight(RbNode(False, l, k, v, go(r)))
                | RbNode(c, l, k, v, r) => balanceRight(RbNode(True, l, k, v, go(r)))
            }
        }
        function go(self: RbMap[K, V]): RbMap[K, V] {
            self.{
                | RbLeaf => self
                | RbNode(_, _, k, _, _) {key < k} => goLeft(self)
                | RbNode(_, _, k, _, _) {key > k} => goRight(self)
                | _ => fuse(self)
            }
        }
        go(self).{
            | RbNode n {n.isRed} => n.RbNode(isRed = False)
            | n => n
        }
    }*/

    balance(): RbMap[K, V] {
        self.{
            | RbNode(False, RbNode(True, RbNode(True, a, k1, v1, b), k2, v2, c), k3, v3, d) => RbNode(True, RbNode(False, a, k1, v1, b), k2, v2, RbNode(False, c, k3, v3, d))
            | RbNode(False, RbNode(True, a, k1, v1, RbNode(True, b, k2, v2, c)), k3, v3, d) => RbNode(True, RbNode(False, a, k1, v1, b), k2, v2, RbNode(False, c, k3, v3, d))
            | RbNode(False, a, k1, v1, RbNode(True, RbNode(True, b, k2, v2, c), k3, v3, d)) => RbNode(True, RbNode(False, a, k1, v1, b), k2, v2, RbNode(False, c, k3, v3, d))
            | RbNode(False, a, k1, v1, RbNode(True, b, k2, v2, RbNode(True, c, k3, v3, d))) => RbNode(True, RbNode(False, a, k1, v1, b), k2, v2, RbNode(False, c, k3, v3, d))
            | _ => self
        }
    }

}
